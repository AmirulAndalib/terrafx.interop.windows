<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AbortDoc">
    <summary>
      <para>The <b>AbortDoc</b> function stops the current print job and erases everything drawn since the last call to the <see cref="StartDoc" /> function.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context for the print job.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero.</para>
      <para>If the function fails, the return value is SP_ERROR.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>AbortDoc</b> function to stop a print job if an error occurs, or to stop a print job after the user cancels that job. To end a successful print job, an application should call the <see cref="EndDoc" /> function.</para>
      <para>If Print Manager was used to start the print job, calling <b>AbortDoc</b> erases the entire spool job, so that the printer receives nothing. If Print Manager was not used to start the print job, the data may already have been sent to the printer. In this case, the printer driver resets the printer (when possible) and ends the print job.</para>
    </remarks>
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="SetAbortProc" />
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.AbortPath">
    <summary>
      <para>The <b>AbortPath</b> function closes and discards any paths in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context from which a path will be discarded.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If there is an open path bracket in the given device context, the path bracket is closed and the path is discarded. If there is a closed path in the device context, the path is discarded.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="EndPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
  </member>
  <member name="Windows.AddFontMemResourceEx">
    <summary>
      <para>The <b>AddFontMemResourceEx</b> function adds the font resource from a memory image to the system.</para>
    </summary>
    <param name="pFileView">
      <para>A pointer to a font resource.</para>
    </param>
    <param name="cjSize">
      <para>The number of bytes in the font resource that is pointed to by <i>pbFont</i>.</para>
    </param>
    <param name="pvResrved">
      <para>Reserved. Must be 0.</para>
    </param>
    <param name="pNumFonts">
      <para>A pointer to a variable that specifies the number of fonts installed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the handle to the font added. This handle uniquely identifies the fonts that were installed on the system. If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows an application to get a font that is embedded in a document or a webpage. A font that is added by <b>AddFontMemResourceEx</b> is always private to the process that made the call and is not enumerable.</para>
      <para>A memory image can contain more than one font. When this function succeeds, <i>pcFonts</i> is a pointer to a <b>DWORD</b> whose value is the number of fonts added to the system as a result of this call. For example, this number could be 2 for the vertical and horizontal faces of an Asian font.</para>
      <para>When the function succeeds, the caller of this function can free the memory pointed to by <i>pbFont</i> because the system has made its own copy of the memory. To remove the fonts that were installed, call <see cref="RemoveFontMemResourceEx" />. However, when the process goes away, the system will unload the fonts even if the process did not call <see cref="RemoveFontMemResource" />.</para>
    </remarks>
    <seealso cref="DESIGNVECTOR " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontMemResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResource">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceA">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceW">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceEx">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceExA">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceExW">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceEx">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceExA">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceExW">
    <summary>
      <para>The <b>AddFontResourceEx</b> function adds the font resource from the specified file to the system. Fonts added with the <b>AddFontResourceEx</b> function can be marked as private and not enumerable.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, point <i>lpszFileName</i> to a string with the file names separated by a | --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be added to the system. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FR_PRIVATE</b>
          </description>
          <description>
            <para>Specifies that only the process that called the <b>AddFontResourceEx</b> function can use this font. When the font name matches a public font, the private font will be chosen. When the process terminates, the system will remove all fonts installed by the process with the <b>AddFontResourceEx</b> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FR_NOT_ENUM</b>
          </description>
          <description>
            <para>Specifies that no process, including the process that called the <b>AddFontResourceEx</b> function, can enumerate this font.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="res">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function allows a process to use fonts without allowing other processes access to the fonts.</para>
      <para>When an application no longer needs a font resource it loaded by calling the <b>AddFontResourceEx</b> function, it must remove the resource by calling the <see cref="RemoveFontResourceEx" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResource">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceA">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AddFontResourceW">
    <summary>
      <para>The <b>AddFontResource</b> function adds the font resource from the specified file to the system font table. The font can subsequently be used for text output by any application.</para>
      <para>To mark a font as private or not enumerable, use the <see cref="AddFontResourceEx" /> function.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A pointer to a null-terminated character string that contains a valid font file name. This parameter can specify any of the following files.</para>
      <list type="table">
        <listheader>
          <description>File Extension</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>.fon</b>
          </description>
          <description>
            <para>Font resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fnt</b>
          </description>
          <description>
            <para>Raw bitmap font file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttf</b>
          </description>
          <description>
            <para>Raw TrueType file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.ttc</b>
          </description>
          <description>
            <para>East Asian Windows: TrueType font collection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.fot</b>
          </description>
          <description>
            <para>TrueType resource file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.otf</b>
          </description>
          <description>
            <para>PostScript OpenType font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.mmm</b>
          </description>
          <description>
            <para>Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfb</b>
          </description>
          <description>
            <para>Type 1 font bits file. It is used with a .pfm file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>.pfm</b>
          </description>
          <description>
            <para>Type 1 font metrics file. It is used with a .pfb file.</para>
          </description>
        </item>
      </list>
      <para>To add a font whose information comes from several resource files, have <i>lpszFileName</i> point to a string with the file names separated by a "|" --for example, abcxxxxx.pfm | abcxxxxx.pfb.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of fonts added.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>Any application that adds or removes fonts from the system font table should notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the operating system. The application should send this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function and setting the <i>hwnd</i> parameter to HWND_BROADCAST.</para>
      <para>When an application no longer needs a font resource that it loaded by calling the <b>AddFontResource</b> function, it must remove that resource by calling the <see cref="RemoveFontResource" /> function.</para>
      <para>This function installs the font only for the current session. When the system restarts, the font will not be present. To have the font installed even after restarting the system, the font must be listed in the registry.</para>
      <para>A font listed in the registry and installed to a location other than the %windir%\fonts\ folder cannot be modified, deleted, or replaced as long as it is loaded in any session. In order to change one of these fonts, it must first be removed by calling <see cref="RemoveFontResource" />, removed from the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>), and the system restarted. After restarting the system, the font will no longer be loaded and can be changed.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines AddFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResource " />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.AlphaBlend">
    <summary>
      <para>The <b>AlphaBlend</b> function displays bitmaps that have transparent or semitransparent pixels.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xoriginDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yoriginDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="wDest">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hDest">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xoriginSrc">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="yoriginSrc">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="wSrc">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="hSrc">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="ftn">
      <para>The alpha-blending function for source and destination bitmaps, a global alpha value to be applied to the entire source bitmap, and format information for the source bitmap. The source and destination blend functions are currently limited to AC_SRC_OVER. See the <see cref="BLENDFUNCTION" /> and <see cref="EMRALPHABLEND" /> structures.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>If the source rectangle and destination rectangle are not the same size, the source bitmap is stretched to match the destination rectangle. If the <see cref="SetStretchBltMode" /> function is used, the <i>iStretchMode</i> value is automatically converted to COLORONCOLOR for this function (that is, BLACKONWHITE, WHITEONBLACK, and HALFTONE are changed to COLORONCOLOR).</para>
      <para>The destination coordinates are transformed by using the transformation currently specified for the destination device context. The source coordinates are transformed by using the transformation currently specified for the source device context.</para>
      <para>An error occurs (and the function returns <b>FALSE</b>) if the source device context identifies an enhanced metafile device context.</para>
      <para>If destination and source bitmaps do not have the same color format, <b>AlphaBlend</b> converts the source bitmap to match the destination bitmap.</para>
      <para>
        <b>AlphaBlend</b> does not support mirroring. If either the width or height of the source or destination is negative, this call will fail.</para>
      <para>When rendering to a printer, first call <see cref="GetDeviceCaps" /> with SHADEBLENDCAPS to determine if the printer supports blending with <b>AlphaBlend</b>. Note that, for a display DC, all blending operations are supported and these flags represent whether the operations are accelerated.</para>
      <para>If the source and destination are the same surface, that is, they are both the screen or the same memory bitmap and the source and destination rectangles overlap, an error occurs and the function returns <b>FALSE</b>.</para>
      <para>The source rectangle must lie completely within the source surface, otherwise an error occurs and the function returns <b>FALSE</b>.</para>
      <para>
        <b>AlphaBlend</b> fails if the width or height of the source or destination is negative.</para>
      <para>The <b>SourceConstantAlpha</b> member of <see cref="BLENDFUNCTION" /> specifies an alpha transparency value to be used on the entire source bitmap. The <b>SourceConstantAlpha</b> value is combined with any per-pixel alpha values. If <b>SourceConstantAlpha</b> is 0, it is assumed that the image is transparent. Set the <b>SourceConstantAlpha</b> value to 255 (which indicates that the image is opaque) when you only want to use per-pixel alpha values.</para>
    </remarks>
    <seealso cref="BLENDFUNCTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="EMRALPHABLEND" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="SetStretchBltMode" />
  </member>
  <member name="Windows.AngleArc">
    <summary>
      <para>The <b>AngleArc</b> function draws a line segment and an arc. The line segment is drawn from the current position to the beginning of the arc. The arc is drawn along the perimeter of a circle with the given radius and center. The length of the arc is defined by the given start and sweep angles.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context.</para>
    </param>
    <param name="x">
      <para>Specifies the x-coordinate, in logical units, of the center of the circle.</para>
    </param>
    <param name="y">
      <para>Specifies the y-coordinate, in logical units, of the center of the circle.</para>
    </param>
    <param name="r">
      <para>Specifies the radius, in logical units, of the circle. This value must be positive.</para>
    </param>
    <param name="StartAngle">
      <para>Specifies the start angle, in degrees, relative to the x-axis.</para>
    </param>
    <param name="SweepAngle">
      <para>Specifies the sweep angle, in degrees, relative to the starting angle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>AngleArc</b> function moves the current position to the ending point of the arc.</para>
      <para>The arc drawn by this function may appear to be elliptical, depending on the current transformation and mapping mode. Before drawing the arc, <b>AngleArc</b> draws the line segment from the current position to the beginning of the arc.</para>
      <para>The arc is drawn by constructing an imaginary circle around the specified center point with the specified radius. The starting point of the arc is determined by measuring counterclockwise from the x-axis of the circle by the number of degrees in the start angle. The ending point is similarly located by measuring counterclockwise from the starting point by the number of degrees in the sweep angle.</para>
      <para>If the sweep angle is greater than 360 degrees, the arc is swept multiple times.</para>
      <para>This function draws lines by using the current pen. The figure is not filled.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-pie-chart">Drawing a Pie Chart</a>.</para>
    </remarks>
    <seealso cref="Arc" />
    <seealso cref="ArcTo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
  </member>
  <member name="Windows.AnimatePalette">
    <summary>
      <para>The <b>AnimatePalette</b> function replaces entries in the specified logical palette.</para>
    </summary>
    <param name="hPal">
      <para>A handle to the logical palette.</para>
    </param>
    <param name="iStartIndex">
      <para>The first logical palette entry to be replaced.</para>
    </param>
    <param name="cEntries">
      <para>The number of entries to be replaced.</para>
    </param>
    <param name="ppe">
      <para>A pointer to the first member in an array of <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures used to replace the current entries.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>The <b>AnimatePalette</b> function only changes entries with the PC_RESERVED flag set in the corresponding <b>palPalEntry</b> member of the <see cref="LOGPALETTE" /> structure.</para>
      <para>If the given palette is associated with the active window, the colors in the palette are replaced immediately.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="CreatePalette" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="LOGPALETTE" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</seealso>
  </member>
  <member name="Windows.Arc">
    <summary>
      <para>The <b>Arc</b> function draws an elliptical arc.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context where drawing takes place.</para>
    </param>
    <param name="x1">
      <para>The x-coordinate, in logical units, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="y1">
      <para>The y-coordinate, in logical units, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="x2">
      <para>The x-coordinate, in logical units, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="y2">
      <para>The y-coordinate, in logical units, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="x3">
      <para>The x-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.</para>
    </param>
    <param name="y3">
      <para>The y-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.</para>
    </param>
    <param name="x4">
      <para>The x-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.</para>
    </param>
    <param name="y4">
      <para>The y-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.</para>
    </param>
    <returns>
      <para>If the arc is drawn, the return value is nonzero.</para>
      <para>If the arc is not drawn, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The points (<i>nLeftRect</i>, <i>nTopRect</i>) and (<i>nRightRect</i>, <i>nBottomRect</i>) specify the bounding rectangle. An ellipse formed by the specified bounding rectangle defines the curve of the arc. The arc extends in the current drawing direction from the point where it intersects the radial from the center of the bounding rectangle to the (<i>nXStartArc</i>, <i>nYStartArc</i>) point. The arc ends where it intersects the radial from the center of the bounding rectangle to the (<i>nXEndArc</i>, <i>nYEndArc</i>) point. If the starting point and ending point are the same, a complete ellipse is drawn.</para>
      <para>The arc is drawn using the current pen; it is not filled.</para>
      <para>The current position is neither used nor updated by <b>Arc</b>.</para>
      <para>Use the <see cref="GetArcDirection" /> and <see cref="SetArcDirection" /> functions to get and set the current drawing direction for a device context. The default drawing direction is counterclockwise.</para>
    </remarks>
    <seealso cref="AngleArc" />
    <seealso cref="ArcTo" />
    <seealso cref="Chord" />
    <seealso cref="Ellipse" />
    <seealso cref="GetArcDirection" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="Pie" />
    <seealso cref="SetArcDirection" />
  </member>
  <member name="Windows.ArcTo">
    <summary>
      <para>The <b>ArcTo</b> function draws an elliptical arc.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context where drawing takes place.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical units, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical units, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical units, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical units, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="xr1">
      <para>The x-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.</para>
    </param>
    <param name="yr1">
      <para>The y-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.</para>
    </param>
    <param name="xr2">
      <para>The x-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.</para>
    </param>
    <param name="yr2">
      <para>The y-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>ArcTo</b> is similar to the <see cref="Arc" /> function, except that the current position is updated.</para>
      <para>The points (<i>nLeftRect</i>, <i>nTopRect</i>) and (<i>nRightRect</i>, <i>nBottomRect</i>) specify the bounding rectangle. An ellipse formed by the specified bounding rectangle defines the curve of the arc. The arc extends counterclockwise from the point where it intersects the radial line from the center of the bounding rectangle to the (<i>nXRadial1</i>, <i>nYRadial1</i>) point. The arc ends where it intersects the radial line from the center of the bounding rectangle to the (<i>nXRadial2</i>, <i>nYRadial2</i>) point. If the starting point and ending point are the same, a complete ellipse is drawn.</para>
      <para>A line is drawn from the current position to the starting point of the arc. If no error occurs, the current position is set to the ending point of the arc.</para>
      <para>The arc is drawn using the current pen; it is not filled.</para>
    </remarks>
    <seealso cref="AngleArc" />
    <seealso cref="Arc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="SetArcDirection" />
  </member>
  <member name="Windows.BeginPath">
    <summary>
      <para>The <b>BeginPath</b> function opens a path bracket in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>After a path bracket is open, an application can begin calling GDI drawing functions to define the points that lie in the path. An application can close an open path bracket by calling the <see cref="EndPath" /> function.</para>
      <para>When an application calls <b>BeginPath</b> for a device context, any previous paths are discarded from that device context. The following list shows which drawing functions can be used.</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="AngleArc" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Arc" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ArcTo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Chord" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CloseFigure" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Ellipse" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ExtTextOut" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LineTo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="MoveToEx" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Pie" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolyBezier" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolyBezierTo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolyDraw" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Polygon" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Polyline" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolylineTo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolyPolygon" />
          </description>
        </item>
        <item>
          <description>
            <see cref="PolyPolyline" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Rectangle" />
          </description>
        </item>
        <item>
          <description>
            <see cref="RoundRect" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TextOut" />
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-paths">Using Paths</a>.</para>
    </remarks>
    <seealso cref="EndPath" />
    <seealso cref="FillPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso cref="PathToRegion" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="SelectClipPath" />
    <seealso cref="StrokeAndFillPath" />
    <seealso cref="StrokePath" />
    <seealso cref="WidenPath" />
  </member>
  <member name="Windows.BitBlt">
    <summary>
      <para>The <b>BitBlt</b> function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="cx">
      <para>The width, in logical units, of the source and destination rectangles.</para>
    </param>
    <param name="cy">
      <para>The height, in logical units, of the source and the destination rectangles.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="x1">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="y1">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="rop">
      <para>A raster-operation code. These codes define how the color data for the source rectangle is to be combined with the color data for the destination rectangle to achieve the final color.</para>
      <para>The following list shows some common raster operation codes.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>BLACKNESS</b>
          </description>
          <description>
            <para>Fills the destination rectangle using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)</para>
          </description>
        </item>
        <item>
          <description>
            <b>CAPTUREBLT</b>
          </description>
          <description>
            <para>Includes any windows that are layered on top of your window in the resulting image. By default, the image only contains your window. Note that this generally cannot be used for printing device contexts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DSTINVERT</b>
          </description>
          <description>
            <para>Inverts the destination rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MERGECOPY</b>
          </description>
          <description>
            <para>Merges the colors of the source rectangle with the brush currently selected in <i>hdcDest</i>, by using the Boolean AND operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MERGEPAINT</b>
          </description>
          <description>
            <para>Merges the colors of the inverted source rectangle with the colors of the destination rectangle by using the Boolean OR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NOMIRRORBITMAP</b>
          </description>
          <description>
            <para>Prevents the bitmap from being mirrored.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NOTSRCCOPY</b>
          </description>
          <description>
            <para>Copies the inverted source rectangle to the destination.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NOTSRCERASE</b>
          </description>
          <description>
            <para>Combines the colors of the source and destination rectangles by using the Boolean OR operator and then inverts the resultant color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PATCOPY</b>
          </description>
          <description>
            <para>Copies the brush currently selected in <i>hdcDest</i>, into the destination bitmap.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PATINVERT</b>
          </description>
          <description>
            <para>Combines the colors of the brush currently selected in <i>hdcDest</i>, with the colors of the destination rectangle by using the Boolean XOR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PATPAINT</b>
          </description>
          <description>
            <para>Combines the colors of the brush currently selected in <i>hdcDest</i>, with the colors of the inverted source rectangle by using the Boolean OR operator. The result of this operation is combined with the colors of the destination rectangle by using the Boolean OR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SRCAND</b>
          </description>
          <description>
            <para>Combines the colors of the source and destination rectangles by using the Boolean AND operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SRCCOPY</b>
          </description>
          <description>
            <para>Copies the source rectangle directly to the destination rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SRCERASE</b>
          </description>
          <description>
            <para>Combines the inverted colors of the destination rectangle with the colors of the source rectangle by using the Boolean AND operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SRCINVERT</b>
          </description>
          <description>
            <para>Combines the colors of the source and destination rectangles by using the Boolean XOR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SRCPAINT</b>
          </description>
          <description>
            <para>Combines the colors of the source and destination rectangles by using the Boolean OR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WHITENESS</b>
          </description>
          <description>
            <para>Fills the destination rectangle using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>BitBlt</b> only does clipping on the destination DC.</para>
      <para>If a rotation or shear transformation is in effect in the source device context, <b>BitBlt</b> returns an error. If other transformations exist in the source device context (and a matching transformation is not in effect in the destination device context), the rectangle in the destination device context is stretched, compressed, or rotated, as necessary.</para>
      <para>If the color formats of the source and destination device contexts do not match, the <b>BitBlt</b> function converts the source color format to match the destination format.</para>
      <para>When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context.</para>
      <para>Not all devices support the <b>BitBlt</b> function. For more information, see the RC_BITBLT raster capability entry in the <see cref="GetDeviceCaps" /> function as well as the following functions: <see cref="MaskBlt" />, <see cref="PlgBlt" />, and <see cref="StretchBlt" />.</para>
      <para>
        <b>BitBlt</b> returns an error if the source and destination device contexts represent different devices. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
      <para>
        <b>ICM:</b> No color management is performed when blits occur.</para>
      <h4>Examples</h4>
      <para>The following code example demonstrates the use of <b>BitBlt</b>.</para>
      <code>if (!BitBlt(hdcMemDC,
    0, 0,
    rcClient.right - rcClient.left, rcClient.bottom - rcClient.top,
    hdcWindow,
    0, 0,
    SRCCOPY))
{
    MessageBox(hWnd, L"BitBlt has failed", L"Failed", MB_OK);
    goto done;
}
</code>
      <para>To see this example in context, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="MaskBlt" />
    <seealso cref="PlgBlt" />
    <seealso cref="SetDIBits" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.CancelDC">
    <summary>
      <para>The <b>CancelDC</b> function cancels any pending operation on the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>CancelDC</b> function is used by multithreaded applications to cancel lengthy drawing operations. If thread A initiates a lengthy drawing operation, thread B may cancel that operation by calling this function.</para>
      <para>If an operation is canceled, the affected thread returns an error and the result of its drawing operation is undefined. The results are also undefined if no drawing operation was in progress when the function was called.</para>
    </remarks>
    <seealso cref="CreateThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetCurrentThread" />
  </member>
  <member name="Windows.CheckColorsInGamut">
    <summary>
      <para>The <b>CheckColorsInGamut</b> function determines whether a specified set of RGB triples lies in the output <a href="https://docs.microsoft.com//windows/win32/wcs/g">gamut</a> of a specified device. The RGB triples are interpreted in the input logical color space.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context whose output gamut to be checked.</para>
    </param>
    <param name="lpRGBTriple">
      <para>Pointer to an array of RGB triples to check.</para>
    </param>
    <param name="dlpBuffer">
      <para>Pointer to the buffer in which the results are to be placed. This buffer must be at least as large as <i>nCount</i> bytes.</para>
    </param>
    <param name="nCount">
      <para>The number of elements in the array of triples.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a nonzero value.</para>
      <para>If this function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The function places the test results in the buffer pointed to by <i>lpBuffer</i>. Each byte in the buffer corresponds to an <i>RGB triple</i>, and has an unsigned value between CM_IN_GAMUT (= 0) and CM_OUT_OF_GAMUT (= 255). The value 0 denotes that the color is in gamut, while a nonzero value denotes that it is out of gamut. For any integer <i>n</i> such that 0 &lt; <i>n</i> &lt; 255, a result value of <i>n</i> + 1 indicates that the corresponding color is at least as far out of gamut as would be indicated by a result value of <i>n</i>, as specified by the ICC Profile Format Specification. For more information on the ICC Profile Format Specification, see the sources listed in <a href="https://docs.microsoft.com//windows/win32/wcs/further-information">Further information</a>
.</para>
      <para>Note that for this function to succeed, WCS must be enabled for the device context handle that is passed in through the <i>hDC</i> parameter. WCS can be enabled for a device context handle by calling the <see cref="SetICMMode" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="SetICMMode" />
  </member>
  <member name="Windows.ChoosePixelFormat">
    <summary>
      <para>The <b>ChoosePixelFormat</b> function attempts to match an appropriate pixel format supported by a device context to a given pixel format specification.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context that the function examines to determine the best match for the pixel format descriptor pointed to by <i>ppfd</i>.</para>
    </param>
    <param name="ppfd">
      <para>Pointer to a <see cref="PIXELFORMATDESCRIPTOR" /> structure that specifies the requested pixel format. In this context, the members of the <b>PIXELFORMATDESCRIPTOR</b> structure that <i>ppfd</i> points to are used as follows:</para>
      <list type="table">
        <listheader>
          <description>
            <i>nSize</i>
          </description>
          <description>Specifies the size of the <see cref="PIXELFORMATDESCRIPTOR" /> data structure. Set this member to <code>sizeof(PIXELFORMATDESCRIPTOR)</code>.</description>
        </listheader>
        <item>
          <description>
            <i>nVersion</i>
          </description>
          <description>Specifies the version number of the <see cref="PIXELFORMATDESCRIPTOR" /> data structure. Set this member to 1.</description>
        </item>
        <item>
          <description>
            <i>dwFlags</i>
          </description>
          <description>A set of bit flags that specify properties of the pixel buffer. You can combine the following bit flag constants by using bitwise-OR. If any of the following flags are set, the <b>ChoosePixelFormat</b> function attempts to match pixel formats that also have that flag or flags set. Otherwise, <b>ChoosePixelFormat</b> ignores that flag in the pixel formats: <b>PFD_DRAW_TO_WINDOW</b>, <b>PFD_DRAW_TO_BITMAP</b>, <b>PFD_SUPPORT_GDI</b>, <b>PFD_SUPPORT_OPENGL</b> If any of the following flags are set, <b>ChoosePixelFormat</b> attempts to match pixel formats that also have that flag or flags set. Otherwise, it attempts to match pixel formats without that flag set: <b>PFD_DOUBLEBUFFER PFD_STEREO</b> If the following flag is set, the function ignores the <b>PFD_DOUBLEBUFFER</b> flag in the pixel formats: <b>PFD_DOUBLEBUFFER_DONTCARE</b> If the following flag is set, the function ignores the <b>PFD_STEREO</b> flag in the pixel formats: <b>PFD_STEREO_DONTCARE</b></description>
        </item>
        <item>
          <description>
            <i>iPixelType</i>
          </description>
          <description>Specifies the type of pixel format for the function to consider: <b>PFD_TYPE_RGBA</b>, <b>PFD_TYPE_COLORINDEX</b></description>
        </item>
        <item>
          <description>
            <i>cColorBits</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>cRedBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cRedShift</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cGreenBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cGreenShift</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cBlueBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cBlueShift</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cAlphaBits</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>cAlphaShift</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cAccumBits</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>cAccumRedBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cAccumGreenBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cAccumBlueBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cAccumAlphaBits</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>cDepthBits</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>cStencilBits</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>cAuxBuffers</i>
          </description>
          <description>Zero or greater.</description>
        </item>
        <item>
          <description>
            <i>iLayerType</i>
          </description>
          <description>Specifies one of the following layer type values: <b>PFD_MAIN_PLANE</b>, <b>PFD_OVERLAY_PLANE</b>, <b>PFD_UNDERLAY_PLANE</b></description>
        </item>
        <item>
          <description>
            <i>bReserved</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>dwLayerMask</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>dwVisibleMask</i>
          </description>
          <description>Not used.</description>
        </item>
        <item>
          <description>
            <i>dwDamageMask</i>
          </description>
          <description>Not used.</description>
        </item>
      </list>
      <para>
        <i></i>
      </para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a pixel format index (one-based) that is the closest match to the given pixel format descriptor.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You must ensure that the pixel format matched by the <b>ChoosePixelFormat</b> function satisfies your requirements. For example, if you request a pixel format with a 24-bit RGB color buffer but the device context offers only 8-bit RGB color buffers, the function returns a pixel format with an 8-bit RGB color buffer.</para>
      <h4>Examples</h4>
      <para>The following code sample shows how to use <b>ChoosePixelFormat</b> to match a specified pixel format.</para>
      <code>PIXELFORMATDESCRIPTOR pfd = {
    sizeof(PIXELFORMATDESCRIPTOR),  //  size of this pfd
    1,                     // version number
    PFD_DRAW_TO_WINDOW |   // support window
    PFD_SUPPORT_OPENGL |   // support OpenGL
    PFD_DOUBLEBUFFER,      // double buffered
    PFD_TYPE_RGBA,         // RGBA type
    24,                    // 24-bit color depth
    0, 0, 0, 0, 0, 0,      // color bits ignored
    0,                     // no alpha buffer
    0,                     // shift bit ignored
    0,                     // no accumulation buffer
    0, 0, 0, 0,            // accum bits ignored
    32,                    // 32-bit z-buffer
    0,                     // no stencil buffer
    0,                     // no auxiliary buffer
    PFD_MAIN_PLANE,        // main layer
    0,                     // reserved
    0, 0, 0                // layer masks ignored
    };
    HDC  hdc;
    int  iPixelFormat;

iPixelFormat = ChoosePixelFormat(hdc, &amp;amp;amp;amp;amp;amp;pfd);
</code>
    </remarks>
    <seealso cref="DescribePixelFormat" />
    <seealso cref="GetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="SetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.Chord">
    <summary>
      <para>The <b>Chord</b> function draws a chord (a region bounded by the intersection of an ellipse and a line segment, called a secant). The chord is outlined by using the current pen and filled by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context in which the chord appears.</para>
    </param>
    <param name="x1">
      <para>The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="y1">
      <para>The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="x2">
      <para>The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="y2">
      <para>The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="x3">
      <para>The x-coordinate, in logical coordinates, of the endpoint of the radial defining the beginning of the chord.</para>
    </param>
    <param name="y3">
      <para>The y-coordinate, in logical coordinates, of the endpoint of the radial defining the beginning of the chord.</para>
    </param>
    <param name="x4">
      <para>The x-coordinate, in logical coordinates, of the endpoint of the radial defining the end of the chord.</para>
    </param>
    <param name="y4">
      <para>The y-coordinate, in logical coordinates, of the endpoint of the radial defining the end of the chord.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The curve of the chord is defined by an ellipse that fits the specified bounding rectangle. The curve begins at the point where the ellipse intersects the first radial and extends counterclockwise to the point where the ellipse intersects the second radial. The chord is closed by drawing a line from the intersection of the first radial and the curve to the intersection of the second radial and the curve.</para>
      <para>If the starting point and ending point of the curve are the same, a complete ellipse is drawn.</para>
      <para>The current position is neither used nor updated by <b>Chord</b>.</para>
    </remarks>
    <seealso cref="AngleArc " />
    <seealso cref="Arc " />
    <seealso cref="ArcTo " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
    <seealso cref="Pie " />
  </member>
  <member name="Windows.CloseEnhMetaFile">
    <summary>
      <para>The <b>CloseEnhMetaFile</b> function closes an enhanced-metafile device context and returns a handle that identifies an enhanced-format metafile.</para>
    </summary>
    <param name="hdc">
      <para>Handle to an enhanced-metafile device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to an enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application can use the enhanced-metafile handle returned by the <b>CloseEnhMetaFile</b> function to perform the following tasks:</para>
      <list type="bullet">
        <item>
          <description>Display a picture stored in an enhanced metafile</description>
        </item>
        <item>
          <description>Create copies of the enhanced metafile</description>
        </item>
        <item>
          <description>Enumerate, edit, or copy individual records in the enhanced metafile</description>
        </item>
        <item>
          <description>Retrieve an optional description of the metafile contents from the enhanced-metafile header</description>
        </item>
        <item>
          <description>Retrieve a copy of the enhanced-metafile header</description>
        </item>
        <item>
          <description>Retrieve a binary copy of the enhanced metafile</description>
        </item>
        <item>
          <description>Enumerate the colors in the optional palette</description>
        </item>
        <item>
          <description>Convert an enhanced-format metafile into a Windows-format metafile</description>
        </item>
      </list>
      <para>When the application no longer needs the enhanced metafile handle, it should release the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
    </remarks>
    <seealso cref="CopyEnhMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="EnumEnhMetaFile" />
    <seealso cref="GetEnhMetaFileBits" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
  </member>
  <member name="Windows.CloseFigure">
    <summary>
      <para>The <b>CloseFigure</b> function closes an open figure in a path.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context in which the figure will be closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>CloseFigure</b> function closes the figure by drawing a line from the current position to the first point of the figure (usually, the point specified by the most recent call to the <see cref="MoveToEx" /> function) and then connects the lines by using the line join style. If a figure is closed by using the <see cref="LineTo" /> function instead of <b>CloseFigure</b>, end caps are used to create the corner instead of a join.</para>
      <para>The <b>CloseFigure</b> function should only be called if there is an open path bracket in the specified device context.</para>
      <para>A figure in a path is open unless it is explicitly closed by using this function. (A figure can be open even if the current point and the starting point of the figure are the same.)</para>
      <para>After a call to <b>CloseFigure</b>, adding a line or curve to the path starts a new figure.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="EndPath" />
    <seealso cref="ExtCreatePen" />
    <seealso cref="LineTo" />
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
  </member>
  <member name="Windows.CloseMetaFile">
    <summary>
      <para>The <b>CloseMetaFile</b> function closes a metafile device context and returns a handle that identifies a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CloseEnhMetaFile" />.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a metafile device context used to create a Windows-format metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>To convert a Windows-format metafile into a new enhanced-format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>When an application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="CopyMetaFile" />
    <seealso cref="CreateMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="EnumMetaFile" />
    <seealso cref="GetMetaFileBitsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayMetaFile" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.CMYK">
    <summary>
      <para>The <b>CMYK</b> macro creates a CMYK color value by combining the specified cyan, magenta, yellow, and black values.</para>
    </summary>
    <param name="c">
      <para>The cyan value for the color to be created.</para>
    </param>
    <param name="m">
      <para>The magenta value for the color to be created.</para>
    </param>
    <param name="y">
      <para>The yellow value for the color to be created.</para>
    </param>
    <param name="k">
      <para>The black value for the color to be created.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="GetCValue" />
    <seealso cref="GetKValue" />
    <seealso cref="GetMValue" />
    <seealso cref="GetYValue" />
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/macros-for-cmyk-values-and-colors">Macros for CMYK values and colors</seealso>
  </member>
  <member name="Windows.ColorCorrectPalette">
    <summary>
      <para>The <b>ColorCorrectPalette</b> function corrects the entries of a palette using the WCS 1.0 parameters in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context whose WCS parameters to use.</para>
    </param>
    <param name="hPal">
      <para>Specifies the handle to the palette to be color corrected.</para>
    </param>
    <param name="deFirst">
      <para>Specifies the first entry in the palette to be color corrected.</para>
    </param>
    <param name="num">
      <para>Specifies the number of entries to color correct.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.ColorMatchToTarget">
    <summary>
      <para>The <b>ColorMatchToTarget</b> function enables you to preview colors as they would appear on the target device.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context for previewing, generally the screen.</para>
    </param>
    <param name="hdcTarget">
      <para>Specifies the target device context, generally a printer.</para>
    </param>
    <param name="action">
      <para>A constant that can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CS_ENABLE</b>
          </description>
          <description>
            <para>Map the colors to the target device's color gamut. This enables color proofing. All subsequent draw commands to the DC will render colors as they would appear on the target device.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CS_DISABLE</b>
          </description>
          <description>
            <para>Disable color proofing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CS_DELETE_TRANSFORM</b>
          </description>
          <description>
            <para>If color management is enabled for the target profile, disable it and delete the concatenated transform.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>ColorMatchToTarget</b> can be used to proof the colors of a color output device on another color output device. Setting the <i>uiAction</i> parameter to CS_ENABLE causes all subsequent drawing commands to the DC to render colors as they would appear on the target device. If <i>uiAction</i> is set to CS_DISABLE, proofing is turned off. However, the current color transform is not deleted from the DC. It is just inactive.</para>
      <para>When <b>ColorMatchToTarget</b> is called, the color transform for the target device is performed first, and then the transform to the preview device is applied to the results of the first transform. This is used primarily for checking gamut mapping conditions. Before using this function, you must enable WCS for both device contexts.</para>
      <para>This function cannot be cascaded. While color mapping to the target is enabled by setting <i>uiAction</i> to CS_ENABLE, application changes to the color space or gamut mapping method are ignored. Those changes then take effect when color mapping to the target is disabled.</para>
      <para>
        <b>Note</b>  A memory leak will not occur if an application does not delete a transform using CS_DELETE_TRANSFORM. The transform will be deleted when either the device context (DC) is closed, or when the application color space is deleted. However if the transform is not going to be used again, or if the application will not be performing any more color matching on the DC, it should explicitly delete the transform to free the memory it occupies.</para>
      <para>The <i>uiAction</i> parameter should only be set to CS_DELETE_TRANSFORM if color management is enabled before the <b>ColorMatchToTarget</b> function is called.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.CombineRgn">
    <summary>
      <para>The <b>CombineRgn</b> function combines two regions and stores the result in a third region. The two regions are combined according to the specified mode.</para>
    </summary>
    <param name="hrgnDst">
      <para>A handle to a new region with dimensions defined by combining two other regions. (This region must exist before <b>CombineRgn</b> is called.)</para>
    </param>
    <param name="hrgnSrc1">
      <para>A handle to the first of two regions to be combined.</para>
    </param>
    <param name="hrgnSrc2">
      <para>A handle to the second of two regions to be combined.</para>
    </param>
    <param name="iMode">
      <para>A mode indicating how the two regions will be combined. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>RGN_AND</b>
          </description>
          <description>
            <para>Creates the intersection of the two combined regions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_COPY</b>
          </description>
          <description>
            <para>Creates a copy of the region identified by <i>hrgnSrc1</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_DIFF</b>
          </description>
          <description>
            <para>Combines the parts of <i>hrgnSrc1</i> that are not part of <i>hrgnSrc2</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_OR</b>
          </description>
          <description>
            <para>Creates the union of two combined regions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_XOR</b>
          </description>
          <description>
            <para>Creates the union of two combined regions except for any overlapping areas.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The return value specifies the type of the resulting region. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>The region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>The region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>The region is more than a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>No region is created.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The three regions need not be distinct. For example, the <i>hrgnSrc1</i> parameter can equal the <i>hrgnDest</i> parameter.</para>
    </remarks>
    <seealso cref="CreateEllipticRgn" />
    <seealso cref="CreateEllipticRgnIndirect" />
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.CombineTransform">
    <summary>
      <para>The <b>CombineTransform</b> function concatenates two world-space to page-space transformations.</para>
    </summary>
    <param name="lpxfOut">
      <para>A pointer to an <see cref="XFORM" /> structure that receives the combined transformation.</para>
    </param>
    <param name="lpxf1">
      <para>A pointer to an <see cref="XFORM" /> structure that specifies the first transformation.</para>
    </param>
    <param name="lpxf2">
      <para>A pointer to an <see cref="XFORM" /> structure that specifies the second transformation.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Applying the combined transformation has the same effect as applying the first transformation and then applying the second transformation.</para>
      <para>The three transformations need not be distinct. For example, <i>lpxform1</i> can point to the same <see cref="XFORM" /> structure as <i>lpxformResult</i>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWorldTransform" />
    <seealso cref="ModifyWorldTransform" />
    <seealso cref="SetWorldTransform" />
    <seealso cref="XFORM" />
  </member>
  <member name="Windows.CopyEnhMetaFile">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyEnhMetaFileA">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyEnhMetaFileW">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyEnhMetaFile">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyEnhMetaFileA">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyEnhMetaFileW">
    <summary>
      <para>The <b>CopyEnhMetaFile</b> function copies the contents of an enhanced-format metafile to a specified file.</para>
    </summary>
    <param name="hEnh">
      <para>A handle to the enhanced metafile to be copied.</para>
    </param>
    <param name="lpFileName">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CopyEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>Applications can use metafiles stored in memory for temporary operations.</para>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFile">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFileA">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFileW">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFile">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFileA">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CopyMetaFileW">
    <summary>
      <para>The <b>CopyMetaFile</b> function copies the content of a Windows-format metafile to the specified file.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CopyEnhMetaFile" />.</para>
    </summary>
    <param name="unnamedParam1">
      <para>A handle to the source Windows-format metafile.</para>
    </param>
    <param name="unnamedParam2">
      <para>A pointer to the name of the destination file. If this parameter is <b>NULL</b>, the source metafile is copied to memory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the copy of the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CopyMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.CreateBitmap">
    <summary>
      <para>The <b>CreateBitmap</b> function creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).</para>
    </summary>
    <param name="nWidth">
      <para>The bitmap width, in pixels.</para>
    </param>
    <param name="nHeight">
      <para>The bitmap height, in pixels.</para>
    </param>
    <param name="nPlanes">
      <para>The number of color planes used by the device.</para>
    </param>
    <param name="nBitCount">
      <para>The number of bits required to identify the color of a single pixel.</para>
    </param>
    <param name="lpBits">
      <para>A pointer to an array of color data used to set the colors in a rectangle of pixels. Each scan line in the rectangle must be word aligned (scan lines that are not word aligned must be padded with zeros). If this parameter is <b>NULL</b>, the contents of the new bitmap is undefined.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a bitmap.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
      <para>This function can return the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_BITMAP</b>
            </para>
          </description>
          <description>
            <para>The calculated size of the bitmap is less than zero.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateBitmap</b> function creates a device-dependent bitmap.</para>
      <para>After a bitmap is created, it can be selected into a device context by calling the <see cref="SelectObject" /> function. However, the bitmap can only be selected into a device context if the bitmap and the DC have the same format.</para>
      <para>The <b>CreateBitmap</b> function can be used to create color bitmaps. However, for performance reasons applications should use <b>CreateBitmap</b> to create monochrome bitmaps and <see cref="CreateCompatibleBitmap" /> to create color bitmaps. Whenever a color bitmap returned from <b>CreateBitmap</b> is selected into a device context, the system checks that the bitmap matches the format of the device context it is being selected into. Because <b>CreateCompatibleBitmap</b> takes a device context, it returns a bitmap that has the same format as the specified device context. Thus, subsequent calls to <see cref="SelectObject" /> are faster with a color bitmap from <b>CreateCompatibleBitmap</b> than with a color bitmap returned from <b>CreateBitmap</b>.</para>
      <para>If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination device context.</para>
      <para>If an application sets the <i>nWidth</i> or <i>nHeight</i> parameters to zero, <b>CreateBitmap</b> returns the handle to a 1-by-1 pixel, monochrome bitmap.</para>
      <para>When you no longer need the bitmap, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateBitmapIndirect" />
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="CreateDIBitmap" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBitmapBits" />
  </member>
  <member name="Windows.CreateBitmapIndirect">
    <summary>
      <para>The <b>CreateBitmapIndirect</b> function creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).</para>
    </summary>
    <param name="pbm">
      <para>A pointer to a <see cref="BITMAP" /> structure that contains information about the bitmap. If an application sets the <b>bmWidth</b> or <b>bmHeight</b> members to zero, <b>CreateBitmapIndirect</b> returns the handle to a 1-by-1 pixel, monochrome bitmap.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the bitmap.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
      <para>This function can return the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>The bitmap is too big for memory to be allocated.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateBitmapIndirect</b> function creates a device-dependent bitmap.</para>
      <para>After a bitmap is created, it can be selected into a device context by calling the <see cref="SelectObject" /> function. However, the bitmap can only be selected into a device context if the bitmap and the DC have the same format.</para>
      <para>While the <b>CreateBitmapIndirect</b> function can be used to create color bitmaps, for performance reasons applications should use <b>CreateBitmapIndirect</b> to create monochrome bitmaps and <see cref="CreateCompatibleBitmap" /> to create color bitmaps. Whenever a color bitmap from <b>CreateBitmapIndirect</b> is selected into a device context, the system must ensure that the bitmap matches the format of the device context it is being selected into. Because <b>CreateCompatibleBitmap</b> takes a device context, it returns a bitmap that has the same format as the specified device context. Thus, subsequent calls to <see cref="SelectObject" /> are faster with a color bitmap from <b>CreateCompatibleBitmap</b> than with a color bitmap returned from <b>CreateBitmapIndirect</b>.</para>
      <para>If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination device context.</para>
      <para>When you no longer need the bitmap, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="BitBlt" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateBitmap" />
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="CreateDIBitmap" />
    <seealso cref="DeleteObject" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateBrushIndirect">
    <summary>
      <para>The <b>CreateBrushIndirect</b> function creates a logical brush that has the specified style, color, and pattern.</para>
    </summary>
    <param name="plbrush">
      <para>A pointer to a <see cref="LOGBRUSH" /> structure that contains information about the brush.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>After an application creates a brush by calling <b>CreateBrushIndirect</b>, it can select it into any device context by calling the <see cref="SelectObject" /> function.</para>
      <para>A brush created by using a monochrome bitmap (one color plane, one bit per pixel) is drawn using the current text and background colors. Pixels represented by a bit set to 0 are drawn with the current text color; pixels represented by a bit set to 1 are drawn with the current background color.</para>
      <para>When you no longer need the brush, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="DeleteObject" />
    <seealso cref="GetBrushOrgEx" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBrushOrgEx" />
  </member>
  <member name="Windows.CreateColorSpace">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateColorSpaceA">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateColorSpaceW">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateColorSpace">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateColorSpaceA">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateColorSpaceW">
    <summary>
      <para>The <b>CreateColorSpace</b> function creates a logical <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="lplcs">
      <para>Pointer to the <see cref="LOGCOLORSPACE" /> data structure.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle that identifies a color space.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the color space is no longer needed, use <b>DeleteColorSpace</b> to delete it.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>CreateColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
  </member>
  <member name="Windows.CreateCompatibleBitmap">
    <summary>
      <para>The <b>CreateCompatibleBitmap</b> function creates a bitmap compatible with the device that is associated with the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="cx">
      <para>The bitmap width, in pixels.</para>
    </param>
    <param name="cy">
      <para>The bitmap height, in pixels.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the compatible bitmap (DDB).</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The color format of the bitmap created by the <b>CreateCompatibleBitmap</b> function matches the color format of the device identified by the <i>hdc</i> parameter. This bitmap can be selected into any memory device context that is compatible with the original device.</para>
      <para>Because memory device contexts allow both color and monochrome bitmaps, the format of the bitmap returned by the <b>CreateCompatibleBitmap</b> function differs when the specified device context is a memory device context. However, a compatible bitmap that was created for a nonmemory device context always possesses the same color format and uses the same color palette as the specified device context.</para>
      <para>Note: When a memory device context is created, it initially has a 1-by-1 monochrome bitmap selected into it. If this memory device context is used in <b>CreateCompatibleBitmap</b>, the bitmap that is created is a <i>monochrome</i> bitmap. To create a color bitmap, use the <b>HDC</b> that was used to create the memory device context, as shown in the following code:</para>
      <code>
    HDC memDC = CreateCompatibleDC ( hDC );
    HBITMAP memBM = CreateCompatibleBitmap ( hDC, nWidth, nHeight );
    SelectObject ( memDC, memBM );

</code>
      <para>If an application sets the <i>nWidth</i> or <i>nHeight</i> parameters to zero, <b>CreateCompatibleBitmap</b> returns the handle to a 1-by-1 pixel, monochrome bitmap.</para>
      <para>If a DIB section, which is a bitmap created by the <see cref="CreateDIBSection" /> function, is selected into the device context identified by the <i>hdc</i> parameter, <b>CreateCompatibleBitmap</b> creates a DIB section.</para>
      <para>When you no longer need the bitmap, call the <see cref="DeleteObject" /> function to delete it.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/scaling-an-image">Scaling an Image</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateDIBSection" />
    <seealso cref="DeleteObject" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateCompatibleDC">
    <summary>
      <para>The <b>CreateCompatibleDC</b> function creates a memory device context (DC) compatible with the specified device.</para>
    </summary>
    <param name="hdc">
      <para>A handle to an existing DC. If this handle is <b>NULL</b>, the function creates a memory DC compatible with the application's current screen.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a memory DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>A memory DC exists only in memory. When the memory DC is created, its display surface is exactly one monochrome pixel wide and one monochrome pixel high. Before an application can use a memory DC for drawing operations, it must select a bitmap of the correct width and height into the DC. To select a bitmap into a DC, use the <see cref="CreateCompatibleBitmap" /> function, specifying the height, width, and color organization required.</para>
      <para>When a memory DC is created, all attributes are set to normal default values. The memory DC can be used as a normal DC. You can set the attributes; obtain the current settings of its attributes; and select pens, brushes, and regions.</para>
      <para>The <b>CreateCompatibleDC</b> function can only be used with devices that support raster operations. An application can determine whether a device supports these operations by calling the <see cref="GetDeviceCaps" /> function.</para>
      <para>When you no longer need the memory DC, call the <see cref="DeleteDC" /> function. We recommend that you call <b>DeleteDC</b> to delete the DC.  However, you can also call <see cref="DeleteObject" /> with the HDC to delete the DC.</para>
      <para>If <i>hdc</i> is <b>NULL</b>, the thread that calls <b>CreateCompatibleDC</b> owns the HDC that is created. When this thread is destroyed, the HDC is no longer valid. Thus, if you create the HDC and pass it to another thread, then exit the first thread, the second thread will not be able to use the HDC.</para>
      <para>
        <b>ICM:</b> If the DC that is passed to this function is enabled for Image Color Management (ICM), the DC created by the function is ICM-enabled. The source and destination color spaces are specified in the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
    </remarks>
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateDC">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDCA">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDCW">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDC">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDCA">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDCW">
    <summary>
      <para>The <b>CreateDC</b> function creates a device context (DC) for a device using the specified name.</para>
    </summary>
    <param name="pwszDriver">
      <para>A pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device. For printing, we recommend that you pass <b>NULL</b> to <i>lpszDriver</i> because GDI ignores <i>lpszDriver</i> for printer devices.</para>
    </param>
    <param name="pwszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
      <para>To obtain valid names for displays, call <see cref="EnumDisplayDevices" />.</para>
      <para>If <i>lpszDriver</i> is DISPLAY or the device name of a specific display device, then <i>lpszDevice</i> must be <b>NULL</b> or that same device name. If <i>lpszDevice</i> is <b>NULL</b>, then a DC is created for the primary display device.</para>
      <para>If there are multiple monitors on the system, calling <code>CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)</code> will create a DC covering all the monitors.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>pdm</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
      <para>If <i>lpszDriver</i> is DISPLAY, <i>pdm</i> must be <b>NULL</b>; GDI then uses the display device's current <see cref="DEVMODE" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to a DC for the specified device.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
      <para>For parameters <i>lpszDriver</i> and <i>lpszDevice</i>, call <see cref="EnumDisplayDevices" /> to obtain valid names for displays.</para>
      <para>When you no longer need the DC, call the <see cref="DeleteDC" /> function.</para>
      <para>If <i>lpszDriver</i> or <i>lpszDevice</i> is DISPLAY, the thread that calls <b>CreateDC</b> owns the <b>HDC</b> that is created. When this thread is destroyed, the <b>HDC</b> is no longer valid. Thus, if you create the <b>HDC</b> and pass it to another thread, then exit the first thread, the second thread will not be able to use the <b>HDC</b>.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a display device, you must pass to <i>pdm</i> either <b>NULL</b> or a pointer to <see cref="DEVMODE" /> that matches the current <b>DEVMODE</b> of the display device that <i>lpszDevice</i> specifies. We recommend to pass <b>NULL</b> and not to try to exactly match the <b>DEVMODE</b> for the current display device.</para>
      <para>When you call <b>CreateDC</b> to create the <b>HDC</b> for a printer device, the printer driver validates the <see cref="DEVMODE" />. If the printer driver determines that the <b>DEVMODE</b> is invalid (that is, printer driver can’t convert or consume the DEVMODE), the printer driver provides a default <b>DEVMODE</b> to create the HDC for the printer device.</para>
      <para>
        <b>ICM:</b> To enable ICM, set the <b>dmICMMethod</b> member of the <see cref="DEVMODE" /> structure (pointed to by the <i>pInitData</i> parameter) to the appropriate value.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EnumDisplayDevices" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors">Multiple Display Monitors</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.CreateDIBitmap">
    <summary>
      <para>The <b>CreateDIBitmap</b> function creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="pbmih">
      <para>A pointer to a bitmap information header structure, <see cref="BITMAPV5HEADER" />.</para>
      <para>If <i>fdwInit</i> is CBM_INIT, the function uses the bitmap information header structure to obtain the desired width and height of the bitmap as well as other information. Note that a positive value for the height indicates a bottom-up DIB while a negative value for the height indicates a top-down DIB. Calling <b>CreateDIBitmap</b> with <i>fdwInit</i> as CBM_INIT is equivalent to calling the <see cref="CreateCompatibleBitmap" /> function to create a DDB in the format of the device and then calling the <see cref="SetDIBits" /> function to translate the DIB bits to the DDB.</para>
    </param>
    <param name="flInit">
      <para>Specifies how the system initializes the bitmap bits. The following value is defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CBM_INIT</b>
          </description>
          <description>
            <para>If this flag is set, the system uses the data pointed to by the <i>lpbInit</i> and <i>lpbmi</i> parameters to initialize the bitmap bits.</para>
            <para>If this flag is clear, the data pointed to by those parameters is not used.</para>
          </description>
        </item>
      </list>
      <para>If <i>fdwInit</i> is zero, the system does not initialize the bitmap bits.</para>
    </param>
    <param name="pjBits">
      <para>A pointer to an array of bytes containing the initial bitmap data. The format of the data depends on the <b>biBitCount</b> member of the <see cref="BITMAPINFO" /> structure to which the <i>lpbmi</i> parameter points.</para>
    </param>
    <param name="pbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that describes the dimensions and color format of the array pointed to by the <i>lpbInit</i> parameter.</para>
    </param>
    <param name="iUsage">
      <para>Specifies whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure was initialized and, if so, whether <b>bmiColors</b> contains explicit red, green, blue (RGB) values or palette indexes. The <i>fuUsage</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the bitmap is to be selected.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and contains literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the compatible bitmap.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The DDB that is created will be whatever bit depth your reference DC is. To create a bitmap that is of different bit depth, use <see cref="CreateDIBSection" />.</para>
      <para>For a device to reach optimal bitmap-drawing speed, specify <i>fdwInit</i> as CBM_INIT. Then, use the same color depth DIB as the video mode. When the video is running 4- or 8-bpp, use DIB_PAL_COLORS.</para>
      <para>The CBM_CREATDIB flag for the <i>fdwInit</i> parameter is no longer supported.</para>
      <para>When you no longer need the bitmap, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color management is performed. The contents of the resulting bitmap are not color matched after the bitmap has been created.</para>
    </remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetSystemPaletteEntries" />
    <seealso cref="SelectObject" />
    <seealso cref="SetDIBits" />
  </member>
  <member name="Windows.CreateDIBPatternBrush">
    <summary>
      <para>The <b>CreateDIBPatternBrush</b> function creates a logical brush that has the pattern specified by the specified device-independent bitmap (DIB). The brush can subsequently be selected into any device context that is associated with a device that supports raster operations.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="CreateDIBPatternBrushPt" /> function.</para>
    </summary>
    <param name="h">
      <para>A handle to a global memory object containing a packed DIB, which consists of a <see cref="BITMAPINFO" /> structure immediately followed by an array of bytes defining the pixels of the bitmap.</para>
    </param>
    <param name="iUsage">
      <para>Specifies whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure is initialized and, if so, whether this member contains explicit red, green, blue (RGB) values or indexes into a logical palette. The <i>fuColorSpec</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the brush is to be selected.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and contains literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When an application selects a two-color DIB pattern brush into a monochrome device context, the system does not acknowledge the colors specified in the DIB; instead, it displays the pattern brush using the current background and foreground colors of the device context. Pixels mapped to the first color of the DIB (offset 0 in the DIB color table) are displayed using the foreground color; pixels mapped to the second color (offset 1 in the color table) are displayed using the background color.</para>
      <para>When you no longer need the brush, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
    </remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="CreateDIBPatternBrushPt" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="CreateSolidBrush" />
    <seealso cref="DeleteObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.CreateDIBPatternBrushPt">
    <summary>
      <para>The <b>CreateDIBPatternBrushPt</b> function creates a logical brush that has the pattern specified by the device-independent bitmap (DIB).</para>
    </summary>
    <param name="lpPackedDIB">
      <para>A pointer to a packed DIB consisting of a <see cref="BITMAPINFO" /> structure immediately followed by an array of bytes defining the pixels of the bitmap.</para>
    </param>
    <param name="iUsage">
      <para>Specifies whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure contains a valid color table and, if so, whether the entries in this color table contain explicit red, green, blue (RGB) values or palette indexes. The <i>iUsage</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the brush is to be selected.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>A color table is provided and contains literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>After an application creates a brush by calling <b>CreateDIBPatternBrushPt</b>, it can select that brush into any device context by calling the <see cref="SelectObject" /> function.</para>
      <para>When you no longer need the brush, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
    </remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="CreateSolidBrush" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetBrushOrgEx" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBrushOrgEx" />
  </member>
  <member name="Windows.CreateDIBSection">
    <summary>
      <para>The <b>CreateDIBSection</b> function creates a DIB that applications can write to directly. The function gives you a pointer to the location of the bitmap bit values. You can supply a handle to a file-mapping object that the function will use to create the bitmap, or you can let the system allocate the memory for the bitmap.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context. If the value of <i>iUsage</i> is DIB_PAL_COLORS, the function uses this device context's logical palette to initialize the DIB colors.</para>
    </param>
    <param name="pbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that specifies various attributes of the DIB, including the bitmap dimensions and colors.</para>
    </param>
    <param name="usage">
      <para>The type of data contained in the <b>bmiColors</b> array member of the <see cref="BITMAPINFO" /> structure pointed to by <i>pbmi</i> (either logical palette indexes or literal RGB values). The following values are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>The <b>bmiColors</b> member is an array of 16-bit indexes into the logical palette of the device context specified by <i>hdc</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>The <see cref="BITMAPINFO" /> structure contains an array of literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ppvBits">
      <para>A pointer to a variable that receives a pointer to the location of the DIB bit values.</para>
    </param>
    <param name="hSection">
      <para>A handle to a file-mapping object that the function will use to create the DIB. This parameter can be <b>NULL</b>.</para>
      <para>If <i>hSection</i> is not <b>NULL</b>, it must be a handle to a file-mapping object created by calling the <see cref="CreateFileMapping" /> function with the PAGE_READWRITE or PAGE_WRITECOPY flag. Read-only DIB sections are not supported. Handles created by other means will cause <b>CreateDIBSection</b> to fail.</para>
      <para>If <i>hSection</i> is not <b>NULL</b>, the <b>CreateDIBSection</b> function locates the bitmap bit values at offset <i>dwOffset</i> in the file-mapping object referred to by <i>hSection</i>. An application can later retrieve the <i>hSection</i> handle by calling the <see cref="GetObject" /> function with the <b>HBITMAP</b> returned by <b>CreateDIBSection</b>.</para>
      <para>If <i>hSection</i> is <b>NULL</b>, the system allocates memory for the DIB. In this case, the <b>CreateDIBSection</b> function ignores the <i>dwOffset</i> parameter. An application cannot later obtain a handle to this memory. The <b>dshSection</b> member of the <see cref="DIBSECTION" /> structure filled in by calling the <see cref="GetObject" /> function will be <b>NULL</b>.</para>
    </param>
    <param name="offset">
      <para>The offset from the beginning of the file-mapping object referenced by <i>hSection</i> where storage for the bitmap bit values is to begin. This value is ignored if <i>hSection</i> is <b>NULL</b>. The bitmap bit values are aligned on doubleword boundaries, so <i>dwOffset</i> must be a multiple of the size of a <b>DWORD</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created DIB, and *<i>ppvBits</i> points to the bitmap bit values.</para>
      <para>If the function fails, the return value is <b>NULL</b>, and *<i>ppvBits</i> is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
      <para>
        <see cref="GetLastError" /> can return the following value:</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>As noted above, if <i>hSection</i> is <b>NULL</b>, the system allocates memory for the DIB. The system closes the handle to that memory when you later delete the DIB by calling the <see cref="DeleteObject" /> function. If <i>hSection</i> is not <b>NULL</b>, you must close the <i>hSection</i> memory handle yourself after calling <b>DeleteObject</b> to delete the bitmap.</para>
      <para>You cannot paste a DIB section from one application into another application.</para>
      <para>
        <b>CreateDIBSection</b> does not use the <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> parameters <i>biXPelsPerMeter</i> or <i>biYPelsPerMeter</i> and will not provide resolution information in the <see cref="BITMAPINFO" /> structure.</para>
      <para>You need to guarantee that the GDI subsystem has completed any drawing to a bitmap created by <b>CreateDIBSection</b> before you draw to the bitmap yourself. Access to the bitmap must be synchronized. Do this by calling the <see cref="GdiFlush" /> function. This applies to any use of the pointer to the bitmap bit values, including passing the pointer in calls to functions such as <see cref="SetDIBits" />.</para>
      <para>
        <b>ICM:</b> No color management is done.</para>
    </remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateFileMapping" />
    <seealso cref="DIBSECTION" />
    <seealso cref="DeleteObject" />
    <seealso cref="GdiFlush" />
    <seealso cref="GetDIBColorTable" />
    <seealso cref="GetObject" />
    <seealso cref="SetDIBColorTable" />
    <seealso cref="SetDIBits" />
  </member>
  <member name="Windows.CreateDiscardableBitmap">
    <summary>
      <para>The <b>CreateDiscardableBitmap</b> function creates a discardable bitmap that is compatible with the specified device. The bitmap has the same bits-per-pixel format and the same color palette as the device. An application can select this bitmap as the current bitmap for a memory device that is compatible with the specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="CreateCompatibleBitmap" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="cx">
      <para>The width, in pixels, of the bitmap.</para>
    </param>
    <param name="cy">
      <para>The height, in pixels, of the bitmap.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the compatible bitmap (DDB).</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the bitmap, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateCompatibleBitmap " />
    <seealso cref="DeleteObject" />
  </member>
  <member name="Windows.CreateEllipticRgn">
    <summary>
      <para>The <b>CreateEllipticRgn</b> function creates an elliptical region.</para>
    </summary>
    <param name="x1">
      <para>Specifies the x-coordinate in logical units, of the upper-left corner of the bounding rectangle of the ellipse.</para>
    </param>
    <param name="y1">
      <para>Specifies the y-coordinate in logical units, of the upper-left corner of the bounding rectangle of the ellipse.</para>
    </param>
    <param name="x2">
      <para>Specifies the x-coordinate in logical units, of the lower-right corner of the bounding rectangle of the ellipse.</para>
    </param>
    <param name="y2">
      <para>Specifies the y-coordinate in logical units, of the lower-right corner of the bounding rectangle of the ellipse.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the HRGN object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis; and the center of the rectangle defines the intersection of the major and minor axes.</para>
    </remarks>
    <seealso cref="CreateEllipticRegnIndirect" />
    <seealso cref="DeleteObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateEllipticRgnIndirect">
    <summary>
      <para>The <b>CreateEllipticRgnIndirect</b> function creates an elliptical region.</para>
    </summary>
    <param name="lprect">
      <para>Pointer to a <see cref="RECT" /> structure that contains the coordinates of the upper-left and lower-right corners of the bounding rectangle of the ellipse in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis; and the center of the rectangle defines the intersection of the major and minor axes.</para>
    </remarks>
    <seealso cref="CreateEllipticRegn" />
    <seealso cref="DeleteObject" />
    <seealso cref="RECT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateEnhMetaFile">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateEnhMetaFileA">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateEnhMetaFileW">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateEnhMetaFile">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateEnhMetaFileA">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateEnhMetaFileW">
    <summary>
      <para>The <b>CreateEnhMetaFile</b> function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a reference device for the enhanced metafile. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to the file name for the enhanced metafile to be created. If this parameter is <b>NULL</b>, the enhanced metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteEnhMetaFile" /> function.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile.</para>
    </param>
    <param name="lpDesc">
      <para>A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be <b>NULL</b>; for more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateEnhMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>The system uses the reference device identified by the <i>hdcRef</i> parameter to record the resolution and units of the device on which a picture originally appeared. If the <i>hdcRef</i> parameter is <b>NULL</b>, it uses the current display device for reference.</para>
      <para>The <b>left</b> and <b>top</b> members of the <see cref="RECT" /> structure pointed to by the <i>lpRect</i> parameter must be less than the <b>right</b> and <b>bottom</b> members, respectively. Points along the edges of the rectangle are included in the picture. If <i>lpRect</i> is <b>NULL</b>, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The <i>lpRect</i> parameter should be provided where possible.</para>
      <para>The string pointed to by the <i>lpDescription</i> parameter must contain a null character between the application name and the picture name and must terminate with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0", where \0 represents the null character. If <i>lpDescription</i> is <b>NULL</b>, there is no corresponding entry in the enhanced-metafile header.</para>
      <para>Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function.</para>
      <para>After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the <see cref="PlayEnhMetaFile" /> function. When displaying the picture, the system uses the rectangle pointed to by the <i>lpRect</i> parameter and the resolution data from the reference device to position and scale the picture.</para>
      <para>The device context returned by this function contains the same default attributes associated with any new device context.</para>
      <para>Applications must use the <see cref="GetWinMetaFileBits" /> function to convert an enhanced metafile to the older Windows metafile format.</para>
      <para>The file name for the enhanced metafile should use the .emf extension.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-an-enhanced-metafile">Creating an Enhanced Metafile</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseEnhMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileDescription" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.CreateFont">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateFontA">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateFontW">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateFontIndirect">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFontIndirectA">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFontIndirectW">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFontIndirectEx">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirectExA">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirectExW">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirectEx">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirectExA">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirectExW">
    <summary>
      <para>The <b>CreateFontIndirectEx</b> function specifies a logical font that has the characteristics in the specified structure. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Pointer to an <see cref="ENUMLOGFONTEXDV" /> structure that defines the characteristics of a multiple master font.</para>
      <para>Note, this function ignores the <b>elfDesignVector</b> member in <see cref="ENUMLOGFONTEXDV" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the new <see cref="ENUMLOGFONTEXDV" /> structure.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirectEx</b> function creates a logical font with the characteristics specified in the <see cref="ENUMLOGFONTEXDV" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The font mapper for <see cref="CreateFont" />, <see cref="CreateFontIndirect" />, and <b>CreateFontIndirectEx</b> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirectEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirect " />
    <seealso cref="ENUMLOGFONTEXDV " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.CreateFontIndirect">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFontIndirectA">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFontIndirectW">
    <summary>
      <para>The <b>CreateFontIndirect</b> function creates a logical font that has the specified characteristics. The font can subsequently be selected as the current font for any device context.</para>
    </summary>
    <param name="lplf">
      <para>A pointer to a <see cref="LOGFONT" /> structure that defines the characteristics of the logical font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The <b>CreateFontIndirect</b> function creates a logical font with the characteristics specified in the <see cref="LOGFONT" /> structure. When this font is selected by using the <see cref="SelectObject" /> function, GDI's font mapper attempts to match the logical font with an existing physical font. If it fails to find an exact match, it provides an alternative whose characteristics match as many of the requested characteristics as possible.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, retrieve the appropriate typeface name, and create the font using <see cref="CreateFont" /> or <b>CreateFontIndirect</b>.</para>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="CreateFont" /> and <b>CreateFontIndirect</b> take the localized typeface name only on a system locale that matches the language, while they take the English typeface name on all other system locales. The best method is to try one name and, on failure, try the other. Note that <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>The font mapper for <see cref="CreateFont" />, <b>CreateFontIndirect</b>, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-a-logical-font">Creating a Logical Font</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFontIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFont " />
    <seealso cref="CreateFontIndirectEx " />
    <seealso cref="DeleteObject " />
    <seealso cref="EnumFontFamilies " />
    <seealso cref="EnumFontFamiliesEx " />
    <seealso cref="EnumFonts " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT " />
    <seealso cref="SelectObject " />
  </member>
  <member name="Windows.CreateFont">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateFontA">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateFontW">
    <summary>
      <para>The <b>CreateFont</b> function creates a logical font with the specified characteristics. The logical font can subsequently be selected as the font for any device.</para>
    </summary>
    <param name="cHeight">
      <para>The height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <i>nHeight</i> in the following manner.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>&gt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The font mapper uses a default height value when it searches for a match.</para>
          </description>
        </item>
        <item>
          <description>
            <para>&lt; 0</para>
          </description>
          <description>
            <para>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</para>
          </description>
        </item>
      </list>
      <para>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.</para>
      <para>This mapping occurs when the font is used for the first time.</para>
      <para>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size:</para>
      <code>
nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

</code>
    </param>
    <param name="cWidth">
      <para>The average width, in logical units, of characters in the requested font. If this value is zero, the font mapper chooses a closest match value. The closest match value is determined by comparing the absolute values of the difference between the current device's aspect ratio and the digitized aspect ratio of available fonts.</para>
    </param>
    <param name="cEscapement">
      <para>The angle, in tenths of degrees, between the escapement vector and the x-axis of the device. The escapement vector is parallel to the base line of a row of text.</para>
      <para>When the graphics mode is set to GM_ADVANCED, you can specify the escapement angle of the string independently of the orientation angle of the string's characters.</para>
      <para>When the graphics mode is set to GM_COMPATIBLE, <i>nEscapement</i> specifies both the escapement and orientation. You should set <i>nEscapement</i> and <i>nOrientation</i> to the same value.</para>
    </param>
    <param name="cOrientation">
      <para>The angle, in tenths of degrees, between each character's base line and the x-axis of the device.</para>
    </param>
    <param name="cWeight">
      <para>The weight of the font in the range 0 through 1000. For example, 400 is normal and 700 is bold. If this value is zero, a default weight is used.</para>
      <para>The following values are defined for convenience.</para>
      <list type="table">
        <listheader>
          <description>Weight</description>
          <description>Value</description>
        </listheader>
        <item>
          <description>
            <b>FW_DONTCARE</b>
          </description>
          <description>
            <para>0</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_THIN</b>
          </description>
          <description>
            <para>100</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRALIGHT</b>
          </description>
          <description>
            <para>200</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_LIGHT</b>
          </description>
          <description>
            <para>300</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_NORMAL</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_REGULAR</b>
          </description>
          <description>
            <para>400</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_MEDIUM</b>
          </description>
          <description>
            <para>500</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_SEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_DEMIBOLD</b>
          </description>
          <description>
            <para>600</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BOLD</b>
          </description>
          <description>
            <para>700</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_EXTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_ULTRABOLD</b>
          </description>
          <description>
            <para>800</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_HEAVY</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
        <item>
          <description>
            <b>FW_BLACK</b>
          </description>
          <description>
            <para>900</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bItalic">
      <para>Specifies an italic font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bUnderline">
      <para>Specifies an underlined font if set to <b>TRUE</b>.</para>
    </param>
    <param name="bStrikeOut">
      <para>A strikeout font if set to <b>TRUE</b>.</para>
    </param>
    <param name="iCharSet">
      <para>The character set. The following values are predefined:</para>
      <list type="bullet">
        <item>
          <description>ANSI_CHARSET</description>
        </item>
        <item>
          <description>BALTIC_CHARSET</description>
        </item>
        <item>
          <description>CHINESEBIG5_CHARSET</description>
        </item>
        <item>
          <description>DEFAULT_CHARSET</description>
        </item>
        <item>
          <description>EASTEUROPE_CHARSET</description>
        </item>
        <item>
          <description>GB2312_CHARSET</description>
        </item>
        <item>
          <description>GREEK_CHARSET</description>
        </item>
        <item>
          <description>HANGUL_CHARSET</description>
        </item>
        <item>
          <description>MAC_CHARSET</description>
        </item>
        <item>
          <description>OEM_CHARSET</description>
        </item>
        <item>
          <description>RUSSIAN_CHARSET</description>
        </item>
        <item>
          <description>SHIFTJIS_CHARSET</description>
        </item>
        <item>
          <description>SYMBOL_CHARSET</description>
        </item>
        <item>
          <description>TURKISH_CHARSET</description>
        </item>
        <item>
          <description>VIETNAMESE_CHARSET</description>
        </item>
      </list>
      <para>Korean language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>JOHAB_CHARSET</description>
        </item>
      </list>
      <para>Middle East language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>ARABIC_CHARSET</description>
        </item>
        <item>
          <description>HEBREW_CHARSET</description>
        </item>
      </list>
      <para>Thai language edition of Windows:</para>
      <list type="bullet">
        <item>
          <description>THAI_CHARSET</description>
        </item>
      </list>
      <para>The OEM_CHARSET value specifies a character set that is operating-system dependent.</para>
      <para>DEFAULT_CHARSET is set to a value based on the current system locale. For example, when the system locale is English (United States), it is set as ANSI_CHARSET.</para>
      <para>Fonts with other character sets may exist in the operating system. If an application uses a font with an unknown character set, it should not attempt to translate or interpret strings that are rendered with that font.</para>
      <para>To ensure consistent results when creating a font, do not specify OEM_CHARSET or DEFAULT_CHARSET. If you specify a typeface name in the <i>lpszFace</i> parameter, make sure that the <i>fdwCharSet</i> value matches the character set of the typeface specified in <i>lpszFace</i>.</para>
    </param>
    <param name="iOutPrecision">
      <para>The output precision. The output precision defines how closely the output must match the requested font's height, width, character orientation, escapement, pitch, and font type. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OUT_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>The default font mapper behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_DEVICE_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a Device font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_OUTLINE_PRECIS</b>
          </description>
          <description>
            <para>This value instructs the font mapper to choose from TrueType and other outline-based fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_PS_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only PostScript fonts. If there are no PostScript fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_RASTER_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a raster font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STRING_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when raster fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_STROKE_PRECIS</b>
          </description>
          <description>
            <para>This value is not used by the font mapper, but it is returned when TrueType, other outline-based fonts, and vector fonts are enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_ONLY_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose from only TrueType fonts. If there are no TrueType fonts installed in the system, the font mapper returns to default behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OUT_TT_PRECIS</b>
          </description>
          <description>
            <para>Instructs the font mapper to choose a TrueType font when the system contains multiple fonts with the same name.</para>
          </description>
        </item>
      </list>
      <para>Applications can use the OUT_DEVICE_PRECIS, OUT_RASTER_PRECIS, OUT_TT_PRECIS, and OUT_PS_ONLY_PRECIS values to control how the font mapper chooses a font when the operating system contains more than one font with a specified name. For example, if an operating system contains a font named Symbol in raster and TrueType form, specifying OUT_TT_PRECIS forces the font mapper to choose the TrueType version. Specifying OUT_TT_ONLY_PRECIS forces the font mapper to choose a TrueType font, even if it must substitute a TrueType font of another name.</para>
    </param>
    <param name="iClipPrecision">
      <para>The clipping precision. The clipping precision defines how to clip characters that are partially outside the clipping region. It can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CLIP_CHARACTER_PRECIS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DEFAULT_PRECIS</b>
          </description>
          <description>
            <para>Specifies default clipping behavior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_DISABLE</b>
          </description>
          <description>
            <para>Windows XP SP1: Turns off font association for the font. Note that this flag is not guaranteed to have any effect on any platform after Windows Server 2003.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_EMBEDDED</b>
          </description>
          <description>
            <para>You must specify this flag to use an embedded read-only font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_LH_ANGLES</b>
          </description>
          <description>
            <para>When this value is used, the rotation for all fonts depends on whether the orientation of the coordinate system is left-handed or right-handed.</para>
            <para>If not used, device fonts always rotate counterclockwise, but the rotation of other fonts is dependent on the orientation of the coordinate system.</para>
            <para>For more information about the orientation of coordinate systems, see the description of the <i>nOrientation</i> parameter</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_MASK</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_DFA_OVERRIDE</b>
          </description>
          <description>
            <para>Turns off font association for the font. This is identical to CLIP_DFA_DISABLE, but it can have problems in some situations; the recommended flag to use is CLIP_DFA_DISABLE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_STROKE_PRECIS</b>
          </description>
          <description>
            <para>Not used by the font mapper, but is returned when raster, vector, or TrueType fonts are enumerated.</para>
            <para>For compatibility, this value is always returned when enumerating fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIP_TT_ALWAYS</b>
          </description>
          <description>
            <para>Not used.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="iQuality">
      <para>The output quality. The output quality defines how carefully GDI must attempt to match the logical-font attributes to those of an actual physical font. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is antialiased, or smoothed, if the font supports it and the size of the font is not too small or too large.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLEARTYPE_QUALITY</b>
          </description>
          <description>
            <para>If set, text is rendered (when possible) using ClearType antialiasing method. See Remarks for more information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font does not matter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DRAFT_QUALITY</b>
          </description>
          <description>
            <para>Appearance of the font is less important than when the PROOF_QUALITY value is used. For GDI raster fonts, scaling is enabled, which means that more font sizes are available, but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NONANTIALIASED_QUALITY</b>
          </description>
          <description>
            <para>Font is never antialiased, that is, font smoothing is not done.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PROOF_QUALITY</b>
          </description>
          <description>
            <para>Character quality of the font is more important than exact matching of the logical-font attributes. For GDI raster fonts, scaling is disabled and the font closest in size is chosen. Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout fonts are synthesized, if necessary.</para>
          </description>
        </item>
      </list>
      <para>If the output quality is DEFAULT_QUALITY, DRAFT_QUALITY, or PROOF_QUALITY, then the font is antialiased if the SPI_GETFONTSMOOTHING system parameter is <b>TRUE</b>. Users can control this system parameter from the Control Panel. (The precise wording of the setting in the Control panel depends on the version of Windows, but it will be words to the effect of "Smooth edges of screen fonts".)</para>
    </param>
    <param name="iPitchAndFamily">
      <para>The pitch and family of the font. The two low-order bits specify the pitch of the font and can be one of the following values:</para>
      <list type="bullet">
        <item>
          <description>DEFAULT_PITCH</description>
        </item>
        <item>
          <description>FIXED_PITCH</description>
        </item>
        <item>
          <description>VARIABLE_PITCH</description>
        </item>
      </list>
      <para>The four high-order bits specify the font family and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FF_DECORATIVE</b>
          </description>
          <description>
            <para>Novelty fonts. Old English is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_DONTCARE</b>
          </description>
          <description>
            <para>Use default font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_MODERN</b>
          </description>
          <description>
            <para>Fonts with constant stroke width, with or without serifs. Pica, Elite, and Courier New are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_ROMAN</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and with serifs. MS Serif is an example.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SCRIPT</b>
          </description>
          <description>
            <para>Fonts designed to look like handwriting. Script and Cursive are examples.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FF_SWISS</b>
          </description>
          <description>
            <para>Fonts with variable stroke width and without serifs. MS?Sans Serif is an example.</para>
          </description>
        </item>
      </list>
      <para>An application can specify a value for the <i>fdwPitchAndFamily</i> parameter by using the Boolean OR operator to join a pitch constant with a family constant.</para>
      <para>Font families describe the look of a font in a general way. They are intended for specifying fonts when the exact typeface requested is not available.</para>
    </param>
    <param name="pszFaceName">
      <para>A pointer to a null-terminated string that specifies the typeface name of the font. The length of this string must not exceed 32 characters, including the terminating null character. The <see cref="EnumFontFamilies" /> function can be used to enumerate the typeface names of all currently available fonts. For more information, see the Remarks.</para>
      <para>If <i>lpszFace</i> is <b>NULL</b> or empty string, GDI uses the first font that matches the other specified attributes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical font.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the font, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>To help protect the copyrights of vendors who provide fonts for Windows, applications should always report the exact name of a selected font. Because available fonts can vary from system to system, do not assume that the selected font is always the same as the requested font. For example, if you request a font named Palatino, but no such font is available on the system, the font mapper will substitute a font that has similar attributes but a different name. Always report the name of the selected font to the user.</para>
      <para>To get the appropriate font on different language versions of the OS, call <see cref="EnumFontFamiliesEx" /> with the desired font characteristics in the <see cref="LOGFONT" /> structure, then retrieve the appropriate typeface name and create the font using <b>CreateFont</b> or <see cref="CreateFontIndirect" />.</para>
      <para>The font mapper for <b>CreateFont</b>,<see cref="CreateFontIndirect" />, and <see cref="CreateFontIndirectEx" /> recognizes both the English and the localized typeface name, regardless of locale.</para>
      <para>The following situations do not support ClearType antialiasing:</para>
      <list type="bullet">
        <item>
          <description>Text rendered on a printer.</description>
        </item>
        <item>
          <description>A display set for 256 colors or less.</description>
        </item>
        <item>
          <description>Text rendered to a terminal server client.</description>
        </item>
        <item>
          <description>The font is not a TrueType font or an OpenType font with TrueType outlines. For example, the following do not support ClearType antialiasing: Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.</description>
        </item>
        <item>
          <description>The font has tuned embedded bitmaps, only for the font sizes that contain the embedded bitmaps. For example, this occurs commonly in East Asian fonts.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;
    switch (message)
    {


    case WM_PAINT:
        {
        RECT rect;
        HBRUSH hBrush;
        HFONT hFont;
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 48 pixels in height.
            //The width, when set to 0, will cause the font mapper to choose the closest matching value.
            //The font face name will be Impact.
            hFont = CreateFont(48,0,0,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Impact"));
            SelectObject(hdc, hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100,100,700,200);
            SetTextColor(hdc, RGB(255,0,0));
            DrawText(hdc, TEXT("Drawing Text with Impact"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 20, will cause the font mapper to choose a font which, in this case, is stretched.
            //The font face name will be Times New Roman.  This time nEscapement is at -300 tenths of a degree (-30 degrees)
            hFont = CreateFont(36,20,-300,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,CLEARTYPE_QUALITY, VARIABLE_PITCH,TEXT("Times New Roman"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 100, 200, 900, 800);
            SetTextColor(hdc, RGB(0,128,0));
            DrawText(hdc, TEXT("Drawing Text with Times New Roman"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);


            //Logical units are device dependent pixels, so this will create a handle to a logical font that is 36 pixels in height.
            //The width, when set to 10, will cause the font mapper to choose a font which, in this case, is compressed.
            //The font face name will be Arial. This time nEscapement is at 250 tenths of a degree (25 degrees)
            hFont = CreateFont(36,10,250,0,FW_DONTCARE,FALSE,TRUE,FALSE,DEFAULT_CHARSET,OUT_OUTLINE_PRECIS,
                CLIP_DEFAULT_PRECIS,ANTIALIASED_QUALITY, VARIABLE_PITCH,TEXT("Arial"));
            SelectObject(hdc,hFont);

            //Sets the coordinates for the rectangle in which the text is to be formatted.
            SetRect(&amp;amp;amp;amp;amp;amp;rect, 500, 200, 1400, 600);
            SetTextColor(hdc, RGB(0,0,255));
            DrawText(hdc, TEXT("Drawing Text with Arial"), -1,&amp;amp;amp;amp;amp;amp;rect, DT_NOCLIP);
            DeleteObject(hFont);

        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
      <para>For another example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateFont as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateFontIndirectEx" />
    <seealso cref="DeleteObject" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateHalftonePalette">
    <summary>
      <para>The <b>CreateHalftonePalette</b> function creates a halftone palette for the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical halftone palette.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application should create a halftone palette when the stretching mode of a device context is set to HALFTONE. The logical halftone palette returned by <b>CreateHalftonePalette</b> should then be selected and realized into the device context before the <see cref="StretchBlt" /> or <see cref="StretchDIBits" /> function is called.</para>
      <para>When you no longer need the palette, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="DeleteObject" />
    <seealso cref="RealizePalette" />
    <seealso cref="SelectPalette" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.CreateHatchBrush">
    <summary>
      <para>The <b>CreateHatchBrush</b> function creates a logical brush that has the specified hatch pattern and color.</para>
    </summary>
    <param name="iHatch">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/hatch-brush">hatch style of the brush</a>. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>HS_BDIAGONAL</b>
          </description>
          <description>
            <para>45-degree upward left-to-right hatch</para>
          </description>
        </item>
        <item>
          <description>
            <b>HS_CROSS</b>
          </description>
          <description>
            <para>Horizontal and vertical crosshatch</para>
          </description>
        </item>
        <item>
          <description>
            <b>HS_DIAGCROSS</b>
          </description>
          <description>
            <para>45-degree crosshatch</para>
          </description>
        </item>
        <item>
          <description>
            <b>HS_FDIAGONAL</b>
          </description>
          <description>
            <para>45-degree downward left-to-right hatch</para>
          </description>
        </item>
        <item>
          <description>
            <b>HS_HORIZONTAL</b>
          </description>
          <description>
            <para>Horizontal hatch</para>
          </description>
        </item>
        <item>
          <description>
            <b>HS_VERTICAL</b>
          </description>
          <description>
            <para>Vertical hatch</para>
          </description>
        </item>
      </list>
    </param>
    <param name="color">
      <para>The foreground color of the brush that is used for the hatches. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>After an application creates a brush by calling <b>CreateHatchBrush</b>, it can select that brush into any device context by calling the <see cref="SelectObject" /> function. It can also call <see cref="SetBkMode" /> to affect the rendering of the  brush.</para>
      <para>If an application uses a hatch brush to fill the backgrounds of both a parent and a child window with matching color, you must  set the brush origin before painting the background of the child window. You can do this by  calling the <see cref="SetBrushOrgEx" /> function. Your application can retrieve the current brush origin by calling the <see cref="GetBrushOrgEx" /> function.</para>
      <para>When you no longer need the brush, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color is defined  at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
      <h4>Examples</h4>
      <para>The following example creates a logical brush that has the specified hatch pattern and color. You can also  set a hatch brush background to transparent or to opaque.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stddef.h&gt;


#include &lt;gdiplus.h&gt;
#include &lt;assert.h&gt;

using namespace Gdiplus;

// Reference to the GDI+ static library).
#pragma comment (lib,"Gdiplus.lib")

// Global variables

// The main window class name.
static TCHAR szWindowClass[] = _T("win32app");


// The string that appears in the application's title bar.
static TCHAR szTitle[] = _T("Win32 Application Hatch Brush");

HINSTANCE hInst;

#define BTN_MYBUTTON_ID_1    503
#define BTN_MYBUTTON_ID_2    504


// Forward declarations of functions included in this code module:
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    WNDCLASSEX wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPLICATION));
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_APPLICATION));

    if (!RegisterClassEx(&amp;amp;amp;amp;amp;amp;wcex))
    {
        MessageBox(NULL,
            _T("Call to RegisterClassEx failed!"),
            _T("Win32 Guided Tour"),
            NULL);

        return 1;
    }

    hInst = hInstance; // Store instance handle in our global variable

    // The parameters to CreateWindow:
    // szWindowClass: the name of the application
    // szTitle: the text that appears in the title bar
    // WS_OVERLAPPEDWINDOW: the type of window to create
    // CW_USEDEFAULT, CW_USEDEFAULT: initial position (x, y)
    // 500, 100: initial size (width, length)
    // NULL: the parent of this window
    // NULL: this application does not have a menu bar
    // hInstance: the first parameter from WinMain
    // NULL: not used in this application
    HWND hWnd = CreateWindow(
        szWindowClass,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        1000, 500,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!hWnd)
    {
        MessageBox(NULL,
            _T("Call to CreateWindow failed!"),
            _T("Win32 Guided Tour"),
            NULL);

        return 1;
    }

    // Create button controls.
    CreateWindowEx(NULL, L"BUTTON", L"Transparent", WS_VISIBLE | WS_CHILD,
        35, 35, 120, 20, hWnd, (HMENU)BTN_MYBUTTON_ID_1, NULL, NULL);

    CreateWindowEx(NULL, L"BUTTON", L"Opaque", WS_VISIBLE | WS_CHILD,
        35, 65, 120, 20, hWnd, (HMENU)BTN_MYBUTTON_ID_2, NULL, NULL);

    // The parameters to ShowWindow:
    // hWnd: the value returned from CreateWindow
    // nCmdShow: the fourth parameter from WinMain
    ShowWindow(hWnd,
        nCmdShow);
    UpdateWindow(hWnd);

    // Main message loop:
    MSG msg;
    while (GetMessage(&amp;amp;amp;amp;amp;amp;msg, NULL, 0, 0))
    {
        TranslateMessage(&amp;amp;amp;amp;amp;amp;msg);
        DispatchMessage(&amp;amp;amp;amp;amp;amp;msg);
    }

    return (int) msg.wParam;
}

/***
 *    This function creates the following rectangles:
 *        1.    An outer rectangle using a solid brush with blue background.
 *        2.    An inner rectangle using a hatch brush with red horizontal lines and yellow background.
 *    It makes the background of the inner rectangle transparent or opaque in function of the user's input.
 *    Inputs:
 *        1.    hdc, the display device context.
 *        2.    transparent, the hatch brush background user's value; true if transparent, false if opaque.
 ***/
VOID SetHatchBrushBackground(HDC hdc, bool transparent)
{
    // Define a brush handle.
    HBRUSH hBrush;

    // Create a solid blue brush.
    hBrush = CreateSolidBrush (RGB(0, 0, 255));

    // Associate the brush with the display device context.
    SelectObject (hdc, hBrush);

    // Draw a rectangle with blue background.
    Rectangle (hdc,  400,40,800,400);


    // Create a hatch brush that draws horizontal red lines.
    hBrush = CreateHatchBrush(HatchStyleHorizontal, RGB(255, 0, 0));

    // Set the background color to yellow.
    SetBkColor(hdc, RGB(255, 255, 0));


    // Select the hatch brush background transparency based on user's input.
    if (transparent == true)
        // Make the hatch brush background transparent.
        // This displays the outer rectangle blue background.
        SetBkMode(hdc, TRANSPARENT);
    else
        // Make the hatch brush background opaque.
        // This displays the inner rectangle yellow background.
        SetBkMode(hdc, OPAQUE);

    // Associate the hatch brush with the current device context.
    SelectObject(hdc, hBrush);

    // Draw a rectangle with the specified hatch brush.
    Rectangle(hdc,  500,130,700,300);

}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;
    TCHAR greeting[] = _T("Select your brush background.");
    TCHAR wmId;
    TCHAR wmEvent;


    switch (message)
    {
    case WM_PAINT:
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);

        // Start application-specific layout section.
        // Just print the greeting string in the top left corner.
        TextOut(hdc,
            5, 5,
            greeting, (int)_tcslen(greeting));
        // End application-specific layout section.

        // Draw rectangles using hatch brush.
        SetHatchBrushBackground(hdc, true);


        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;

    case WM_COMMAND:
        wmId    = LOWORD(wParam);
        wmEvent = HIWORD(wParam);
        hdc = GetDC(hWnd);

        switch (wmId) {

            case BTN_MYBUTTON_ID_1:
                // Draw the inner rectangle using a hatch brush transparent background.
                SetHatchBrushBackground(hdc, true);
                MessageBox(hWnd, _T("Hatch brush background is TRANSPARENT"), _T("Information"), MB_OK);
                break;

            case BTN_MYBUTTON_ID_2:
                // Draw the inner rectangle using a hatch brush opaque background.
                SetHatchBrushBackground(hdc, false);
                MessageBox(hWnd, _T("Hatch brush background is OPAQUE"), _T("Information"), MB_OK);
                break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;


    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateDIBPatternBrushPt" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="CreateSolidBrush" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetBrushOrgEx" />
    <seealso cref="RGB" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkMode" />
    <seealso cref="SetBrushOrgEx" />
  </member>
  <member name="Windows.CreateIC">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateICA">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateICW">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateIC">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateICA">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateICW">
    <summary>
      <para>The <b>CreateIC</b> function creates an information context for the specified device. The information context provides a fast way to get information about the device without creating a device context (DC). However, GDI drawing functions cannot accept a handle to an information context.</para>
    </summary>
    <param name="pszDriver">
      <para>A pointer to a null-terminated character string that specifies the name of the device driver (for example, Epson).</para>
    </param>
    <param name="pszDevice">
      <para>A pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The <i>lpszDevice</i> parameter must be used.</para>
    </param>
    <param name="pszPort">
      <para>This parameter is ignored and should be set to <b>NULL</b>. It is provided only for compatibility with 16-bit Windows.</para>
    </param>
    <param name="pdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing device-specific initialization data for the device driver. The <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function retrieves this structure filled in for a specified device. The <i>lpdvmInit</i> parameter must be <b>NULL</b> if the device driver is to use the default initialization (if any) specified by the user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an information context.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the information DC, call the <see cref="DeleteDC" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.CreateMetaFile">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateMetaFileA">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateMetaFileW">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateMetaFile">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateMetaFileA">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateMetaFileW">
    <summary>
      <para>The <b>CreateMetaFile</b> function creates a device context for a Windows-format metafile.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="CreateEnhMetaFile" />.</para>
    </summary>
    <param name="pszFile">
      <para>A pointer to the file name for the Windows-format metafile to be created. If this parameter is <b>NULL</b>, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the <see cref="DeleteMetaFile" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context for the Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Where text arguments must use Unicode characters, use the <b>CreateMetaFile</b> function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <para>
        <b>CreateMetaFile</b> is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in <a href="https://docs.microsoft.com//windows/desktop/gdi/windows-format-metafiles">Windows-Format Metafiles</a>. It does not record or play back GDI functions such as <see cref="PolyBezier" />, which were not part of 16-bit Windows.</para>
      <para>The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as <see cref="GetTextColor" />. When the device context is used with a GDI output function, the return value of that function becomes <b>TRUE</b> if the function is recorded and <b>FALSE</b> otherwise. When an object is selected by using the <see cref="SelectObject" /> function, only a copy of the object is recorded. The object still belongs to the application.</para>
      <para>To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the <see cref="SelectClipRgn" /> function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines CreateMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetTextColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreatePalette">
    <summary>
      <para>The <b>CreatePalette</b> function creates a logical palette.</para>
    </summary>
    <param name="plpal">
      <para>A pointer to a <see cref="LOGPALETTE" /> structure that contains information about the colors in the logical palette.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a logical palette.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>Once an application creates a logical palette, it can select that palette into a device context by calling the <see cref="SelectPalette" /> function. A palette selected into a device context can be realized by calling the <see cref="RealizePalette" /> function.</para>
      <para>When you no longer need the palette, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="DeleteObject" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="RealizePalette" />
    <seealso cref="SelectPalette" />
  </member>
  <member name="Windows.CreatePatternBrush">
    <summary>
      <para>The <b>CreatePatternBrush</b> function creates a logical brush with the specified bitmap pattern. The bitmap can be a DIB section bitmap, which is created by the <b>CreateDIBSection</b> function, or it can be a device-dependent bitmap.</para>
    </summary>
    <param name="hbm">
      <para>A handle to the bitmap to be used to create the logical brush.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>A pattern brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>After an application creates a brush by calling <b>CreatePatternBrush</b>, it can select that brush into any device context by calling the <see cref="SelectObject" /> function.</para>
      <para>You can delete a pattern brush without affecting the associated bitmap by using the <see cref="DeleteObject" /> function. Therefore, you can then use this bitmap to create any number of pattern brushes.</para>
      <para>A brush created by using a monochrome (1 bit per pixel) bitmap has the text and background colors of the device context to which it is drawn. Pixels represented by a 0 bit are drawn with the current text color; pixels represented by a 1 bit are drawn with the current background color.</para>
      <para>
        <b>ICM:</b> No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="CreateBitmap" />
    <seealso cref="CreateBitmapIndirect" />
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateDIBPatternBrushPt" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetBrushOrgEx" />
    <seealso cref="LoadBitmap" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBrushOrgEx" />
  </member>
  <member name="Windows.CreatePen">
    <summary>
      <para>The <b>CreatePen</b> function creates a logical pen that has the specified style, width, and color. The pen can subsequently be selected into a device context and used to draw lines and curves.</para>
    </summary>
    <param name="iStyle">
      <para>The pen style. It can be any one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PS_SOLID</b>
          </description>
          <description>
            <para>The pen is solid.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASH</b>
          </description>
          <description>
            <para>The pen is dashed. This style is valid only when the pen width is one or less in device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DOT</b>
          </description>
          <description>
            <para>The pen is dotted. This style is valid only when the pen width is one or less in device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASHDOT</b>
          </description>
          <description>
            <para>The pen has alternating dashes and dots. This style is valid only when the pen width is one or less in device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASHDOTDOT</b>
          </description>
          <description>
            <para>The pen has alternating dashes and double dots. This style is valid only when the pen width is one or less in device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_NULL</b>
          </description>
          <description>
            <para>The pen is invisible.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_INSIDEFRAME</b>
          </description>
          <description>
            <para>The pen is solid. When this pen is used in any GDI drawing function that takes a bounding rectangle, the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="cWidth">
      <para>The width of the pen, in logical units. If <i>nWidth</i> is zero, the pen is a single pixel wide, regardless of the current transformation.</para>
      <para>
        <b>CreatePen</b> returns a pen with the specified width but with the PS_SOLID style if you specify a width greater than one for the following styles: PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT.</para>
    </param>
    <param name="color">
      <para>A color reference for the pen color. To generate a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> structure, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle that identifies a logical pen.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>After an application creates a logical pen, it can select that pen into a device context by calling the <see cref="SelectObject" /> function. After a pen is selected into a device context, it can be used to draw lines and curves.</para>
      <para>If the value specified by the <i>nWidth</i> parameter is zero, a line drawn with the created pen always is a single pixel wide regardless of the current transformation.</para>
      <para>If the value specified by <i>nWidth</i> is greater than 1, the <i>fnPenStyle</i> parameter must be PS_NULL, PS_SOLID, or PS_INSIDEFRAME.</para>
      <para>If the value specified by <i>nWidth</i> is greater than 1 and <i>fnPenStyle</i> is PS_INSIDEFRAME, the line associated with the pen is drawn inside the frame of all primitives except polygons and polylines.</para>
      <para>If the value specified by <i>nWidth</i> is greater than 1, <i>fnPenStyle</i> is PS_INSIDEFRAME, and the color specified by the <i>crColor</i> parameter does not match one of the entries in the logical palette, the system draws lines by using a dithered color. Dithered colors are not available with solid pens.</para>
      <para>When using an <i>iStyle</i> parameter of PS_DASH, PS_DOT, PS_DASHDOT or PS_DASHDOTDOT, in order to make the gaps between the dashes or dots transparent, use <see cref=" SetBkMode" /> to set the mode to TRANSPARENT.</para>
      <para>When you no longer need the pen, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>
        <b>ICM:</b> No color management is done at creation. However, color management is performed when the pen is selected into an ICM-enabled device context.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-colored-pens-and-brushes">Creating Colored Pens and Brushes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="CreatePenIndirect" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreatePen" />
    <seealso cref="GetObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pen-functions">Pen Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pens">Pens Overview</seealso>
    <seealso cref="RGB" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreatePenIndirect">
    <summary>
      <para>The <b>CreatePenIndirect</b> function creates a logical cosmetic pen that has the style, width, and color specified in a structure.</para>
    </summary>
    <param name="plpen">
      <para>Pointer to a <see cref="LOGPEN" /> structure that specifies the pen's style, width, and color.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle that identifies a logical cosmetic pen.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>After an application creates a logical pen, it can select that pen into a device context by calling the <see cref="SelectObject" /> function. After a pen is selected into a device context, it can be used to draw lines and curves.</para>
      <para>When you no longer need the pen, call the <see cref="DeleteObject" /> function to delete it.</para>
    </remarks>
    <seealso cref="CreatePen" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreatePen" />
    <seealso cref="GetObject" />
    <seealso cref="LOGPEN" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pen-functions">Pen Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pens">Pens Overview</seealso>
    <seealso cref="RGB" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreatePolygonRgn">
    <summary>
      <para>The <b>CreatePolygonRgn</b> function creates a polygonal region.</para>
    </summary>
    <param name="pptl">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that define the vertices of the polygon in logical units. The polygon is presumed closed. Each vertex can be specified only once.</para>
    </param>
    <param name="cPoint">
      <para>The number of points in the array.</para>
    </param>
    <param name="iMode">
      <para>The fill mode used to determine which pixels are in the region. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ALTERNATE</b>
          </description>
          <description>
            <para>Selects alternate mode (fills area between odd-numbered and even-numbered polygon sides on each scan line).</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINDING</b>
          </description>
          <description>
            <para>Selects winding mode (fills any region with a nonzero winding value).</para>
          </description>
        </item>
      </list>
      <para>For more information about these modes, see the <see cref="SetPolyFillMode" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>Region coordinates are represented as 27-bit signed integers.</para>
      <para>Regions created by the Create&lt;shape&gt;Rgn methods (such as <see cref="CreateRectRgn" /> and <b>CreatePolygonRgn</b>) only include the interior of the shape; the shape's outline is excluded from the region. This means that any point on a line between two sequential vertices is not included in the region. If you were to call <see cref="PtInRegion" /> for such a point, it would return zero as the result.</para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="GetRegionData" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
    <seealso cref="SetPolyFillMode" />
  </member>
  <member name="Windows.CreatePolyPolygonRgn">
    <summary>
      <para>The <b>CreatePolyPolygonRgn</b> function creates a region consisting of a series of polygons. The polygons can overlap.</para>
    </summary>
    <param name="pptl">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that define the vertices of the polygons in logical units. The polygons are specified consecutively. Each polygon is presumed closed and each vertex is specified only once.</para>
    </param>
    <param name="pc">
      <para>A pointer to an array of integers, each of which specifies the number of points in one of the polygons in the array pointed to by <i>lppt</i>.</para>
    </param>
    <param name="cPoly">
      <para>The total number of integers in the array pointed to by <i>lpPolyCounts</i>.</para>
    </param>
    <param name="iMode">
      <para>The fill mode used to determine which pixels are in the region. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ALTERNATE</b>
          </description>
          <description>
            <para>Selects alternate mode (fills area between odd-numbered and even-numbered polygon sides on each scan line).</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINDING</b>
          </description>
          <description>
            <para>Selects winding mode (fills any region with a nonzero winding value).</para>
          </description>
        </item>
      </list>
      <para>For more information about these modes, see the <see cref="SetPolyFillMode" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>Region coordinates are represented as 27-bit signed integers.</para>
    </remarks>
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="GetRegionData" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
    <seealso cref="SetPolyFillMode" />
  </member>
  <member name="Windows.CreateRectRgn">
    <summary>
      <para>The <b>CreateRectRgn</b> function creates a rectangular region.</para>
    </summary>
    <param name="x1">
      <para>Specifies the x-coordinate of the upper-left corner of the region in logical units.</para>
    </param>
    <param name="y1">
      <para>Specifies the y-coordinate of the upper-left corner of the region in logical units.</para>
    </param>
    <param name="x2">
      <para>Specifies the x-coordinate of the lower-right corner of the region in logical units.</para>
    </param>
    <param name="y2">
      <para>Specifies the y-coordinate of the lower-right corner of the region in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>Region coordinates are represented as 27-bit signed integers.</para>
      <para>Regions created by the Create&lt;shape&gt;Rgn methods (such as <b>CreateRectRgn</b> and <see cref="CreatePolygonRgn" />) only include the interior of the shape; the shape's outline is excluded from the region. This means that any point on a line between two sequential vertices is not included in the region. If you were to call <see cref="PtInRegion" /> for such a point, it would return zero as the result.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-markers">Drawing Markers.</a></para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="GetRegionData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateRectRgnIndirect">
    <summary>
      <para>The <b>CreateRectRgnIndirect</b> function creates a rectangular region.</para>
    </summary>
    <param name="lprect">
      <para>Pointer to a <see cref="RECT" /> structure that contains the coordinates of the upper-left and lower-right corners of the rectangle that defines the region in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>Region coordinates are represented as 27-bit signed integers.</para>
      <para>The region will be exclusive of the bottom and right edges.</para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="GetRegionData" />
    <seealso cref="RECT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateRoundRectRgn">
    <summary>
      <para>The <b>CreateRoundRectRgn</b> function creates a rectangular region with rounded corners.</para>
    </summary>
    <param name="x1">
      <para>Specifies the x-coordinate of the upper-left corner of the region in device units.</para>
    </param>
    <param name="y1">
      <para>Specifies the y-coordinate of the upper-left corner of the region in device units.</para>
    </param>
    <param name="x2">
      <para>Specifies the x-coordinate of the lower-right corner of the region in device units.</para>
    </param>
    <param name="y2">
      <para>Specifies the y-coordinate of the lower-right corner of the region in device units.</para>
    </param>
    <param name="w">
      <para>Specifies the width of the ellipse used to create the rounded corners in device units.</para>
    </param>
    <param name="h">
      <para>Specifies the height of the ellipse used to create the rounded corners in device units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>Region coordinates are represented as 27-bit signed  integers.</para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="DeleteObject" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="GetRegionData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.CreateSolidBrush">
    <summary>
      <para>The <b>CreateSolidBrush</b> function creates a logical brush that has the specified solid color.</para>
    </summary>
    <param name="color">
      <para>The color of the brush. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a logical brush.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HBRUSH</b> object, call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>A solid brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>After an application creates a brush by calling <b>CreateSolidBrush</b>, it can select that brush into any device context by calling the <see cref="SelectObject" /> function.</para>
      <para>To paint with a system color brush, an application should use <code>GetSysColorBrush (nIndex)</code> instead of <code>CreateSolidBrush(GetSysColor(nIndex))</code>, because <see cref="GetSysColorBrush" /> returns a cached brush instead of allocating a new one.</para>
      <para>
        <b>ICM:</b> No color management is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-colored-pens-and-brushes">Creating Colored Pens and Brushes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateDIBPatternBrushPt" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetSysColorBrush" />
    <seealso cref="RGB" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.DeleteColorSpace">
    <summary>
      <para>The <b>DeleteColorSpace</b> function removes and destroys a specified <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a>.</para>
    </summary>
    <param name="hcs">
      <para>Specifies the handle to a color space to delete.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.DeleteDC">
    <summary>
      <para>The <b>DeleteDC</b> function deletes the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application must not delete a DC whose handle was obtained by calling the <see cref="GetDC" /> function. Instead, it must call the <see cref="ReleaseDC" /> function to free the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/retrieving-the-capabilities-of-a-printer">Retrieving the Capabilities of a Printer</a>.</para>
    </remarks>
    <seealso cref="CreateDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetDC" />
    <seealso cref="ReleaseDC" />
  </member>
  <member name="Windows.DeleteEnhMetaFile">
    <summary>
      <para>The <b>DeleteEnhMetaFile</b> function deletes an enhanced-format metafile or an enhanced-format metafile handle.</para>
    </summary>
    <param name="hmf">
      <para>A handle to an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the <i>hemf</i> parameter identifies an enhanced metafile stored in memory, the <b>DeleteEnhMetaFile</b> function deletes the metafile. If <i>hemf</i> identifies a metafile stored on a disk, the function deletes the metafile handle but does not destroy the actual metafile. An application can retrieve the file by calling the <see cref="GetEnhMetaFile" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
    </remarks>
    <seealso cref="CopyEnhMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.DeleteEnhMetaFileW">
    <summary>
      <para>The <b>DeleteEnhMetaFile</b> function deletes an enhanced-format metafile or an enhanced-format metafile handle.</para>
    </summary>
    <param name="hmf">
      <para>A handle to an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the <i>hemf</i> parameter identifies an enhanced metafile stored in memory, the <b>DeleteEnhMetaFile</b> function deletes the metafile. If <i>hemf</i> identifies a metafile stored on a disk, the function deletes the metafile handle but does not destroy the actual metafile. An application can retrieve the file by calling the <see cref="GetEnhMetaFile" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
    </remarks>
    <seealso cref="CopyEnhMetaFile" />
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.DeleteMetaFile">
    <summary>
      <para>The <b>DeleteMetaFile</b> function deletes a Windows-format metafile or Windows-format metafile handle.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="DeleteEnhMetaFile" />.</para>
    </summary>
    <param name="hmf">
      <para>A handle to a Windows-format metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the metafile identified by the <i>hmf</i> parameter is stored in memory (rather than on a disk), its content is lost when it is deleted by using the <b>DeleteMetaFile</b> function.</para>
    </remarks>
    <seealso cref="CopyMetaFile" />
    <seealso cref="CreateMetaFile" />
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.DeleteObject">
    <summary>
      <para>The <b>DeleteObject</b> function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</para>
    </summary>
    <param name="ho">
      <para>A handle to a logical pen, brush, font, bitmap, region, or palette.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC.</para>
      <para>When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-colored-pens-and-brushes">Creating Colored Pens and Brushes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.DeleteObjectW">
    <summary>
      <para>The <b>DeleteObject</b> function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</para>
    </summary>
    <param name="ho">
      <para>A handle to a logical pen, brush, font, bitmap, region, or palette.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC.</para>
      <para>When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/creating-colored-pens-and-brushes">Creating Colored Pens and Brushes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.DescribePixelFormat">
    <summary>
      <para>The <b>DescribePixelFormat</b> function obtains information about the pixel format identified by <i>iPixelFormat</i> of the device associated with <i>hdc</i>. The function sets the members of the <see cref="PIXELFORMATDESCRIPTOR" /> structure pointed to by <i>ppfd</i> with that pixel format data.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="iPixelFormat">
      <para>Index that specifies the pixel format. The pixel formats that a device context supports are identified by positive one-based integer indexes.</para>
    </param>
    <param name="nBytes">
      <para>The size, in bytes, of the structure pointed to by <i>ppfd</i>. The <b>DescribePixelFormat</b> function stores no more than <i>nBytes</i> bytes of data to that structure. Set this value to <b>sizeof</b>(<b>PIXELFORMATDESCRIPTOR</b>).</para>
    </param>
    <param name="ppfd">
      <para>Pointer to a <b>PIXELFORMATDESCRIPTOR</b> structure whose members the function sets with pixel format data. The function stores the number of bytes copied to the structure in the structure's <b>nSize</b> member. If, upon entry, <i>ppfd</i> is <b>NULL</b>, the function writes no data to the structure. This is useful when you only want to obtain the maximum pixel format index of a device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the maximum pixel format index of the device context. In addition, the function sets the members of the <b>PIXELFORMATDESCRIPTOR</b> structure pointed to by <i>ppfd</i> according to the specified pixel format.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="ChoosePixelFormat" />
    <seealso cref="GetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="SetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.DeviceCapabilities">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DeviceCapabilitiesA">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DeviceCapabilitiesW">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DeviceCapabilities">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DeviceCapabilitiesA">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DeviceCapabilitiesW">
    <summary>
      <para>The <b>DeviceCapabilities</b> function retrieves the capabilities of a printer driver.</para>
    </summary>
    <param name="pDevice">
      <para>A pointer to a null-terminated string that contains the name of the printer. Note that this is the name of the printer, not of the printer driver.</para>
    </param>
    <param name="pPort">
      <para>A pointer to a null-terminated string that contains the name of the port to which the device is connected, such as LPT1.</para>
    </param>
    <param name="fwCapability">
      <para>The capabilities to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DC_BINNAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the printer's paper bins. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 24 characters long and contains the name of a paper bin. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 24 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of bin entries required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BINS</b>
          </description>
          <description>
            <para>Retrieves a list of available paper bins. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sources for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmDefaultSource</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLLATE</b>
          </description>
          <description>
            <para>If the printer supports collating, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COLORDEVICE</b>
          </description>
          <description>
            <para>If the printer supports color printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_COPIES</b>
          </description>
          <description>
            <para>Returns the number of copies the device can print.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DRIVER</b>
          </description>
          <description>
            <para>Returns the version number of the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_DUPLEX</b>
          </description>
          <description>
            <para>If the printer supports duplex printing, the return value is 1; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ENUMRESOLUTIONS</b>
          </description>
          <description>
            <para>Retrieves a list of the resolutions supported by the printer. The <i>pOutput</i> buffer receives an array of <b>LONG</b> values. For each supported resolution, the array contains a pair of <b>LONG</b> values that specify the x and y dimensions of the resolution, in dots per inch. The return value indicates the number of supported resolutions. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the number of supported resolutions.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_EXTRA</b>
          </description>
          <description>
            <para>Returns the number of bytes required for the device-specific portion of the <see cref="DEVMODE" /> structure for the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FIELDS</b>
          </description>
          <description>
            <para>Returns the <b>dmFields</b> member of the printer driver's <see cref="DEVMODE" /> structure. The <b>dmFields</b> member indicates which members in the device-independent portion of the structure are supported by the printer driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_FILEDEPENDENCIES</b>
          </description>
          <description>
            <para>Retrieves the names of any additional files that need to be loaded when a driver is installed. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a file. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of files.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MAXEXTENT</b>
          </description>
          <description>
            <para>Returns the maximum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the maximum <b>dmPaperWidth</b> value, and the HIWORD contains the maximum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIAREADY</b>
          </description>
          <description>
            <para>Retrieves the names of the paper forms that are currently available for use. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPENAMES</b>
          </description>
          <description>
            <para>Retrieves the names of the supported media types. The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a supported media type. The return value indicates the number of entries in the array. The strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of media type names required.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MEDIATYPES</b>
          </description>
          <description>
            <para>Retrieves a list of supported media types. The <i>pOutput</i> buffer receives an array of DWORD values that indicate the supported media types. The return value indicates the number of entries in the array. For a list of possible array values, see the description of the <b>dmMediaType</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_MINEXTENT</b>
          </description>
          <description>
            <para>Returns the minimum paper size that the <b>dmPaperLength</b> and <b>dmPaperWidth</b> members of the printer driver's <see cref="DEVMODE" /> structure can specify. The LOWORD of the return value contains the minimum <b>dmPaperWidth</b> value, and the HIWORD contains the minimum <b>dmPaperLength</b> value.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_ORIENTATION</b>
          </description>
          <description>
            <para>Returns the relationship between portrait and landscape orientations for a device, in terms of the number of degrees that portrait orientation is rotated counterclockwise to produce landscape orientation. The return value can be one of the following:</para>
            <list type="table">
              <listheader>
                <term>0</term>
                <description>
                  <para>No landscape orientation.</para>
                </description>
              </listheader>
              <item>
                <term>90</term>
                <description>
                  <para>Portrait is rotated 90 degrees to produce landscape.</para>
                </description>
              </item>
              <item>
                <term>270</term>
                <description>
                  <para>Portrait is rotated 270 degrees to produce landscape.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_NUP</b>
          </description>
          <description>
            <para>Retrieves an array of integers that indicate that printer's ability to print multiple document pages per printed page. The <i>pOutput</i> buffer receives an array of <b>DWORD</b> values. Each value represents a supported number of document pages per printed page. The return value indicates the number of entries in the array. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERNAMES</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper names (for example, Letter or Legal). The <i>pOutput</i> buffer receives an array of string buffers. Each string buffer is 64 characters long and contains the name of a paper form. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 64 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value is the number of paper forms.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERS</b>
          </description>
          <description>
            <para>Retrieves a list of supported paper sizes. The <i>pOutput</i> buffer receives an array of <b>WORD</b> values that indicate the available paper sizes for the printer. The return value indicates the number of entries in the array. For a list of the possible array values, see the description of the <b>dmPaperSize</b> member of the <see cref="DEVMODE" /> structure. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PAPERSIZE</b>
          </description>
          <description>
            <para>Retrieves the dimensions, in tenths of a millimeter, of each supported paper size. The <i>pOutput</i> buffer receives an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. Each structure contains the width (x-dimension) and length (y-dimension) of a paper size as if the paper were in the <b>DMORIENT_PORTRAIT</b> orientation. The return value indicates the number of entries in the array.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PERSONALITY</b>
          </description>
          <description>
            <para>Retrieves a list of printer description languages supported by the printer. The <i>pOutput</i> buffer receives an array of string buffers. Each buffer is 32 characters long and contains the name of a printer description language. The return value indicates the number of entries in the array. The name strings are null-terminated unless the name is 32 characters long. If <i>pOutput</i> is <b>NULL</b>, the return value indicates the required number of array entries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTERMEM</b>
          </description>
          <description>
            <para>The return value is the amount of available printer memory, in kilobytes. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATE</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate. The value returned for <b>DC_PRINTRATEUNIT</b> indicates the units of the <b>DC_PRINTRATE</b> value. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEPPM</b>
          </description>
          <description>
            <para>The return value indicates the printer's print rate, in pages per minute. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PRINTRATEUNIT</b>
          </description>
          <description>
            <para>The return value is one of the following values that indicate the print rate units for the value returned for the <b>DC_PRINTRATE</b> flag. The <i>pOutput</i> parameter is not used.</para>
            <list type="table">
              <listheader>
                <term>
                  <b>PRINTRATEUNIT_CPS</b>
                </term>
                <description>
                  <para>Characters per second.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>PRINTRATEUNIT_IPM</b>
                </term>
                <description>
                  <para>Inches per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_LPM</b>
                </term>
                <description>
                  <para>Lines per minute.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>PRINTRATEUNIT_PPM</b>
                </term>
                <description>
                  <para>Pages per minute.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_SIZE</b>
          </description>
          <description>
            <para>Returns the <b>dmSize</b> member of the printer driver's <see cref="DEVMODE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_STAPLE</b>
          </description>
          <description>
            <para>If the printer supports stapling, the return value is a nonzero value; otherwise, the return value is zero. The <i>pOutput</i> parameter is not used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_TRUETYPE</b>
          </description>
          <description>
            <para>Retrieves the abilities of the driver to use TrueType fonts. For <b>DC_TRUETYPE</b>, the <i>pOutput</i> parameter should be <b>NULL</b>. The return value can be one or more of the following:</para>
            <list type="table">
              <listheader>
                <term>
                  <b>DCTT_BITMAP</b>
                </term>
                <description>
                  <para>Device can print TrueType fonts as graphics.</para>
                </description>
              </listheader>
              <item>
                <term>
                  <b>DCTT_DOWNLOAD</b>
                </term>
                <description>
                  <para>Device can download TrueType fonts.</para>
                </description>
              </item>
              <item>
                <term>
                  <b>DCTT_SUBDEV</b>
                </term>
                <description>
                  <para>Device can substitute device fonts for TrueType fonts.</para>
                </description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>DC_VERSION</b>
          </description>
          <description>
            <para>Returns the specification version to which the printer driver conforms.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pOutput">
      <para>A pointer to an array. The format of the array depends on the setting of the <i>fwCapability</i> parameter. See each capability above to find out what is returned if <i>pOutput</i> is <b>NULL</b>.</para>
    </param>
    <param name="pDevMode">
      <para>A pointer to a <see cref="DEVMODE" /> structure. If this parameter is <b>NULL</b>, <b>DeviceCapabilities</b> retrieves the current default initialization values for the specified printer driver. Otherwise, the function retrieves the values contained in the structure to which <i>pDevMode</i> points.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value depends on the setting of the <i>fwCapability</i> parameter. A return value of zero generally indicates that, while the function completed successfully, there was some type of failure, such as a capability that is not supported. For more details, see the descriptions for the <i>fwCapability</i> values.</para>
      <para>If the function returns -1, this may mean either that the capability is not supported or there was a general function failure.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The <see cref="DEVMODE" /> structure pointed to by the <i>pDevMode</i> parameter may be obtained by calling the <a href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</a> function.</para>
      <para>If a printer driver supports custom device capabilities, the driver must call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/setprinterdata">SetPrinterData</a> function for each custom capability. The <b>SetPrinterData</b> function adds the appropriate printer data to the print system, which enables 32-bit applications to access the custom capabilities on 64-bit Windows installations.</para>
      <para>For each custom capability, you must first add printer data that describes the type of the capability. To do this, when you call <b>SetPrinterData</b>, set the <i>pValueName</i> string to <b>CustomDeviceCapabilityType_Xxx</b>, where "Xxx" is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilityType_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to one of the following:</para>
      <list type="bullet">
        <item>
          <description>0, if the custom capability is a <b>DWORD</b></description>
        </item>
        <item>
          <description>1, if the custom capability is a buffer of bytes</description>
        </item>
        <item>
          <description>2, if the custom capability is an array of items</description>
        </item>
      </list>
      <para>If the custom capability is an array of items, you must call <b>SetPinterData</b> a second time to provide information about the size of an item in the array. To do this, when you call <b>SetPinterData</b>, the <i>pValueName</i> string that you provide must be "CustomDeviceCapabilitySize_Xxx" where Xxx is the hexadecimal representation of the capability. For example, you might have "CustomDeviceCapabilitySize_1234". The registry data that you set must be of the <b>REG_DWORD</b> type, and you must set its value to the size in bytes of an item in the array.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines DeviceCapabilities as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso cref="DOCINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetProcAddress" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.DPtoLP">
    <summary>
      <para>The <b>DPtoLP</b> function converts device coordinates into logical coordinates. The conversion depends on the mapping mode of the device context, the settings of the origins and extents for the window and viewport, and the world transformation.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. The x- and y-coordinates contained in each <b>POINT</b> structure will be transformed.</para>
    </param>
    <param name="c">
      <para>The number of points in the array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>DPtoLP</b> function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates exceed 32 bits. In the case of such an overflow, the results for all the points are undefined.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-coordinate-spaces-and-transformations">Using Coordinate Spaces and Transformations</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="LPtoDP" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
  </member>
  <member name="Windows.DrawEscape">
    <summary>
      <para>The <b>DrawEscape</b> function provides drawing capabilities of the specified video display that are not directly available through the graphics device interface (GDI).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC for the specified video display.</para>
    </param>
    <param name="iEscape">
      <para>The escape function to be performed.</para>
    </param>
    <param name="cjIn">
      <para>The number of bytes of data pointed to by the <i>lpszInData</i> parameter.</para>
    </param>
    <param name="lpIn">
      <para>A pointer to the input structure required for the specified escape.</para>
    </param>
    <returns>
      <para>If the function is successful, the return value is greater than zero except for the QUERYESCSUPPORT draw escape, which checks for implementation only.</para>
      <para>If the escape is not implemented, the return value is zero.</para>
      <para>If an error occurred, the return value is less than zero.</para>
    </returns>
    <remarks>
      <para>When an application calls the <b>DrawEscape</b> function, the data identified by <i>cbInput</i> and <i>lpszInData</i> is passed directly to the specified display driver.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
  </member>
  <member name="Windows.Ellipse">
    <summary>
      <para>The <b>Ellipse</b> function draws an ellipse. The center of the ellipse is the center of the specified bounding rectangle. The ellipse is outlined by using the current pen and is filled by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current position is neither used nor updated by <b>Ellipse</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-filled-shapes">Using Filled Shapes</a>.</para>
    </remarks>
    <seealso cref="Arc " />
    <seealso cref="ArcTo " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
  </member>
  <member name="Windows.EndDoc">
    <summary>
      <para>The <b>EndDoc</b> function ends a print job.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context for the print job.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call <b>EndDoc</b> immediately after finishing a print job.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="StartDoc" />
  </member>
  <member name="Windows.EndPage">
    <summary>
      <para>The <b>EndPage</b> function notifies the device that the application has finished writing to a page. This function is typically used to direct the device driver to advance to a new page.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Use the <see cref="ResetDC" /> function to change the device mode, if necessary, after calling the <b>EndPage</b> function. Note that a call to <b>ResetDC</b> resets all device context attributes back to default values. Neither <b>EndPage</b> nor <see cref="StartPage" /> resets the device context attributes. Device context attributes remain constant across subsequent pages. You do not need to re-select objects and set up the mapping mode again before printing the next page; however, doing so will produce the same results and reduce code differences between versions of Windows.</para>
      <para>When a page in a spooled file exceeds approximately 350 MB, it may fail to print and not send an error message. For example, this can occur when printing large EMF files. The page size limit depends on many factors including the amount of virtual memory available, the amount of memory allocated by calling processes, and the amount of fragmentation in the process heap.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="ResetDC" />
    <seealso cref="StartPage" />
  </member>
  <member name="Windows.EndPath">
    <summary>
      <para>The <b>EndPath</b> function closes a path bracket and selects the path defined by the bracket into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context into which the new path is selected.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="BeginPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
  </member>
  <member name="Windows.EnumEnhMetaFile">
    <summary>
      <para>The <b>EnumEnhMetaFile</b> function enumerates the records within an enhanced-format metafile by retrieving each record and passing it to the specified callback function. The application-supplied callback function processes each record as required. The enumeration continues until the last record is processed or when the callback function returns zero.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context. This handle is passed to the callback function.</para>
    </param>
    <param name="hmf">
      <para>A handle to an enhanced metafile.</para>
    </param>
    <param name="proc">
      <para>A pointer to the application-supplied callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162606(v=vs.85)">EnhMetaFileProc</a> function.</para>
    </param>
    <param name="param">
      <para>A pointer to optional callback-function data.</para>
    </param>
    <param name="lpRect">
      <para>A pointer to a <see cref="RECT" /> structure that specifies the coordinates, in logical units, of the picture's upper-left and lower-right corners.</para>
    </param>
    <returns>
      <para>If the callback function successfully enumerates all the records in the enhanced metafile, the return value is nonzero.</para>
      <para>If the callback function does not successfully enumerate all the records in the enhanced metafile, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Points along the edge of the rectangle pointed to by the <i>lpRect</i> parameter are included in the picture. If the <i>hdc</i> parameter is <b>NULL</b>, the system ignores <i>lpRect</i>.</para>
      <para>If the callback function calls the <see cref="PlayEnhMetaFileRecord" /> function, <i>hdc</i> must identify a valid device context. The system uses the device context's transformation and mapping mode to transform the picture displayed by the <b>PlayEnhMetaFileRecord</b> function.</para>
      <para>You can use the <b>EnumEnhMetaFile</b> function to embed one enhanced-metafile within another.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162606(v=vs.85)">EnhMetaFileProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="PlayEnhMetaFileRecord" />
    <seealso cref="RECT" />
  </member>
  <member name="Windows.EnumFontFamilies">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFontFamiliesA">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFontFamiliesW">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFontFamiliesEx">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamiliesExA">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamiliesExW">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamiliesEx">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamiliesExA">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamiliesExW">
    <summary>
      <para>The <b>EnumFontFamiliesEx</b> function enumerates all uniquely-named fonts in the system that match the font characteristics specified by the <see cref="LOGFONT" /> structure. <b>EnumFontFamiliesEx</b> enumerates fonts based on typeface name, character set, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a <see cref="LOGFONT" /> structure that contains information about the fonts to enumerate. The function examines the following members.</para>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b>
          </description>
          <description>If set to DEFAULT_CHARSET, the function enumerates all uniquely-named fonts in all character sets. (If there are two fonts with the same name, only one is enumerated.) If set to a valid character set value, the function enumerates only fonts in the specified character set.</description>
        </item>
        <item>
          <description>
            <b>lfFaceName</b>
          </description>
          <description>If set to an empty string, the function enumerates one font in each available typeface name. If set to a valid typeface name, the function enumerates all fonts with the specified name.</description>
        </item>
        <item>
          <description>
            <b>lfPitchAndFamily</b>
          </description>
          <description>Must be set to zero for all language versions of the operating system.</description>
        </item>
      </list>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For more information, see the <a href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>An application defined value. The function passes this value to the callback function along with font information.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is not used and must be zero.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. This value depends on which font families are available for the specified device.</para>
    </returns>
    <remarks>
      <para>The <b>EnumFontFamiliesEx</b> function does not use tagged typeface names to identify character sets. Instead, it always passes the correct typeface name and a separate character set value to the callback function. The function enumerates fonts based on the values of the <b>lfCharSet</b> and <b>lfFaceName</b> members in the <see cref="LOGFONT" /> structure.</para>
      <para>As with <see cref="EnumFontFamilies" />, <b>EnumFontFamiliesEx</b> enumerates all font styles. Not all styles of a font cover the same character sets. For example, Fontorama Bold might contain ANSI, Greek, and Cyrillic characters, but Fontorama Italic might contain only ANSI characters. For this reason, it's best not to assume that a specified font covers a specific character set, even if it is the ANSI character set. The following table shows the results of various combinations of values for <b>lfCharSet</b> and <b>lfFaceName</b>.</para>
      <list type="table">
        <listheader>
          <description>Values</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all uniquely-named fonts within all character sets. If there are two fonts with the same name, only one is enumerated.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> = DEFAULT_CHARSET
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all character sets and styles in a specific font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = '\0'</para></description>
          <description>
            <para>Enumerates all styles of all fonts in the specific character set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>lfCharSet</b> =a specific character set
<para><b>lfFaceName</b> = a specific font</para></description>
          <description>
            <para>Enumerates all styles of a font in a specific character set.</para>
          </description>
        </item>
      </list>
      <para>The following code sample shows how these values are used.</para>
      <code>
// To enumerate all styles and charsets of all fonts:
lf.lfFaceName[0] = '\0';
lf.lfCharSet = DEFAULT_CHARSET;
HRESULT hr;

// To enumerate all styles and character sets of the Arial font:
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = DEFAULT_CHARSET;

</code>
      <code>
// To enumerate all styles of all fonts for the ANSI character set
lf.lfFaceName[0] = '\0';
lf.lfCharSet = ANSI_CHARSET;

// To enumerate all styles of Arial font that cover the ANSI charset
hr = StringCchCopy( (LPSTR)lf.lfFaceName, LF_FACESIZE, "Arial" );
if (FAILED(hr))
{
// TODO: write error handler
}

lf.lfCharSet = ANSI_CHARSET;

</code>
      <para>The callback functions for <see cref="EnumFontFamilies" /> and <b>EnumFontFamiliesEx</b> are very similar. The main difference is that the <see cref="ENUMLOGFONTEX" /> structure includes a script field.</para>
      <para>Note, based on the values of <b>lfCharSet</b> and <b>lfFaceName</b>, <b>EnumFontFamiliesEx</b> will enumerate the same font as many times as there are distinct character sets in the font. This can create an extensive list of fonts which can be burdensome to a user. For example, the Century Schoolbook font can appear for the Baltic, Western, Greek, Turkish, and Cyrillic character sets. To avoid this, an application should filter the list of fonts.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <see cref="EnumFontFamilies" />, and <b>EnumFontFamiliesEx</b> return the English typeface name if the system locale does not match the language of the font.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamiliesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162618(v=vs.85)">EnumFontFamExProc</seealso>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="LOGFONT" />
  </member>
  <member name="Windows.EnumFontFamilies">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFontFamiliesA">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFontFamiliesW">
    <summary>
      <para>The <b>EnumFontFamilies</b> function enumerates the fonts in a specified font family that are available on a specified device.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the family name of the desired fonts. If <i>lpszFamily</i> is <b>NULL</b>, <b>EnumFontFamilies</b> selects and enumerates one font of each available type family.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application defined callback function. For information, see <a href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to application-supplied data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is implementation specific.</para>
    </returns>
    <remarks>
      <para>For each font having the typeface name specified by the <i>lpszFamily</i> parameter, the <b>EnumFontFamilies</b> function retrieves information about that font and passes it to the function pointed to by the <i>lpEnumFontFamProc</i> parameter. The application defined callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.</para>
      <para>When the graphics mode on the device context is set to GM_ADVANCED using the SetGraphicsMode function and the DEVICE_FONTTYPE flag is passed to the FontType parameter, this function returns a list of type 1 and OpenType fonts on the system. When the graphics mode is not set to GM_ADVANCED, this function returns a list of type 1, OpenType, and TrueType fonts on the system.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <see cref="EnumFonts" />, <b>EnumFontFamilies</b>, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <h4>Examples</h4>
      <para>For examples, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFontFamilies as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162621(v=vs.85)">EnumFontFamProc</seealso>
    <seealso cref="EnumFontFamiliesEx" />
    <seealso cref="EnumFonts" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
  </member>
  <member name="Windows.EnumFonts">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumFontsA">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumFontsW">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumFonts">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumFontsA">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumFontsW">
    <summary>
      <para>The <b>EnumFonts</b> function enumerates the fonts available on a specified device. For each font with the specified typeface name, the <b>EnumFonts</b> function retrieves information about that font and passes it to the application defined callback function. This callback function can process the font information as desired. Enumeration continues until there are no more fonts or the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="EnumFontFamiliesEx" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context from which to enumerate the fonts.</para>
    </param>
    <param name="lpLogfont">
      <para>A pointer to a null-terminated string that specifies the typeface name of the desired fonts. If <i>lpFaceName</i> is <b>NULL</b>, <b>EnumFonts</b> randomly selects and enumerates one font of each available typeface.</para>
    </param>
    <param name="lpProc">
      <para>A pointer to the application definedcallback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</a>.</para>
    </param>
    <param name="lParam">
      <para>A pointer to any application-defined data. The data is passed to the callback function along with the font information.</para>
    </param>
    <returns>
      <para>The return value is the last value returned by the callback function. Its meaning is defined by the application.</para>
    </returns>
    <remarks>
      <para>Use <see cref="EnumFontFamiliesEx" /> instead of <b>EnumFonts</b>. The <b>EnumFontFamiliesEx</b> function differs from the <b>EnumFonts</b> function in that it retrieves the style names associated with a TrueType font. With <b>EnumFontFamiliesEx</b>, you can retrieve information about font styles that cannot be enumerated using the <b>EnumFonts</b> function.</para>
      <para>The fonts for many East Asian languages have two typeface names: an English name and a localized name. <b>EnumFonts</b>, <see cref="EnumFontFamilies" />, and <see cref="EnumFontFamiliesEx" /> return the English typeface name if the system locale does not match the language of the font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumFonts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EnumFontFamilies" />
    <seealso cref="EnumFontFamiliesEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162623(v=vs.85)">EnumFontsProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.EnumICMProfiles">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumICMProfilesA">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumICMProfilesW">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumICMProfiles">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumICMProfilesA">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumICMProfilesW">
    <summary>
      <para>The <b>EnumICMProfiles</b> function enumerates the different output color profiles that the system supports for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context.</para>
    </param>
    <param name="proc">
      <para>Specifies the procedure instance address of a callback function defined by the application. (See <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-icmenumproca">EnumICMProfilesProcCallback</a>.)</para>
    </param>
    <param name="param">
      <para>Data supplied by the application that is passed to the callback function along with the color profile information.</para>
    </param>
    <returns>
      <para>This function returns zero if the application interrupted the enumeration. The return value is -1 if there are no color profiles to enumerate. Otherwise, the return value is the last value returned by the callback function.</para>
    </returns>
    <remarks>
      <para>The <b>EnumICMProfiles</b> function returns a list of profiles that are associated with a device context (DC), and whose settings match those of the DC. It is possible for a device context to contain device profiles that are not associated with particular hardware devices, or device profiles that do not match the settings of the DC. The sRGB profile is an example. The <see cref="SetICMProfile" /> function is used to associate these types of profiles with a DC. The <see cref="GetICMProfile" /> function can be used to retrieve a profile that is not enumerated by the <b>EnumICMProfiles</b> function.</para>
      <para>
        <b>Windows 95/98/Me:</b>
        <b>EnumICMProfilesW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines EnumICMProfiles as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="GetICMProfileW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.EnumMetaFile">
    <summary>
      <para>The <b>EnumMetaFile</b> function enumerates the records within a Windows-format metafile by retrieving each record and passing it to the specified callback function. The application-supplied callback function processes each record as required. The enumeration continues until the last record is processed or when the callback function returns zero.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="EnumEnhMetaFile" />.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context. This handle is passed to the callback function.</para>
    </param>
    <param name="hmf">
      <para>Handle to a Windows-format metafile.</para>
    </param>
    <param name="proc">
      <para>Pointer to an application-supplied callback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/dd162630(v=vs.85)">EnumMetaFileProc</a>.</para>
    </param>
    <param name="param">
      <para>Pointer to optional data.</para>
    </param>
    <returns>
      <para>If the callback function successfully enumerates all the records in the Windows-format metafile, the return value is nonzero.</para>
      <para>If the callback function does not successfully enumerate all the records in the Windows-format metafile, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To convert a Windows-format metafile into an enhanced-format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>You can use the <b>EnumMetaFile</b> function to embed one Windows-format metafile within another.</para>
    </remarks>
    <seealso cref="EnumEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162630(v=vs.85)">EnumMetaFileProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayMetaFile" />
    <seealso cref="PlayMetaFileRecord" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.EnumObjects">
    <summary>
      <para>The <b>EnumObjects</b> function enumerates the pens or brushes available for the specified device context (DC). This function calls the application-defined callback function once for each available object, supplying data describing that object. <b>EnumObjects</b> continues calling the callback function until the callback function returns zero or until all of the objects have been enumerated.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="nType">
      <para>The object type. This parameter can be OBJ_BRUSH or OBJ_PEN.</para>
    </param>
    <param name="lpFunc">
      <para>A pointer to the application-defined callback function. For more information about the callback function, see the <a href="https://docs.microsoft.com//previous-versions/dd162686(v=vs.85)">EnumObjectsProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>A pointer to the application-defined data. The data is passed to the callback function along with the object information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the last value returned by the callback function. Its meaning is user-defined.</para>
      <para>If the objects cannot be enumerated (for example, there are too many objects), the function returns zero without calling the callback function.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162686(v=vs.85)">EnumObjectsProc</seealso>
    <seealso cref="GetObject" />
  </member>
  <member name="Windows.EqualRgn">
    <summary>
      <para>The <b>EqualRgn</b> function checks the two specified regions to determine whether they are identical. The function considers two regions identical if they are equal in size and shape.</para>
    </summary>
    <param name="hrgn1">
      <para>Handle to a region.</para>
    </param>
    <param name="hrgn2">
      <para>Handle to a region.</para>
    </param>
    <returns>
      <para>If the two regions are equal, the return value is nonzero.</para>
      <para>If the two regions are not equal, the return value is zero. A return value of ERROR means at least one of the region handles is invalid.</para>
    </returns>
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.Escape">
    <summary>
      <para>The <b>Escape</b> function enables an application to access the system-defined device capabilities that are not available through GDI. Escape calls made by an application are translated and sent to the driver.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iEscape">
      <para>The escape function to be performed. This parameter must be one of the predefined escape values listed in Remarks. Use the <see cref="ExtEscape" /> function if your application defines a private escape value.</para>
    </param>
    <param name="cjIn">
      <para>The number of bytes of data pointed to by the <i>lpvInData</i> parameter. This can be 0.</para>
    </param>
    <param name="pvIn">
      <para>A pointer to the input structure required for the specified escape.</para>
    </param>
    <param name="pvOut">
      <para>A pointer to the structure that receives output from this escape. This parameter should be <b>NULL</b> if no data is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero, except with the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> printer escape, which checks for implementation only. If the escape is not implemented, the return value is zero.</para>
      <para>If the function fails, the return value is a system error code.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The effect of passing 0 for <i>cbInput</i> will depend on the value of <i>nEscape</i> and on the driver that is handling the escape.</para>
      <para>Of the original printer escapes, only the following can be used.</para>
      <list type="table">
        <listheader>
          <description>Escape</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>QUERYESCSUPPORT</para>
          </description>
          <description>
            <para>Determines whether a particular escape is implemented by the device driver.</para>
          </description>
        </item>
        <item>
          <description>
            <para>PASSTHROUGH</para>
          </description>
          <description>
            <para>Allows the application to send data directly to a printer.</para>
          </description>
        </item>
      </list>
      <para>For information about printer escapes, see <see cref="ExtEscape" />.</para>
      <para>Use the <see cref="StartPage" /> function to prepare the printer driver to receive data.</para>
    </remarks>
    <seealso cref="AbortDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/documentproperties">DocumentProperties</seealso>
    <seealso cref="EndDoc" />
    <seealso cref="EndPage" />
    <seealso cref="ExtEscape" />
    <seealso cref="GetDeviceCaps" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printerproperties">PrinterProperties</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="ResetDC" />
    <seealso cref="SetAbortProc" />
    <seealso cref="StartDoc" />
    <seealso cref="StartPage" />
  </member>
  <member name="Windows.ExcludeClipRect">
    <summary>
      <para>The <b>ExcludeClipRect</b> function creates a new clipping region that consists of the existing clipping region minus the specified rectangle.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical units, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical units, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical units, of the lower-right corner of the rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical units, of the lower-right corner of the rectangle.</para>
    </param>
    <returns>
      <para>The return value specifies the new clipping region's complexity; it can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>No region was created.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The lower and right edges of the specified rectangle are not excluded from the clipping region.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="IntersectClipRect" />
  </member>
  <member name="Windows.ExtCreatePen">
    <summary>
      <para>The <b>ExtCreatePen</b> function creates a logical cosmetic or geometric pen that has the specified style, width, and brush attributes.</para>
    </summary>
    <param name="iPenStyle">
      <para>A combination of type, style, end cap, and join attributes. The values from each category are combined by using the bitwise OR operator ( | ).</para>
      <para>The pen type can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PS_GEOMETRIC</b>
          </description>
          <description>
            <para>The pen is geometric.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_COSMETIC</b>
          </description>
          <description>
            <para>The pen is cosmetic.</para>
          </description>
        </item>
      </list>
      <para>The pen style can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PS_ALTERNATE</b>
          </description>
          <description>
            <para>The pen sets every other pixel. (This style is applicable only for cosmetic pens.)</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_SOLID</b>
          </description>
          <description>
            <para>The pen is solid.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASH</b>
          </description>
          <description>
            <para>The pen is dashed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DOT</b>
          </description>
          <description>
            <para>The pen is dotted.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASHDOT</b>
          </description>
          <description>
            <para>The pen has alternating dashes and dots.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_DASHDOTDOT</b>
          </description>
          <description>
            <para>The pen has alternating dashes and double dots.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_NULL</b>
          </description>
          <description>
            <para>The pen is invisible.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_USERSTYLE</b>
          </description>
          <description>
            <para>The pen uses a styling array supplied by the user.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_INSIDEFRAME</b>
          </description>
          <description>
            <para>The pen is solid. When this pen is used in any GDI drawing function that takes a bounding rectangle, the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens.</para>
          </description>
        </item>
      </list>
      <para>The end cap is only specified for geometric pens. The end cap can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PS_ENDCAP_ROUND</b>
          </description>
          <description>
            <para>End caps are round.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_ENDCAP_SQUARE</b>
          </description>
          <description>
            <para>End caps are square.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_ENDCAP_FLAT</b>
          </description>
          <description>
            <para>End caps are flat.</para>
          </description>
        </item>
      </list>
      <para>The join is only specified for geometric pens. The join can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PS_JOIN_BEVEL</b>
          </description>
          <description>
            <para>Joins are beveled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_JOIN_MITER</b>
          </description>
          <description>
            <para>Joins are mitered when they are within the current limit set by the <see cref="SetMiterLimit" /> function. If it exceeds this limit, the join is beveled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PS_JOIN_ROUND</b>
          </description>
          <description>
            <para>Joins are round.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="cWidth">
      <para>The width of the pen. If the <i>dwPenStyle</i> parameter is PS_GEOMETRIC, the width is given in logical units. If <i>dwPenStyle</i> is PS_COSMETIC, the width must be set to 1.</para>
    </param>
    <param name="plbrush">
      <para>A pointer to a <see cref="LOGBRUSH" /> structure. If <i>dwPenStyle</i> is PS_COSMETIC, the <b>lbColor</b> member specifies the color of the pen and the <b>lpStyle</b> member must be set to BS_SOLID. If <i>dwPenStyle</i> is PS_GEOMETRIC, all members must be used to specify the brush attributes of the pen.</para>
    </param>
    <param name="cStyle">
      <para>The length, in <b>DWORD</b> units, of the <i>lpStyle</i> array. This value must be zero if <i>dwPenStyle</i> is not PS_USERSTYLE.</para>
      <para>The style count is limited to 16.</para>
    </param>
    <param name="pstyle">
      <para>A pointer to an array. The first value specifies the length of the first dash in a user-defined style, the second value specifies the length of the first space, and so on. This pointer must be <b>NULL</b> if <i>dwPenStyle</i> is not PS_USERSTYLE.</para>
      <para>If the <i>lpStyle</i> array is exceeded during line drawing, the pointer is reset to the beginning of the array. When this happens and <i>dwStyleCount</i> is an even number, the pattern of dashes and spaces repeats. However, if <i>dwStyleCount</i> is odd, the pattern reverses when the pointer is reset -- the first element of <i>lpStyle</i> now refers to spaces, the second refers to dashes, and so forth.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle that identifies a logical pen.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A geometric pen can have any width and can have any of the attributes of a brush, such as dithers and patterns. A cosmetic pen can only be a single pixel wide and must be a solid color, but cosmetic pens are generally faster than geometric pens.</para>
      <para>The width of a geometric pen is always specified in world units. The width of a cosmetic pen is always 1.</para>
      <para>End caps and joins are only specified for geometric pens.</para>
      <para>After an application creates a logical pen, it can select that pen into a device context by calling the <see cref="SelectObject" /> function. After a pen is selected into a device context, it can be used to draw lines and curves.</para>
      <para>If <i>dwPenStyle</i> is PS_COSMETIC and PS_USERSTYLE, the entries in the <i>lpStyle</i> array specify lengths of dashes and spaces in style units. A style unit is defined by the device where the pen is used to draw a line.</para>
      <para>If <i>dwPenStyle</i> is PS_GEOMETRIC and PS_USERSTYLE, the entries in the <i>lpStyle</i> array specify lengths of dashes and spaces in logical units.</para>
      <para>If <i>dwPenStyle</i> is PS_ALTERNATE, the style unit is ignored and every other pixel is set.</para>
      <para>If the <b>lbStyle</b> member of the <see cref="LOGBRUSH" /> structure pointed to by <i>lplb</i> is BS_PATTERN, the bitmap pointed to by the <b>lbHatch</b> member of that structure cannot be a DIB section. A DIB section is a bitmap created by <see cref="CreateDIBSection" />. If that bitmap is a DIB section, the <b>ExtCreatePen</b> function fails.</para>
      <para>When an application no longer requires a specified pen, it should call the <see cref="DeleteObject" /> function to delete the pen.</para>
      <para>
        <b>ICM:</b> No color management is done at pen creation. However, color management is performed when the pen is selected into an ICM-enabled device context.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-pens">Using Pens</a>.</para>
    </remarks>
    <seealso cref="CreateDIBSection" />
    <seealso cref="CreatePen" />
    <seealso cref="CreatePenIndirect" />
    <seealso cref="DeleteObject" />
    <seealso cref="GetObject" />
    <seealso cref="LOGBRUSH" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pen-functions">Pen Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/pens">Pens Overview</seealso>
    <seealso cref="SelectObject" />
    <seealso cref="SetMiterLimit" />
  </member>
  <member name="Windows.ExtCreateRegion">
    <summary>
      <para>The <b>ExtCreateRegion</b> function creates a region from the specified region and transformation data.</para>
    </summary>
    <param name="lpx">
      <para>A pointer to an <see cref="XFORM" /> structure that defines the transformation to be performed on the region. If this pointer is <b>NULL</b>, the identity transformation is used.</para>
    </param>
    <param name="nCount">
      <para>The number of bytes pointed to by <i>lpRgnData</i>.</para>
    </param>
    <param name="lpData">
      <para>A pointer to a <see cref="RGNDATA" /> structure that contains the region data in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the value of the region.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Region coordinates are represented as 27-bit signed integers.</para>
      <para>An application can retrieve data for a region by calling the <see cref="GetRegionData" /> function.</para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="GetRegionData" />
    <seealso cref="RGNDATA" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="XFORM" />
  </member>
  <member name="Windows.ExtEscape">
    <summary>
      <para>The <b>ExtEscape</b> function enables an application to access device capabilities that are not available through GDI.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iEscape">
      <para>The escape function to be performed. It can be one of the following or it can be an application-defined escape function.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183421(v=vs.85)">CHECKJPEGFORMAT</a>
            </b>
          </description>
          <description>
            <para>Checks whether the printer supports a JPEG image.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183424(v=vs.85)">CHECKPNGFORMAT</a>
            </b>
          </description>
          <description>
            <para>Checks whether the printer supports a PNG image.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a>
            </b>
          </description>
          <description>
            <para>Draws a white, gray-scale, or black rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd144954(v=vs.85)">GET_PS_FEATURESETTING</a>
            </b>
          </description>
          <description>
            <para>Gets information on a specified feature setting for a PostScript driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd144931(v=vs.85)">GETTECHNOLOGY</a>
            </b>
          </description>
          <description>
            <para>Reports on whether or not the driver is a Postscript driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a>
            </b>
          </description>
          <description>
            <para>Allows the application to send data directly to a printer. Supported in compatibility mode and GDI-centric mode.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162828(v=vs.85)">POSTSCRIPT_DATA</a>
            </b>
          </description>
          <description>
            <para>Allows the application to send data directly to a printer. Supported only in compatibility mode.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a>
            </b>
          </description>
          <description>
            <para>Sets a PostScript driver to GDI-centric or PostScript-centric mode.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162830(v=vs.85)">POSTSCRIPT_INJECTION</a>
            </b>
          </description>
          <description>
            <para>Inserts a block of raw data in a PostScript job stream.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a>
            </b>
          </description>
          <description>
            <para>Sends data directly to a PostScript printer driver. Supported in compatibility mode and PostScript-centric mode.</para>
          </description>
        </item>
        <item>
          <description>
            <b>QUERYESCSUPPORT</b>
          </description>
          <description>
            <para>Determines whether a particular escape is implemented by the device driver.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd145110(v=vs.85)">SPCLPASSTHROUGH2</a>
            </b>
          </description>
          <description>
            <para>Enables applications to include private procedures and other resources at the document level-save context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="cjInput">
      <para>The number of bytes of data pointed to by the <i>lpszInData</i> parameter.</para>
    </param>
    <param name="lpInData">
      <para>A pointer to the input structure required for the specified escape. See also Remarks.</para>
    </param>
    <param name="cjOutput">
      <para>The number of bytes of data pointed to by the <i>lpszOutData</i> parameter.</para>
    </param>
    <param name="lpOutData">
      <para>A pointer to the structure that receives output from this escape. This parameter must not be <b>NULL</b> if <b>ExtEscape</b> is called as a query function. If no data is to be returned in this structure, set <i>cbOutput</i> to 0. See also Remarks.</para>
    </param>
    <returns>
      <para>The return value specifies the outcome of the function. It is greater than zero if the function is successful, except for the QUERYESCSUPPORT printer escape, which checks for implementation only. The return value is zero if the escape is not implemented. A return value less than zero indicates an error.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Use this function to pass a driver-defined escape value to a device.</para>
      <para>Use the <see cref="Escape" /> function to pass one of the system-defined escape values to a device, unless the escape is one of the defined escapes in <i>nEscape</i>. <b>ExtEscape</b> might not work properly with the system-defined escapes. In particular, escapes in which <i>lpszInData</i> is a pointer to a structure that contains a member that is a pointer will fail.</para>
      <para>Note, that the behavior described in this article is the expected behavior, but it is up to the driver to comply with this model.</para>
      <para>The variables referenced by <i>lpszInData</i> and <i>lpszOutData</i> should not be the same or overlap. If the input and the output buffer size variables overlap, they may not contain the correct values after the call returns. For the best results, <i>lpszInData</i> and <i>lpszOutData</i> should refer to different variables.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183421(v=vs.85)">CHECKJPEGFORMAT</a> printer escape function determines whether a printer supports printing a JPEG image.</para>
      <para>Before using the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183421(v=vs.85)">CHECKJPEGFORMAT</a> printer escape function, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> printer escape function to determine whether the driver supports <b>CHECKJPEGFORMAT</b>. For sample code that demonstrates the use of <b>CHECKJPEGFORMAT</b>, see <a href="https://docs.microsoft.com//windows/desktop/gdi/testing-a-printer-for-jpeg-or-png-support">Testing a Printer for JPEG or PNG Support</a>.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183424(v=vs.85)">CHECKPNGFORMAT</a> printer escape function determines whether a printer supports printing a PNG image.</para>
      <para>Before using the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd183421(v=vs.85)">CHECKJPEGFORMAT</a> printer escape function, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> printer escape function to determine whether the driver supports <b>CHECKJPEGFORMAT</b>. For sample code, see <a href="https://docs.microsoft.com//windows/desktop/gdi/testing-a-printer-for-jpeg-or-png-support">Testing a Printer for JPEG or PNG Support</a>.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a> printer escape creates a white, gray scale, or solid black rectangle by using the pattern and rule capabilities of Page Control Language (PCL) on Hewlett-Packard LaserJet or LaserJet-compatible printers. A gray scale is a gray pattern that contains a specific mixture of black and white pixels.</para>
      <para>An application should use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> escape to determine whether the printer is capable of drawing patterns and rules before using the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a> escape.</para>
      <list type="bullet">
        <item>
          <description>Rules drawn with <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a> are not subject to clipping regions in the device context.</description>
        </item>
        <item>
          <description>Applications should not try to erase patterns and rules created with <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a> by placing opaque objects over them. </description>
        </item>
      </list>
      <para>If the printer supports white rules, these can be used to erase patterns created by <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a>. If the printer does not support white rules, there is no method for erasing these patterns.</para>
      <para>If an application cannot use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162495(v=vs.85)">DRAWPATTERNRECT</a> escape and the device is a printer, it should generally use the <see cref="PatBlt" /> function instead. Note that if <b>PatBlt</b> is used to print a black rectangle, the application should use the BLACKNESS raster operator. If the device is a plotter, however, the application should use the <see cref="Rectangle" /> function.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd144954(v=vs.85)">GET_PS_FEATURESETTING</a> printer escape function retrieves information about a specified feature setting for a PostScript driver.</para>
      <para>This escape function is supported only if the PostScript driver is in PostScript-centric mode or in GDI-centric mode. To set the PostScript driver mode, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> escape function.</para>
      <para>To perform this operation, call the <b>ExtEscape</b> function with the following parameters.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd144954(v=vs.85)">GET_PS_FEATURESETTING</a> printer escape function is valid if called any time after calling the <see cref="CreateDC" /> function and before calling the <see cref="DeleteDC" /> function.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd144931(v=vs.85)">GETTECHNOLOGY</a> printer escape function identifies the type of printer driver.</para>
      <para>For non-XPSDrv printers, this escape reports whether the driver is a Postscript driver.</para>
      <para>For XPSDrv printers, this escape reports whether the driver is the <a href="https://docs.microsoft.com//windows/desktop/printdocs/microsoft-xps-document-converter--mxdc-">Microsoft XPS Document Converter (MXDC)</a>. If it is, the escape returns the zero-terminated string "http://schemas.microsoft.com/xps/2005/06"</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a> printer escape function sends data directly to a printer driver. To perform this operation, call the <b>ExtEscape</b> function with the following parameters.</para>
      <para>The <b>PASSTHROUGH</b> printer escape function is supported by PostScript drivers in GDI-centric mode or compatibility mode, but not in PostScript-centric mode. Drivers in PostScript-centric mode can use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a> escape function. To set a PostScript driver mode, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> escape function.</para>
      <para>For PASSTHROUGH data sent by EPSPRINTING or PostScript-centric applications, the PostScript driver will not make any modifications. For PASSTHROUGH data sent by other applications, if the PostScript driver is using BCP (Binary Communication Protocol) or TBCP (Tagged Binary Communication Protocol) output protocol, the driver does the appropriate BCP or TBCP quoting on special characters, as described in "Adobe Serial and Parallel Communications Protocols Specification." This means that the application should send either ASCII or pure binary PASSTHROUGH data.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162828(v=vs.85)">POSTSCRIPT_DATA</a> printer escape function sends data directly to a printer driver. To perform this operation, call the <b>ExtEscape</b> function with the following parameters.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162828(v=vs.85)">POSTSCRIPT_DATA</a> function is identical to the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a> escape function except that it is supported by PostScript drivers in compatibility mode only. It is not supported by PostScript drivers in PostScript-centric mode or in GDI-centric mode.</para>
      <para>Drivers in PostScript-centric mode can use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a> escape function, and drivers in GDI-centric mode can use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a> escape function. To set a PostScript driver's mode, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> escape function.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> printer escape function sets a PostScript driver to GDI-centric mode or PostScript-centric mode.</para>
      <para>To put the driver in GDI-centric or PostScript-centric modes, first call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> printer escape function to determine whether the driver supports the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> printer escape function. If so, you can assume the driver is PSCRIPT 5.0. Then, before you call any other printer escape function, you must call <b>POSTSCRIPT_IDENTIFY</b> and specify either <b>PSIDENT_GDICENTRIC</b> or <b>PSIDENT_PSCENTRIC</b>. You must call the <b>QUERYESCSUPPORT</b> and <b>POSTSCRIPT_IDENTIFY</b> printer escape functions before calling any other printer escape function.</para>
      <para>
        <b>Note</b>  After the PostScript driver is set to GDI-centric mode or PostScript-centric mode, you will not be allowed to call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> printer escape function anymore.</para>
      <para>If you do not use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> printer escape function, the PostScript driver is in compatibility mode and provides identical support for the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a>, <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a>, and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162828(v=vs.85)">POSTSCRIPT_DATA</a> printer escape functions.</para>
      <para>For PostScript drivers that support the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a>, <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162776(v=vs.85)">PASSTHROUGH</a>, and <b>POSTSCRIPT_PASSTHROUGH</b> printer escape functions are identical.</para>
      <para>In PostScript-centric mode, the application is responsible for all PostScript output that marks the paper using the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a> escape function. GDI functions are not allowed. The driver is responsible for the overall document structure and printer control settings. The application can use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162830(v=vs.85)">POSTSCRIPT_INJECTION</a> printer escape function to inject a block of raw data (including DSC comments) into the job stream at specific places.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162830(v=vs.85)">POSTSCRIPT_INJECTION</a> printer escape function inserts a block of raw data at a specified point in a PostScript job stream.</para>
      <para>A PostScript driver supports this escape function in GDI-centric mode or PostScript-centric mode support, but not  in compatibility mode.</para>
      <para>To set the PostScript driver's mode, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> escape function.</para>
      <para>To perform this operation, call the <b>ExtEscape</b> function with the following parameters.</para>
      <para>The driver internally caches the injection data and emits it at appropriate points in the output. The cached information is flushed when it is no longer needed. At the latest, it is flushed after the <see cref="EndDoc" /> call.</para>
      <para>In GDI-centric mode, the application can only inject valid DSC block data by using the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162830(v=vs.85)">POSTSCRIPT_INJECTION</a> printer escape function. A valid DSC block must satisfy all of the following conditions:</para>
      <list type="bullet">
        <item>
          <description>It consists of an integral sequence of "lines."</description>
        </item>
        <item>
          <description>Each "line" must begin with "%%".</description>
        </item>
        <item>
          <description>Each "line" except the last line must end with &lt;CR&gt;, &lt;LF&gt;, or &lt;CR&gt;&lt;LF&gt; except for the last line. If the last line does not end with &lt;CR&gt;, &lt;LF&gt;, or &lt;CR&gt;&lt;LF&gt;, the driver appends &lt;CR&gt;&lt;LF&gt; after the last byte of the injection data.</description>
        </item>
        <item>
          <description>Each "line" must be 255 bytes or less including the "%%" but not counting the &lt;CR&gt;/&lt;LF&gt; line termination.</description>
        </item>
      </list>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162831(v=vs.85)">POSTSCRIPT_PASSTHROUGH</a> printer escape function sends data directly to a PostScript printer driver.</para>
      <para>A PostScript driver supports this escape function when in PostScript-centric mode or in compatibility mode, but not in GDI-centric mode.</para>
      <para>To set the PostScript driver's mode, call the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd162829(v=vs.85)">POSTSCRIPT_IDENTIFY</a> escape function.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff686811(v=vs.85)">QUERYESCSUPPORT</a> printer escape function checks the implementation of a printer escape function.</para>
      <para>The <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd145110(v=vs.85)">SPCLPASSTHROUGH2</a> printer escape function allows applications that print to PostScript devices using EPSPRINTING to include private PostScript procedures and other resources at the document-level save context.</para>
      <para>This escape is supported only for backward compatibility with Adobe Acrobat. Other applications should not use this obsolete escape.</para>
      <para>The application must call this escape before calling <see cref="StartDoc" /> so that the driver will cache the data for insertion at the correct point in the PostScript stream. If this escape is supported, the driver will also allow escape <b>DOWNLOADFACE</b> calls prior to <b>StartDoc</b>. The driver internally caches the data to be inserted and the data required by any escape <b>DOWNLOADFACE</b> calls prior to <b>StartDoc</b> and emits them all immediately before %%EndProlog. The sequence of <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/dd145110(v=vs.85)">SPCLPASSTHROUGH2</a> and <b>DOWNLOADFACE</b> calls will be preserved in the order their data is passed in, that is, a later call results in data output after an earlier call's data. The driver will consider fonts downloaded by pre-<b>StartDoc</b> escape <b>DOWNLOADFACE</b> calls as unavailable for removal during the scope of the job.</para>
      <para>This escape is not recorded in EMF files by the operating system, therefore applications must ensure that EMF recording is turned off for those jobs using the escape.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/sizing-a-jpeg-or-png-image">Sizing a JPEG or PNG Image</a>.</para>
    </remarks>
    <seealso cref="Escape" />
    <seealso cref="GetDeviceCaps" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
  </member>
  <member name="Windows.ExtFloodFill">
    <summary>
      <para>The <b>ExtFloodFill</b> function fills an area of the display surface with the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the point where filling is to start.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the point where filling is to start.</para>
    </param>
    <param name="color">
      <para>The color of the boundary or of the area to be filled. The interpretation of <i>color</i> depends on the value of the <i>fuFillType</i> parameter. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <param name="type">
      <para>The type of fill operation to be performed. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FLOODFILLBORDER</b>
          </description>
          <description>
            <para>The fill area is bounded by the color specified by the <i>color</i> parameter. This style is identical to the filling performed by the <see cref="FloodFill" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FLOODFILLSURFACE</b>
          </description>
          <description>
            <para>The fill area is defined by the color that is specified by <i>color</i>. Filling continues outward in all directions as long as the color is encountered. This style is useful for filling areas with multicolored boundaries.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The following are some of the reasons this function might fail:</para>
      <list type="bullet">
        <item>
          <description>The filling could not be completed.</description>
        </item>
        <item>
          <description>The specified point has the boundary color specified by the <i>color</i> parameter (if FLOODFILLBORDER was requested).</description>
        </item>
        <item>
          <description>The specified point does not have the color specified by <i>color</i> (if FLOODFILLSURFACE was requested).</description>
        </item>
        <item>
          <description>The point is outside the clipping region, that is, it is not visible on the device.</description>
        </item>
      </list>
      <para>If the <i>fuFillType</i> parameter is FLOODFILLBORDER, the system assumes that the area to be filled is completely bounded by the color specified by the <i>color</i> parameter. The function begins filling at the point specified by the <i>nXStart</i> and <i>nYStart</i> parameters and continues in all directions until it reaches the boundary.</para>
      <para>If <i>fuFillType</i> is FLOODFILLSURFACE, the system assumes that the area to be filled is a single color. The function begins to fill the area at the point specified by <i>nXStart</i> and <i>nYStart</i> and continues in all directions, filling all adjacent regions containing the color specified by <i>color</i>.</para>
      <para>Only memory device contexts and devices that support raster-display operations support the <b>ExtFloodFill</b> function. To determine whether a device supports this technology, use the <see cref="GetDeviceCaps" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see "Adding Lines and Graphs to a Menu" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="FloodFill" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.ExtSelectClipRgn">
    <summary>
      <para>The <b>ExtSelectClipRgn</b> function combines the specified region with the current clipping region using the specified mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>A handle to the region to be selected. This handle must not be <b>NULL</b> unless the RGN_COPY mode is specified.</para>
    </param>
    <param name="mode">
      <para>The operation to be performed. It must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>RGN_AND</b>
          </description>
          <description>
            <para>The new clipping region combines the overlapping areas of the current clipping region and the region identified by <i>hrgn</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_COPY</b>
          </description>
          <description>
            <para>The new clipping region is a copy of the region identified by <i>hrgn</i>. This is identical to <see cref="SelectClipRgn" />. If the region identified by <i>hrgn</i> is <b>NULL</b>, the new clipping region is the default clipping region (the default clipping region is a null region).</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_DIFF</b>
          </description>
          <description>
            <para>The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by <i>hrgn</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_OR</b>
          </description>
          <description>
            <para>The new clipping region combines the current clipping region and the region identified by <i>hrgn</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_XOR</b>
          </description>
          <description>
            <para>The new clipping region combines the current clipping region and the region identified by <i>hrgn</i> but excludes any overlapping areas.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The return value specifies the new clipping region's complexity; it can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If an error occurs when this function is called, the previous clipping region for the specified device context is not affected.</para>
      <para>The <b>ExtSelectClipRgn</b> function assumes that the coordinates for the specified region are specified in device units.</para>
      <para>Only a copy of the region identified by the <i>hrgn</i> parameter is used. The region itself can be reused after this call or it can be deleted.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="SelectClipRgn" />
  </member>
  <member name="Windows.ExtTextOut">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.ExtTextOutA">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.ExtTextOutW">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.ExtTextOut">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.ExtTextOutA">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.ExtTextOutW">
    <summary>
      <para>The <b>ExtTextOut</b> function draws text using the currently selected font, background color, and text color. You can optionally provide dimensions to be used for clipping, opaquing, or both.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point used to position the string.</para>
    </param>
    <param name="options">
      <para>Specifies how to use the application-defined rectangle. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ETO_CLIPPED</b>
          </description>
          <description>
            <para>The text will be clipped to the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>The <i>lpString</i> array refers to an array returned from <see cref="GetCharacterPlacement" /> and should be parsed directly by GDI as no further language-specific processing is required. Glyph indexing only applies to TrueType fonts, but the flag can be used for bitmap and vector fonts to indicate that no further language processing is necessary and GDI should process the string directly. Note that all glyph indexes are 16-bit values even though the string is assumed to be an array of 8-bit values for raster fonts.</para>
            <para>For ExtTextOutW, the glyph indexes are saved to a metafile. However, to display the correct characters the metafile must be played back using the same font. For ExtTextOutA, the glyph indexes are not saved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_IGNORELANGUAGE</b>
          </description>
          <description>
            <para>Reserved for system use. If an application sets this flag, it loses international scripting support and in some cases it may display no text at all.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLATIN</b>
          </description>
          <description>
            <para>To display numbers, use European digits.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>To display numbers, use digits appropriate to the locale.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_OPAQUE</b>
          </description>
          <description>
            <para>The current background color should be used to fill the rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_PDY</b>
          </description>
          <description>
            <para>When this is set, the array pointed to by <i>lpDx</i> contains pairs of values. The first value of each pair is, as usual, the distance between origins of adjacent character cells, but the second value is the displacement along the vertical direction of the font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ETO_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> If this value is specified and a Hebrew or Arabic font is selected into the device context, the string is output using right-to-left reading order. If this value is not specified, the string is output in left-to-right order. The same effect can be achieved by setting the TA_RTLREADING value in <see cref="SetTextAlign" />. This value is preserved for backward compatibility.
</description>
        </item>
      </list>
      <para>The ETO_GLYPH_INDEX and ETO_RTLREADING values cannot be used together. Because ETO_GLYPH_INDEX implies that all language processing has been completed, the function ignores the ETO_RTLREADING flag if also specified.</para>
    </param>
    <param name="lprect">
      <para>A pointer to an optional <see cref="RECT" /> structure that specifies the dimensions, in logical coordinates, of a rectangle that is used for clipping, opaquing, or both.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a string that specifies the text to be drawn. The string does not need to be zero-terminated, since <i>cbCount</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
      <para>This value may not exceed 8192.</para>
    </param>
    <param name="lpDx">
      <para>A pointer to an optional array of values that indicate the distance between origins of adjacent character cells. For example, lpDx[<i>i</i>] logical units separate the origins of character cell <i>i</i> and character cell <i>i</i> + 1.</para>
    </param>
    <returns>
      <para>If the string is drawn, the return value is nonzero. However, if the ANSI version of <b>ExtTextOut</b> is called with ETO_GLYPH_INDEX, the function returns <b>TRUE</b> even though the function does nothing.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current text-alignment settings for the specified device context determine how the reference point is used to position the text. The text-alignment settings are retrieved by calling the <see cref="GetTextAlign" /> function. The text-alignment settings are altered by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>If the <i>lpDx</i> parameter is <b>NULL</b>, the <b>ExtTextOut</b> function uses the default spacing between characters. The character-cell origins and the contents of the array pointed to by the <i>lpDx</i> parameter are specified in logical units. A character-cell origin is defined as the upper-left corner of the character cell.</para>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>ExtTextOut</b> for a specified device context. When this flag is set, the system ignores the <i>X</i> and <i>Y</i> parameters on subsequent <b>ExtTextOut</b> calls.</para>
      <para>For the ANSI version of <b>ExtTextOut</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. For DBCS characters, you can apportion the dx in the <i>lpDx</i> entries between the lead byte and the trail byte, as long as the sum of the two bytes adds up to the desired dx. For DBCS characters with the Unicode version of <b>ExtTextOut</b>, each Unicode glyph gets a single <i>pdx</i> entry.</para>
      <para>Note, the <i>alpDx</i> values from <see cref="GetTextExtentExPoint" /> are not the same as the <i>lpDx</i> values for <b>ExtTextOut</b>. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>
        <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. The ETO_IGNORELANGUAGE flag will inhibit this behavior and should not be passed.</para>
      <para>Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ExtTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="RECT" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
  </member>
  <member name="Windows.FillPath">
    <summary>
      <para>The <b>FillPath</b> function closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context that contains a valid path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>After its interior is filled, the path is discarded from the DC identified by the <i>hdc</i> parameter.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="SetPolyFillMode" />
    <seealso cref="StrokeAndFillPath" />
    <seealso cref="StrokePath" />
  </member>
  <member name="Windows.FillRgn">
    <summary>
      <para>The <b>FillRgn</b> function fills a region by using the specified brush.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>Handle to the region to be filled. The region's coordinates are presumed to be in logical units.</para>
    </param>
    <param name="hbr">
      <para>Handle to the brush to be used to fill the region.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="CreateBrushIndirect" />
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="CreateSolidBrush" />
    <seealso cref="PaintRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.FlattenPath">
    <summary>
      <para>The <b>FlattenPath</b> function transforms any curves in the path that is selected into the current device context (DC), turning each curve into a sequence of lines.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a DC that contains a valid path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="WidenPath" />
  </member>
  <member name="Windows.FloodFill">
    <summary>
      <para>The <b>FloodFill</b> function fills an area of the display surface with the current brush. The area is assumed to be bounded as specified by the <i>color</i> parameter.
<b>Note</b>  The <b>FloodFill</b> function is included only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="ExtFloodFill" /> function with FLOODFILLBORDER specified.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the point where filling is to start.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the point where filling is to start.</para>
    </param>
    <param name="color">
      <para>The color of the boundary or the area to be filled. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The following are reasons this function might fail:</para>
      <list type="bullet">
        <item>
          <description>The fill could not be completed.</description>
        </item>
        <item>
          <description>The given point has the boundary color specified by the <i>color</i> parameter.</description>
        </item>
        <item>
          <description>The given point lies outside the current clipping region, that is, it is not visible on the device.</description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF
</seealso>
    <seealso cref="ExtFloodFill " />
    <seealso cref="RGB " />
  </member>
  <member name="Windows.FrameRgn">
    <summary>
      <para>The <b>FrameRgn</b> function draws a border around the specified region by using the specified brush.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>Handle to the region to be enclosed in a border. The region's coordinates are presumed to be in logical units.</para>
    </param>
    <param name="hbr">
      <para>Handle to the brush to be used to draw the border.</para>
    </param>
    <param name="w">
      <para>Specifies the width, in logical units, of vertical brush strokes.</para>
    </param>
    <param name="h">
      <para>Specifies the height, in logical units, of horizontal brush strokes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="FillRgn" />
    <seealso cref="PaintRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.GdiAlphaBlend">
    <summary>
      <para>The <b>GdiAlphaBlend</b> function displays bitmaps that have transparent or semitransparent pixels.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xoriginDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yoriginDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="wDest">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hDest">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xoriginSrc">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="yoriginSrc">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="wSrc">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="hSrc">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="ftn">
      <para>The alpha-blending function for source and destination bitmaps, a global alpha value to be applied to the entire source bitmap, and format information for the source bitmap. The source and destination blend functions are currently limited to AC_SRC_OVER. See the <see cref="BLENDFUNCTION" /> and <see cref="EMRALPHABLEND" /> structures.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
      <para>This function can return the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This function is the same as <see cref="AlphaBlend" />.</para>
      <para>If the source rectangle and destination rectangle are not the same size, the source bitmap is stretched to match the destination rectangle. If the <see cref="SetStretchBltMode" /> function is used, the <i>iStretchMode</i> value is automatically converted to COLORONCOLOR for this function (that is, BLACKONWHITE, WHITEONBLACK, and HALFTONE are changed to COLORONCOLOR).</para>
      <para>The destination coordinates are transformed by using the transformation currently specified for the destination device context. The source coordinates are transformed by using the transformation currently specified for the source device context.</para>
      <para>An error occurs (and the function returns <b>FALSE</b>) if the source device context identifies an enhanced metafile device context.</para>
      <para>If destination and source bitmaps do not have the same color format, <b>GdiAlphaBlend</b> converts the source bitmap to match the destination bitmap.</para>
      <para>
        <b>GdiAlphaBlend</b> does not support mirroring. If either the width or height of the source or destination is negative, this call will fail.</para>
      <para>When rendering to a printer, first call <see cref="GetDeviceCaps" /> with SHADEBLENDCAPS to determine if the printer supports blending with <b>GdiAlphaBlend</b>. Note that, for a display DC, all blending operations are supported and these flags represent whether the operations are accelerated.</para>
      <para>If the source and destination are the same surface, that is, they are both the screen or the same memory bitmap and the source and destination rectangles overlap, an error occurs and the function returns <b>FALSE</b>.</para>
      <para>The source rectangle must lie completely within the source surface, otherwise an error occurs and the function returns <b>FALSE</b>.</para>
      <para>
        <b>GdiAlphaBlend</b> fails if the width or height of the source or destination is negative.</para>
      <para>The <b>SourceConstantAlpha</b> member of <see cref="BLENDFUNCTION" /> specifies an alpha transparency value to be used on the entire source bitmap. The <b>SourceConstantAlpha</b> value is combined with any per-pixel alpha values. If <b>SourceConstantAlpha</b> is 0, it is assumed that the image is transparent. Set the <b>SourceConstantAlpha</b> value to 255 (which indicates that the image is opaque) when you only want to use per-pixel alpha values.</para>
    </remarks>
    <seealso cref="BLENDFUNCTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="EMRALPHABLEND" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="SetStretchBltMode" />
  </member>
  <member name="Windows.GdiComment">
    <summary>
      <para>The <b>GdiComment</b> function copies a comment from a buffer into a specified enhanced-format metafile.</para>
    </summary>
    <param name="hdc">
      <para>A handle to an enhanced-metafile device context.</para>
    </param>
    <param name="nSize">
      <para>The length of the comment buffer, in bytes.</para>
    </param>
    <param name="lpData">
      <para>A pointer to the buffer that contains the comment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A comment can include any kind of private information, for example, the source of a picture and the date it was created. A comment should begin with an application signature, followed by the data.</para>
      <para>Comments should not contain application-specific or position-specific data. Position-specific data specifies the location of a record, and it should not be included because one metafile may be embedded within another metafile.</para>
      <para>A public comment is a comment that begins with the comment signature identifier GDICOMMENT_IDENTIFIER. The following public comments are defined.</para>
      <list type="table">
        <listheader>
          <description>GDICOMMENT_WINDOWS_METAFILE</description>
          <description>The GDICOMMENT_WINDOWS_METAFILE public comment contains a Windows-format metafile that is equivalent to an enhanced-format metafile. This comment is written only by the <see cref="SetWinMetaFileBits" /> function. The comment record, if given, follows the <see cref="ENHMETAHEADER" /> metafile record. The comment has the following form:</description>
        </listheader>
      </list>
      <code>
DWORD ident;         // This contains GDICOMMENT_IDENTIFIER.
DWORD iComment;      // This contains GDICOMMENT_WINDOWS_METAFILE.
DWORD nVersion;      // This contains the version number of the
                     // Windows-format metafile.
DWORD nChecksum;     // This is the additive DWORD checksum for
                     // the enhanced metafile.  The checksum
                     // for the enhanced metafile data including
                     // this comment record must be zero.
                     // Otherwise, the enhanced metafile has been
                     //  modified and the Windows-format
                     // metafile is no longer valid.
DWORD fFlags;        // This must be zero.
DWORD cbWinMetaFile; // This is the size, in bytes. of the
                     // Windows-format metafile data that follows.

</code>
      <list type="table">
        <listheader>
          <description>GDICOMMENT_BEGINGROUP</description>
          <description>The GDICOMMENT_BEGINGROUP public comment identifies the beginning of a group of drawing records. It identifies an object within an enhanced metafile. The comment has the following form:</description>
        </listheader>
      </list>
      <code>
DWORD   ident;         // This contains GDICOMMENT_IDENTIFIER.
DWORD   iComment;      // This contains GDICOMMENT_BEGINGROUP.
RECTL   rclOutput;     // This is the bounding rectangle for the
                       // object in logical coordinates.
DWORD   nDescription;  // This is the number of characters in the
                       // optional Unicode description string that
                       // follows. This is zero if there is no
                       // description string.

</code>
      <list type="table">
        <listheader>
          <description>GDICOMMENT_ENDGROUP</description>
          <description>The GDICOMMENT_ENDGROUP public comment identifies the end of a group of drawing records. The GDICOMMENT_BEGINGROUP comment and the GDICOMMENT_ENDGROUP comment must be included in a pair and may be nested. The comment has the following form:</description>
        </listheader>
      </list>
      <code>
DWORD   ident;       // This contains GDICOMMENT_IDENTIFIER.
DWORD   iComment;    // This contains GDICOMMENT_ENDGROUP.

</code>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GdiFlush">
    <summary>
      <para>The <b>GdiFlush</b> function flushes the calling thread's current batch.</para>
    </summary>
    <returns>
      <para>If all functions in the current batch succeed, the return value is nonzero.</para>
      <para>If not all functions in the current batch succeed, the return value is zero, indicating that at least one function returned an error.</para>
    </returns>
    <remarks>
      <para>Batching enhances drawing performance by minimizing the amount of time needed to call GDI drawing functions that return Boolean values. The system accumulates the parameters for calls to these functions in the current batch and then calls the functions when the batch is flushed by any of the following means:</para>
      <list type="bullet">
        <item>
          <description>Calling the <b>GdiFlush</b> function.</description>
        </item>
        <item>
          <description>Reaching or exceeding the batch limit set by the <see cref="GdiSetBatchLimit" /> function.</description>
        </item>
        <item>
          <description>Filling the batching buffers.</description>
        </item>
        <item>
          <description>Calling any GDI function that does not return a Boolean value.</description>
        </item>
      </list>
      <para>The return value for <b>GdiFlush</b> applies only to the functions in the batch at the time <b>GdiFlush</b> is called. Errors that occur when the batch is flushed by any other means are never reported.</para>
      <para>The <see cref="GdiGetBatchLimit" /> function returns the batch limit.</para>
      <para>
        <b>Note</b>  The batch limit is maintained for each thread separately. In order to completely disable batching, call <see cref="GdiSetBatchLimit" /> (1) during the initialization of each thread.</para>
      <para>An application should call <b>GdiFlush</b> before a thread goes away if there is a possibility that there are pending function calls in the graphics batch queue. The system does not execute such batched functions when a thread goes away.</para>
      <para>A multithreaded application that serializes access to GDI objects with a mutex must ensure flushing the GDI batch queue by calling <b>GdiFlush</b> as each thread releases ownership of the GDI object. This prevents collisions of the GDI objects (device contexts, metafiles, and so on).</para>
    </remarks>
    <seealso cref="GdiGetBatchLimit " />
    <seealso cref="GdiSetBatchLimit " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
  </member>
  <member name="Windows.GdiGetBatchLimit">
    <summary>
      <para>The <b>GdiGetBatchLimit</b> function returns the maximum number of function calls that can be accumulated in the calling thread's current batch. The system flushes the current batch whenever this limit is exceeded.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is the batch limit.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The batch limit is set by using the <see cref="GdiSetBatchLimit" /> function. Setting the limit to 1 effectively disables batching.</para>
      <para>Only GDI drawing functions that return Boolean values can be batched; calls to any other GDI functions immediately flush the current batch. Exceeding the batch limit or calling the <see cref="GdiFlush" /> function also flushes the current batch.</para>
      <para>When the system batches a function call, the function returns <b>TRUE</b>. The actual return value for the function is reported only if <see cref="GdiFlush" /> is used to flush the batch.</para>
      <para>
        <b>Note</b>  The batch limit is maintained for each thread separately. In order to completely disable batching, call <see cref="GdiSetBatchLimit" /> (1) during the initialization of each thread.</para>
    </remarks>
    <seealso cref="GdiFlush " />
    <seealso cref="GdiSetBatchLimit " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
  </member>
  <member name="Windows.GdiGradientFill">
    <summary>
      <para>The <b>GdiGradientFill</b> function fills rectangle and triangle structures.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="pVertex">
      <para>A pointer to an array of <see cref="TRIVERTEX" /> structures that each define a triangle vertex.</para>
    </param>
    <param name="nVertex">
      <para>The number of vertices in <i>pVertex</i>.</para>
    </param>
    <param name="pMesh">
      <para>An array of <see cref="GRADIENT_TRIANGLE" /> structures in triangle mode, or an array of <see cref="GRADIENT_RECT" /> structures in rectangle mode.</para>
    </param>
    <param name="nCount">
      <para>The number of elements (triangles or rectangles) in <i>pMesh</i>.</para>
    </param>
    <param name="ulMode">
      <para>The gradient fill mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GRADIENT_FILL_RECT_H</b>
          </description>
          <description>
            <para>In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the <see cref="TRIVERTEX" /> structure) for the left and right edges. GDI interpolates the color from the left to right edge and fills the interior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GRADIENT_FILL_RECT_V</b>
          </description>
          <description>
            <para>In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the <see cref="TRIVERTEX" /> structure) for the top and bottom edges. GDI interpolates the color from the top to bottom edge and fills the interior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GRADIENT_FILL_TRIANGLE</b>
          </description>
          <description>
            <para>In this mode, an array of <see cref="TRIVERTEX" /> structures is passed to GDI along with a list of array indexes that describe separate triangles. GDI performs linear interpolation between triangle vertices and fills the interior. Drawing is done directly in 24- and 32-bpp modes. Dithering is performed in 16-, 8-, 4-, and 1-bpp mode.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This function is the same as <see cref="GradientFill" />.</para>
      <para>To add smooth shading to a triangle, call the <b>GdiGradientFill</b> function with the three triangle endpoints. GDI will linearly interpolate and fill the triangle. Here is the drawing output of a shaded triangle.</para>
      <para>
        <img alt="Illustration of a triangle that fills from orange at the top point to magenta on the bottom line " src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillTriangle.png" />
      </para>
      <para>To add smooth shading to a rectangle, call <b>GdiGradientFill</b> with the upper-left and lower-right coordinates of the rectangle. There are two shading modes used when drawing a rectangle. In horizontal mode, the rectangle is shaded from left-to-right. In vertical mode, the rectangle is shaded from top-to-bottom. Here is the drawing output of two shaded rectangles - one in horizontal mode, the other in vertical mode.</para>
      <para>
        <img alt="Illustration of a rectangle that shades from dark on the left side to light on the right side" src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillRectangle.png" />
        <img alt="Illustration of a rectangle that shades from dark on the top to light on the bottom" src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillRectangle2.png" />
      </para>
      <para>The <b>GdiGradientFill</b> function uses a mesh method to specify the endpoints of the object to draw. All vertices are passed to <b>GdiGradientFill</b> in the <i>pVertex</i> array. The <i>pMesh</i> parameter specifies how these vertices are connected to form an object. When filling a rectangle, <i>pMesh</i> points to an array of <see cref="GRADIENT_RECT" /> structures. Each <b>GRADIENT_RECT</b> structure specifies the index of two vertices in the <i>pVertex</i> array. These two vertices form the upper-left and lower-right boundary of one rectangle.</para>
      <para>In the case of filling a triangle, <i>pMesh</i> points to an array of <see cref="GRADIENT_TRIANGLE" /> structures. Each <b>GRADIENT_TRIANGLE</b> structure specifies the index of three vertices in the <i>pVertex</i> array. These three vertices form one triangle.</para>
      <para>To simplify hardware acceleration, this routine is not required to be pixel-perfect in the triangle interior.</para>
      <para>Note that <b>GdiGradientFill</b> does not use the Alpha member of the <see cref="TRIVERTEX" /> structure. To use <b>GdiGradientFill</b> with transparency, call <b>GdiGradientFill</b> and then call <see cref="GdiAlphaBlend" /> with the desired values for the alpha channel of each vertex.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/gdi/smooth-shading">Smooth Shading</a>, <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-shaded-triangle">Drawing a Shaded Triangle</a>, and <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-shaded-rectangle">Drawing a Shaded Rectangle</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="EMRGRADIENTFILL" />
    <seealso cref="GRADIENT_RECT" />
    <seealso cref="GRADIENT_TRIANGLE" />
    <seealso cref="TRIVERTEX" />
  </member>
  <member name="Windows.GdiSetBatchLimit">
    <summary>
      <para>The <b>GdiSetBatchLimit</b> function sets the maximum number of function calls that can be accumulated in the calling thread's current batch. The system flushes the current batch whenever this limit is exceeded.</para>
    </summary>
    <param name="dw">
      <para>Specifies the batch limit to be set. A value of 0 sets the default limit. A value of 1 disables batching.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous batch limit.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Only GDI drawing functions that return Boolean values can be accumulated in the current batch; calls to any other GDI functions immediately flush the current batch. Exceeding the batch limit or calling the <see cref="GdiFlush" /> function also flushes the current batch.</para>
      <para>When the system accumulates a function call, the function returns <b>TRUE</b> to indicate it is in the batch. When the system flushes the current batch and executes the function for the second time, the return value is either <b>TRUE</b> or <b>FALSE</b>, depending on whether the function succeeds. This second return value is reported only if <see cref="GdiFlush" /> is used to flush the batch.</para>
      <para>
        <b>Note</b>  The batch limit is maintained for each thread separately. In order to completely disable batching, call <b>GdiSetBatchLimit</b> (1) during the initialization of each thread.</para>
    </remarks>
    <seealso cref="GdiFlush " />
    <seealso cref="GdiGetBatchLimit " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
  </member>
  <member name="Windows.GdiTransparentBlt">
    <summary>
      <para>The <b>GdiTransparentBlt</b> function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.
<b>Note</b>  This function is the same as <see cref="TransparentBlt" />.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xoriginDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yoriginDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="wDest">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hDest">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xoriginSrc">
      <para>The x-coordinate, in logical units, of the source rectangle.</para>
    </param>
    <param name="yoriginSrc">
      <para>The y-coordinate, in logical units, of the source rectangle.</para>
    </param>
    <param name="wSrc">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="hSrc">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="crTransparent">
      <para>The RGB color in the source bitmap to treat as transparent.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The <b>GdiTransparentBlt</b> function works with compatible bitmaps (DDBs).</para>
      <para>The <see cref="GdiTransparentBlt" /> function supports all formats of source bitmaps. However, for 32 bpp bitmaps, it just copies the alpha value over. Use <see cref="AlphaBlend" /> to specify 32 bits-per-pixel bitmaps with transparency.</para>
      <para>If the source and destination rectangles are not the same size, the source bitmap is stretched to match the destination rectangle. When the <see cref="SetStretchBltMode" /> function is used, the <i>iStretchMode</i> modes of BLACKONWHITE and WHITEONBLACK are converted to COLORONCOLOR for the <b>GdiTransparentBlt</b> function.</para>
      <para>The destination device context specifies the transformation type for the destination coordinates. The source device context specifies the transformation type for the source coordinates.</para>
      <para>
        <b>GdiTransparentBlt</b> does not mirror a bitmap if either the width or height, of either the source or destination, is negative.</para>
      <para>When used in a multiple monitor system, both <i>hdcSrc</i> and <i>hdcDest</i> must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
    </remarks>
    <seealso cref="AlphaBlend" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="SetDIBits" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.GetArcDirection">
    <summary>
      <para>The <b>GetArcDirection</b> function retrieves the current arc direction for the specified device context. Arc and rectangle functions use the arc direction.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <returns>
      <para>The return value specifies the current arc direction; it can be any one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>AD_COUNTERCLOCKWISE</description>
          <description>Arcs and rectangles are drawn counterclockwise.</description>
        </item>
        <item>
          <description>AD_CLOCKWISE</description>
          <description>Arcs and rectangles are drawn clockwise.</description>
        </item>
      </list>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="SetArcDirection" />
  </member>
  <member name="Windows.GetAspectRatioFilterEx">
    <summary>
      <para>The <b>GetAspectRatioFilterEx</b> function retrieves the setting for the current aspect-ratio filter.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context.</para>
    </param>
    <param name="lpsize">
      <para>Pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the current aspect-ratio filter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The aspect ratio is the ratio formed by the width and height of a pixel on a specified device.</para>
      <para>The system provides a special filter, the aspect-ratio filter, to select fonts that were designed for a particular device. An application can specify that the system should only retrieve fonts matching the specified aspect ratio by calling the <see cref="SetMapperFlags" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetMapperFlags" />
  </member>
  <member name="Windows.GetBitmapBits">
    <summary>
      <para>The <b>GetBitmapBits</b> function copies the bitmap bits of a specified device-dependent bitmap into a buffer.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="GetDIBits" /> function.</para>
    </summary>
    <param name="hbit">
      <para>A handle to the device-dependent bitmap.</para>
    </param>
    <param name="cb">
      <para>The number of bytes to copy from the bitmap into the buffer.</para>
    </param>
    <param name="lpvBits">
      <para>A pointer to a buffer to receive the bitmap bits. The bits are stored as an array of byte values.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
  </member>
  <member name="Windows.GetBitmapDimensionEx">
    <summary>
      <para>The <b>GetBitmapDimensionEx</b> function retrieves the dimensions of a compatible bitmap. The retrieved dimensions must have been set by the <see cref="SetBitmapDimensionEx" /> function.</para>
    </summary>
    <param name="hbit">
      <para>A handle to a compatible bitmap (DDB).</para>
    </param>
    <param name="lpsize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure to receive the bitmap dimensions. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The function returns a data structure that contains fields for the height and width of the bitmap, in .01-mm units. If those dimensions have not yet been set, the structure that is returned will have zeros in those fields.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetBitmapDimensionEx" />
  </member>
  <member name="Windows.GetBkColor">
    <summary>
      <para>The <b>GetBkColor</b> function returns the current background color for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context whose background color is to be returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value for the current background color.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="GetBkMode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="SetBkColor" />
  </member>
  <member name="Windows.GetBkMode">
    <summary>
      <para>The <b>GetBkMode</b> function returns the current background mix mode for a specified device context. The background mix mode of a device context affects text, hatched brushes, and pen styles that are not solid lines.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context whose background mode is to be returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the current background mix mode, either OPAQUE or TRANSPARENT.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="GetBkColor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="SetBkMode" />
  </member>
  <member name="Windows.GetBoundsRect">
    <summary>
      <para>The <b>GetBoundsRect</b> function obtains the current accumulated bounding rectangle for a specified device context.</para>
      <para>The system maintains an accumulated bounding rectangle for each application. An application can retrieve and set this rectangle.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context whose bounding rectangle the function will return.</para>
    </param>
    <param name="lprect">
      <para>A pointer to the <see cref="RECT" /> structure that will receive the current bounding rectangle. The application's rectangle is returned in logical coordinates, and the bounding rectangle is returned in screen coordinates.</para>
    </param>
    <param name="flags">
      <para>Specifies how the <b>GetBoundsRect</b> function will behave. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DCB_RESET</b>
          </description>
          <description>
            <para>Clears the bounding rectangle after returning it. If this flag is not set, the bounding rectangle will not be cleared.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The return value specifies the state of the accumulated bounding rectangle; it can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>0</description>
          <description>An error occurred. The specified device context handle is invalid.</description>
        </item>
        <item>
          <description>DCB_DISABLE</description>
          <description>Boundary accumulation is off.</description>
        </item>
        <item>
          <description>DCB_ENABLE</description>
          <description>Boundary accumulation is on.</description>
        </item>
        <item>
          <description>DCB_RESET</description>
          <description>The bounding rectangle is empty.</description>
        </item>
        <item>
          <description>DCB_SET</description>
          <description>The bounding rectangle is not empty.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The DCB_SET value is a combination of the bit values DCB_ACCUMULATE and DCB_RESET. Applications that check the DCB_RESET bit to determine whether the bounding rectangle is empty must also check the DCB_ACCUMULATE bit. The bounding rectangle is empty only if the DCB_RESET bit is 1 and the DCB_ACCUMULATE bit is 0.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="SetBoundsRect" />
  </member>
  <member name="Windows.GetBrushOrgEx">
    <summary>
      <para>The <b>GetBrushOrgEx</b> function retrieves the current brush origin for the specified device context. This function replaces the <b>GetBrushOrg</b> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the brush origin, in device coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>The brush origin is a set of coordinates with values between 0 and 7, specifying the location of one pixel in the bitmap. The default brush origin coordinates are (0,0). For horizontal coordinates, the value 0 corresponds to the leftmost column of pixels; the value 7 corresponds to the rightmost column. For vertical coordinates, the value 0 corresponds to the uppermost row of pixels; the value 7 corresponds to the lowermost row. When the system positions the brush at the start of any painting operation, it maps the origin of the brush to the location in the window's client area specified by the brush origin. For example, if the origin is set to (2,3), the system maps the origin of the brush (0,0) to the location (2,3) on the window's client area.</para>
      <para>If an application uses a brush to fill the backgrounds of both a parent and a child window with matching colors, it may be necessary to set the brush origin after painting the parent window but before painting the child window.</para>
      <para>The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="SelectObject" />
    <seealso cref="SetBrushOrgEx" />
    <seealso cref="UnrealizeObject" />
  </member>
  <member name="Windows.GetBValue">
    <summary>
      <para>The <b>GetBValue</b> macro retrieves an intensity value for the blue component of a red, green, blue (RGB) value.</para>
    </summary>
    <param name="rgb">
      <para>Specifies an RGB color value.</para>
    </param>
    <remarks>
      <para>The intensity value is in the range 0 through 255.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetGValue" />
    <seealso cref="GetRValue" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</seealso>
    <seealso cref="PALETTERGB" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.GetCharABCWidths">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidthsA">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidthsW">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidthsFloat">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsFloatA">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsFloatW">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsFloat">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsFloatA">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsFloatW">
    <summary>
      <para>The <b>GetCharABCWidthsFloat</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>Specifies the code point of the first character in the group of consecutive characters where the ABC widths are seeked.</para>
    </param>
    <param name="iLast">
      <para>Specifies the code point of the last character in the group of consecutive characters where the ABC widths are seeked. This range is inclusive. An error is returned if the specified last character precedes the specified first character.</para>
    </param>
    <param name="lpABC">
      <para>Pointer to an array of <see cref="ABCFLOAT" /> structures that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="GetCharABCWidths" /> function that returns widths only for TrueType fonts, the <b>GetCharABCWidthsFloat</b> function retrieves widths for any font. The widths returned by this function are in the IEEE floating-point format.</para>
      <para>If the current world-to-device transformation is not identified, the returned widths may be noninteger values, even if the corresponding values in the device space are integers.</para>
      <para>A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>The ABC spaces are measured along the character base line of the selected font.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidthsFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABCFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharABCWidthsI">
    <summary>
      <para>The <b>GetCharABCWidthsI</b> function retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="giFirst">
      <para>The first glyph index in the group of consecutive glyph indices from the current font. This parameter is only used if the <i>pgi</i> parameter is <b>NULL</b>.</para>
    </param>
    <param name="cgi">
      <para>The number of glyph indices.</para>
    </param>
    <param name="pgi">
      <para>A pointer to an array that contains glyph indices. If this parameter is <b>NULL</b>, the <i>giFirst</i> parameter is used instead. The <i>cgi</i> parameter specifies the number of glyph indices in this array.</para>
    </param>
    <param name="pabc">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are glyph indices specified by the <i>cgi</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidthsI</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of glyph indices in non-TrueType fonts, applications should use the <see cref="GetCharWidthI" /> function.</para>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidths">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidthsA">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharABCWidthsW">
    <summary>
      <para>The <b>GetCharABCWidths</b> function retrieves the widths, in logical units, of consecutive characters in a specified range from the current TrueType font. This function succeeds only with TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="wFirst">
      <para>The first character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="wLast">
      <para>The last character in the group of consecutive characters from the current font.</para>
    </param>
    <param name="lpABC">
      <para>A pointer to an array of <see cref="ABC" /> structures that receives the character widths, in logical units. This array must contain at least as many <b>ABC</b> structures as there are characters in the range specified by the <i>uFirstChar</i> and <i>uLastChar</i> parameters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The TrueType rasterizer provides ABC character spacing after a specific point size has been selected. A spacing is the distance added to the current position before placing the glyph. B spacing is the width of the black part of the glyph. C spacing is the distance added to the current position to provide white space to the right of the glyph. The total advanced width is specified by A+B+C.</para>
      <para>When the <b>GetCharABCWidths</b> function retrieves negative A or C widths for a character, that character includes underhangs or overhangs.</para>
      <para>To convert the ABC widths to font design units, an application should use the value stored in the <b>otmEMSquare</b> member of a <see cref="OUTLINETEXTMETRIC" /> structure. This value can be retrieved by calling the <see cref="GetOutlineTextMetrics" /> function.</para>
      <para>The ABC widths of the default character are used for characters outside the range of the currently selected font.</para>
      <para>To retrieve the widths of characters in non-TrueType fonts, applications should use the <see cref="GetCharWidth" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharABCWidths as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ABC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharWidth" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetCharacterPlacement">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharacterPlacementA">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharacterPlacementW">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharacterPlacement">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharacterPlacementA">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharacterPlacementW">
    <summary>
      <para>The <b>GetCharacterPlacement</b> function retrieves information about a character string, such as character widths, caret positioning, ordering within the string, and glyph rendering. The type of information returned depends on the <i>dwFlags</i> parameter and is based on the currently selected font in the specified display context. The function copies the information to the specified <see cref="GCP_RESULTS" /> structure or to one or more arrays specified by the structure.</para>
      <para>Although this function was once adequate for working with character strings, a need to work with an increasing number of languages and scripts has rendered it obsolete. It has been superseded by the functionality of the Uniscribe module. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a>.</para>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the character string to process. The string does not need to be zero-terminated, since <i>nCount</i> specifies the length of the string.</para>
    </param>
    <param name="nCount">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="nMexExtent">
      <para>The maximum extent (in logical units) to which the string is processed. Characters that, if processed, would exceed this extent are ignored. Computations for any required ordering or glyph arrays apply only to the included characters. This parameter is used only if the GCP_MAXEXTENT value is specified in the <i>dwFlags</i> parameter. As the function processes the input string, each character and its extent is added to the output, extent, and other arrays only if the total extent has not yet exceeded the maximum. Once the limit is reached, processing will stop.</para>
    </param>
    <param name="lpResults">
      <para>A pointer to a <see cref="GCP_RESULTS" /> structure that receives the results of the function.</para>
    </param>
    <param name="dwFlags">
      <para>Specifies how to process the string into the required arrays. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GCP_CLASSIN</b>
          </description>
          <description>
            <para>Specifies that the <i>lpClass</i> array contains preset classifications for characters. The classifications may be the same as on output. If the particular classification for a character is not known, the corresponding location in the array must be set to zero. for more information about the classifications, see GCP_RESULTS. This is useful only if <see cref="GetFontLanguageInfo" /> returned the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DIACRITIC</b>
          </description>
          <description>
            <para>Determines how diacritics in the string are handled. If this value is not set, diacritics are treated as zero-width characters. For example, a Hebrew string may contain diacritics, but you may not want to display them.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether a font supports diacritics. If it does, you can use or not use the GCP_DIACRITIC flag in the call to <b>GetCharacterPlacement</b>, depending on the needs of your application.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_DISPLAYZWG</b>
          </description>
          <description>
            <para>For languages that need reordering or different glyph shapes depending on the positions of the characters within a word, nondisplayable characters often appear in the code page. For example, in the Hebrew code page, there are Left-To-Right and Right-To-Left markers, to help determine the final positioning of characters within the output strings. Normally these are not displayed and are removed from the <i>lpGlyphs</i> and <i>lpDx</i> arrays. You can use the GCP_DISPLAYZWG flag to display these characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_GLYPHSHAPE</b>
          </description>
          <description>
            <para>Specifies that some or all characters in the string are to be displayed using shapes other than the standard shapes defined in the currently selected font for the current code page. Some languages, such as Arabic, cannot support glyph creation unless this value is specified. As a general rule, if <see cref="GetFontLanguageInfo" /> returns this value for a string, this value must be used with <b>GetCharacterPlacement</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_JUSTIFY</b>
          </description>
          <description>
            <para>Adjusts the extents in the <i>lpDx</i> array so that the string length is the same as <i>nMaxExtent</i>. GCP_JUSTIFY may only be used in conjunction with GCP_MAXEXTENT.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_KASHIDA</b>
          </description>
          <description>
            <para>Use Kashidas as well as, or instead of, adjusted extents to modify the length of the string so that it is equal to the value specified by <i>nMaxExtent</i>. In the <i>lpDx</i> array, a Kashida is indicated by a negative justification index. GCP_KASHIDA may be used only in conjunction with GCP_JUSTIFY and only if the font (and language) support Kashidas. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports Kashidas.</para>
            <para>Using Kashidas to justify the string can result in the number of glyphs required being greater than the number of characters in the input string. Because of this, when Kashidas are used, the application cannot assume that setting the arrays to be the size of the input string will be sufficient. (The maximum possible will be approximately dxPageWidth/dxAveCharWidth, where dxPageWidth is the width of the document and dxAveCharWidth is the average character width as returned from a <see cref="GetTextMetrics" /> call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_KASHIDA flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_LIGATE</b>
          </description>
          <description>
            <para>Use ligations wherever characters ligate. A ligation occurs where one glyph is used for two or more characters. For example, the letters a and e can ligate to ?. For this to be used, however, both the language support and the font must support the required glyphs (the example will not be processed by default in English).</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports ligation. If it does and a specific maximum is required for the number of characters that will ligate, set the number in the first element of the <b>lpGlyphs</b> array. If normal ligation is required, set this value to zero. If GCP_LIGATE is not specified, no ligation will take place. See GCP_RESULTS for more information.</para>
            <para>If the GCP_REORDER value is usually required for the character set but is not specified, the output will be meaningless unless the string being passed in is already in visual ordering (that is, the result that gets put into lpGcpResults-&gt;lpOutString in one call to <b>GetCharacterPlacement</b> is the input string of a second call).</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_LIGATE flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_MAXEXTENT</b>
          </description>
          <description>
            <para>Compute extents of the string only as long as the resulting extent, in logical units, does not exceed the values specified by the <i>nMaxExtent</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NEUTRALOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of neutrals and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICOVERRIDE</b>
          </description>
          <description>
            <para>Certain languages only. Override the normal handling of numerics and treat them as strong characters that match the strings reading order. Useful only with the GCP_REORDER flag.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLATIN</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use standard Latin glyphs for numbers and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_NUMERICSLOCAL</b>
          </description>
          <description>
            <para>Arabic/Thai only. Use local glyphs for numeric characters and override the system default. To determine if this option is available in the language of the font, use <see cref="GetStringTypeEx" /> to see if the language supports more than one number format.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_REORDER</b>
          </description>
          <description>
            <para>Reorder the string. Use for languages that are not SBCS and left-to-right reading order. If this value is not specified, the string is assumed to be in display order already.</para>
            <para>If this flag is set for Semitic languages and the <b>lpClass</b> array is used, the first two elements of the array are used to specify the reading order beyond the bounds of the string. GCP_CLASS_PREBOUNDRTL and GCP_CLASS_PREBOUNDLTR can be used to set the order. If no preset order is required, set the values to zero. These values can be combined with other values if the GCPCLASSIN flag is set.</para>
            <para>If the GCP_REORDER value is not specified, the <i>lpString</i> parameter is taken to be visual ordered for languages where this is used, and the <i>lpOutString</i> and <i>lpOrder</i> fields are ignored.</para>
            <para>Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports reordering.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_SYMSWAPOFF</b>
          </description>
          <description>
            <para>Semitic languages only. Specifies that swappable characters are not reset. For example, in a right-to-left string, the '(' and ')' are not reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GCP_USEKERNING</b>
          </description>
          <description>
            <para>Use kerning pairs in the font (if any) when creating the widths arrays. Use <see cref="GetFontLanguageInfo" /> to determine whether the current font supports kerning pairs.</para>
            <para>Note that just because <see cref="GetFontLanguageInfo" /> returns the GCP_USEKERNING flag does not mean that it has to be used in the call to <b>GetCharacterPlacement</b>, just that the option is available. Most TrueType fonts have a kerning table, but you do not have to use it.</para>
          </description>
        </item>
      </list>
      <para>It is recommended that an application use the <see cref="GetFontLanguageInfo" /> function to determine whether the GCP_DIACRITIC, GCP_DBCS, GCP_USEKERNING, GCP_LIGATE, GCP_REORDER, GCP_GLYPHSHAPE, and GCP_KASHIDA values are valid for the currently selected font. If not valid, <b>GetCharacterPlacement</b> ignores the value.</para>
      <para>The GCP_NODIACRITICS value is no longer defined and should not be used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the  width and height of the string in logical units. The width is the low-order word and the height is the high-order word.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharacterPlacement</b> ensures that an application can correctly process text regardless of the international setting and type of fonts available. Applications use this function before using the <see cref="ExtTextOut" /> function and in place of the <see cref="GetTextExtentPoint32" /> function (and occasionally in place of the <see cref="GetCharWidth32" /> and <see cref="GetCharABCWidths" /> functions).</para>
      <para>Using <b>GetCharacterPlacement</b> to retrieve intercharacter spacing and index arrays is not always necessary unless justification or kerning is required. For non-Latin fonts, applications can improve the speed at which the <see cref="ExtTextOut" /> function renders text by using <b>GetCharacterPlacement</b> to retrieve the intercharacter spacing and index arrays before calling <b>ExtTextOut</b>. This is especially useful when rendering the same text repeatedly or when using intercharacter spacing to position the caret. If the <b>lpGlyphs</b> output array is used in the call to <b>ExtTextOut</b>, the ETO_GLYPH_INDEX flag must be set.</para>
      <para>
        <b>GetCharacterPlacement</b> checks the <b>lpOrder</b>, <b>lpDX</b>, <b>lpCaretPos</b>, <b>lpOutString</b>, and <b>lpGlyphs</b> members of the <see cref="GCP_RESULTS" /> structure and fills the corresponding arrays if these members are not set to <b>NULL</b>. If <b>GetCharacterPlacement</b> cannot fill an array, it sets the corresponding member to <b>NULL</b>. To ensure retrieval of valid information, the application is responsible for setting the member to a valid address before calling the function and for checking the value of the member after the call. If the GCP_JUSTIFY or GCP_USEKERNING values are specified, the <b>lpDX</b> and/or <b>lpCaretPos</b> members must have valid addresses.</para>
      <para>Note that the glyph indexes returned in GCP_RESULTS.lpGlyphs are specific to the current font in the device context and should only be used to draw text in the device context while that font remains selected.</para>
      <para>When computing justification, if the trailing characters in the string are spaces, the function reduces the length of the string and removes the spaces prior to computing the justification. If the array consists of only spaces, the function returns an error.</para>
      <para>
        <see cref="ExtTextOut" /> expects an <b>lpDX</b> entry for each byte of a DBCS string, whereas <b>GetCharacterPlacement</b> assigns an <b>lpDX</b> entry for each glyph. To correct this mismatch when using this combination of functions, either use <see cref="GetGlyphIndices" /> or expand the <b>lpDX</b> array with zero-width entries for the corresponding second byte of a DBCS byte pair.</para>
      <para>If the logical width is less than the width of the leading character in the input string, GCP_RESULTS.nMaxFit returns a bad value. For this case, call <b>GetCharacterPlacement</b> for glyph indexes and the <b>lpDX</b> array. Then use the <b>lpDX</b> array to do the extent calculation using the advance width of each character, where <b>nMaxFit</b> is the number of characters whose glyph indexes advance width is less than the width of the leading character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharacterPlacement as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GCP_RESULTS" />
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetFontLanguageInfo" />
    <seealso cref="GetStringTypeEx" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetCharWidth32">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth32A">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth32W">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth32">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth32A">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth32W">
    <summary>
      <para>The <b>GetCharWidth32</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth32</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidthA">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidthW">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidthFloat">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthFloatA">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthFloatW">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthFloat">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthFloatA">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthFloatW">
    <summary>
      <para>The <b>GetCharWidthFloat</b> function retrieves the fractional widths of consecutive characters in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The code point of the first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The code point of the last character in the group of consecutive characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The returned widths are in the 32-bit IEEE floating-point format. (The widths are measured along the base line of the characters.)</para>
      <para>If the <i>iFirstChar</i> parameter specifies the letter a and the <i>iLastChar</i> parameter specifies the letter z, <b>GetCharWidthFloat</b> retrieves the widths of all lowercase characters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidthFloat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
  </member>
  <member name="Windows.GetCharWidthI">
    <summary>
      <para>The <b>GetCharWidthI</b> function retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="giFirst">
      <para>The first glyph index in the group of consecutive glyph indices.</para>
    </param>
    <param name="cgi">
      <para>The number of glyph indices.</para>
    </param>
    <param name="pgi">
      <para>A pointer to an array of glyph indices. If this parameter is not <b>NULL</b>, it is used instead of the <i>giFirst</i> parameter.</para>
    </param>
    <param name="piWidths">
      <para>A pointer to a buffer that receives the widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetCharWidthI</b> function processes a consecutive glyph indices if the <i>pgi</i> parameter is <b>NULL</b> with the <i>giFirst</i> parameter indicating the first glyph index to process and the <i>cgi</i> parameter indicating how many glyph indices to process. Otherwise the <b>GetCharWidthI</b> function processes the array of glyph indices pointed to by the <i>pgi</i> parameter with the <i>cgi</i> parameter indicating how many glyph indices to process.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidth">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidthA">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetCharWidthW">
    <summary>
      <para>The <b>GetCharWidth</b> function retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetCharWidth32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iFirst">
      <para>The first character in the group of consecutive characters.</para>
    </param>
    <param name="iLast">
      <para>The last character in the group of consecutive characters, which must not precede the specified first character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the character widths, in logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>GetCharWidth</b> cannot be used on TrueType fonts. To retrieve character widths for TrueType fonts, use <see cref="GetCharABCWidths" />.</para>
      <para>The range is inclusive; that is, the returned widths include the widths of the characters specified by the <i>iFirstChar</i> and <i>iLastChar</i> parameters.</para>
      <para>If a character does not exist in the current font, it is assigned the width of the default character.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetCharWidth as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharABCWidths" />
    <seealso cref="GetCharABCWidthsFloat" />
    <seealso cref="GetCharWidth32" />
    <seealso cref="GetCharWidthFloat" />
  </member>
  <member name="Windows.GetClipBox">
    <summary>
      <para>The <b>GetClipBox</b> function retrieves the dimensions of the tightest bounding rectangle that can be drawn around the current visible area on the device. The visible area is defined by the current clipping region or clip path, as well as any overlapping windows.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lprect">
      <para>A pointer to a <see cref="RECT" /> structure that is to receive the rectangle dimensions, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the clipping box's complexity and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred.</para>
          </description>
        </item>
      </list>
      <para>
        <b>GetClipBox</b> returns logical coordinates based on the given device context.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="RECT" />
  </member>
  <member name="Windows.GetClipRgn">
    <summary>
      <para>The <b>GetClipRgn</b> function retrieves a handle identifying the current application-defined clipping region for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>A handle to an existing region before the function is called. After the function returns, this parameter is a handle to a copy of the current clipping region.</para>
    </param>
    <returns>
      <para>If the function succeeds and there is no clipping region for the given device context, the return value is zero. If the function succeeds and there is a clipping region for the given device context, the return value is 1. If an error occurs, the return value is -1.</para>
    </returns>
    <remarks>
      <para>An application-defined clipping region is a clipping region identified by the <see cref="SelectClipRgn" /> function. It is not a clipping region created when the application calls the <see cref="BeginPaint" /> function.</para>
      <para>If the function succeeds, the <i>hrgn</i> parameter is a handle to a copy of the current clipping region. Subsequent changes to this copy will not affect the current clipping region.</para>
    </remarks>
    <seealso cref="BeginPaint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="SelectClipRgn" />
  </member>
  <member name="Windows.GetColorAdjustment">
    <summary>
      <para>The <b>GetColorAdjustment</b> function retrieves the color adjustment values for the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpca">
      <para>A pointer to a <see cref="COLORADJUSTMENT" /> structure that receives the color adjustment values.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="COLORADJUSTMENT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="SetColorAdjustment" />
  </member>
  <member name="Windows.GetColorSpace">
    <summary>
      <para>The <b>GetColorSpace</b> function retrieves the handle to the input <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> from a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context that is to have its input color space handle retrieved.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current input color space handle.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetColorSpace</b> obtains the handle to the input color space regardless of whether color management is enabled for the device context.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetCurrentObject">
    <summary>
      <para>The <b>GetCurrentObject</b> function retrieves a handle to an object of the specified type that has been selected into the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="type">
      <para>The object type to be queried. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OBJ_BITMAP</b>
          </description>
          <description>
            <para>Returns the current selected bitmap.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJ_BRUSH</b>
          </description>
          <description>
            <para>Returns the current selected brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJ_COLORSPACE</b>
          </description>
          <description>
            <para>Returns the current color space.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJ_FONT</b>
          </description>
          <description>
            <para>Returns the current selected font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJ_PAL</b>
          </description>
          <description>
            <para>Returns the current selected palette.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJ_PEN</b>
          </description>
          <description>
            <para>Returns the current selected pen.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified object.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application can use the <b>GetCurrentObject</b> and <see cref="GetObject" /> functions to retrieve descriptions of the graphic objects currently selected into the specified DC.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/retrieving-graphic-object-attributes-and-selecting-new-graphic-objects">Retrieving Graphic-Object Attributes and Selecting New Graphic Objects</a>.</para>
    </remarks>
    <seealso cref="CreateColorSpace" />
    <seealso cref="DeleteObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetObject" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.GetCurrentPositionEx">
    <summary>
      <para>The <b>GetCurrentPositionEx</b> function retrieves the current position in logical coordinates.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the logical coordinates of the current position.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
  </member>
  <member name="Windows.GetCValue">
    <summary>
      <para>The <b>GetCValue</b> macro retrieves the cyan color value from a CMYK color value.</para>
    </summary>
    <param name="cmyk">
      <para>CMYK color value from which the cyan color value will be retrieved.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="CMYK" />
    <seealso cref="GetKValue" />
    <seealso cref="GetMValue" />
    <seealso cref="GetYValue" />
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/macros-for-cmyk-values-and-colors">Macros for CMYK values and colors</seealso>
  </member>
  <member name="Windows.GetDCBrushColor">
    <summary>
      <para>The <b>GetDCBrushColor</b> function retrieves the current brush color for the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC whose brush color is to be returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value for the current DC brush color.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>For information on setting the brush color, see <see cref="SetDCBrushColor" />.</para>
      <para>
        <b>ICM:</b> Color management is performed if ICM is enabled.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SetDCBrushColor" />
  </member>
  <member name="Windows.GetDCOrgEx">
    <summary>
      <para>The <b>GetDCOrgEx</b> function retrieves the final translation origin for a specified device context (DC). The final translation origin specifies an offset that the system uses to translate device coordinates into client coordinates (for coordinates in an application's window).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC whose final translation origin is to be retrieved.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the final translation origin, in device coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The final translation origin is relative to the physical origin of the screen.</para>
    </remarks>
    <seealso cref="CreateIC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
  </member>
  <member name="Windows.GetDCPenColor">
    <summary>
      <para>The <b>GetDCPenColor</b> function retrieves the current pen color for the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC whose brush color is to be returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value for the current DC pen color.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>For information on setting the pen color, see <see cref="SetDCPenColor" />.</para>
      <para>
        <b>ICM:</b> Color management is performed if ICM is enabled.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SetDCPenColor" />
  </member>
  <member name="Windows.GetDeviceCaps">
    <summary>
      <para>The <b>GetDeviceCaps</b> function retrieves device-specific information for the specified device.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="index">
      <para>The item to be returned. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Index</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DRIVERVERSION</b>
          </description>
          <description>
            <para>The device driver version.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TECHNOLOGY</b>
          </description>
          <description>
            <para>Device technology. It can be any one of the following values.</para>
            <list type="table">
              <listheader>
                <description>DT_PLOTTER</description>
                <description>Vector plotter</description>
              </listheader>
              <item>
                <description>DT_RASDISPLAY</description>
                <description>Raster display</description>
              </item>
              <item>
                <description>DT_RASPRINTER</description>
                <description>Raster printer</description>
              </item>
              <item>
                <description>DT_RASCAMERA</description>
                <description>Raster camera</description>
              </item>
              <item>
                <description>DT_CHARSTREAM</description>
                <description>Character stream</description>
              </item>
              <item>
                <description>DT_METAFILE</description>
                <description>Metafile</description>
              </item>
              <item>
                <description>DT_DISPFILE</description>
                <description>Display file</description>
              </item>
            </list>
            <para>If the <i>hdc</i> parameter is a handle to the DC of an enhanced metafile, the device technology is that of the referenced device as specified to the <see cref="CreateEnhMetaFile" /> function. To determine whether it is an enhanced metafile DC, use the <see cref="GetObjectType" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>HORZSIZE</b>
          </description>
          <description>
            <para>Width, in millimeters, of the physical screen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>VERTSIZE</b>
          </description>
          <description>
            <para>Height, in millimeters, of the physical screen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>HORZRES</b>
          </description>
          <description>
            <para>Width, in pixels, of the screen; or for printers, the width, in pixels, of the printable area of the page.</para>
          </description>
        </item>
        <item>
          <description>
            <b>VERTRES</b>
          </description>
          <description>
            <para>Height, in raster lines, of the screen; or for printers, the height, in pixels, of the printable area of the page.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGPIXELSX</b>
          </description>
          <description>
            <para>Number of pixels per logical inch along the screen width. In a system with multiple display monitors, this value is the same for all monitors.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGPIXELSY</b>
          </description>
          <description>
            <para>Number of pixels per logical inch along the screen height. In a system with multiple display monitors, this value is the same for all monitors.</para>
          </description>
        </item>
        <item>
          <description>
            <b>BITSPIXEL</b>
          </description>
          <description>
            <para>Number of adjacent color bits for each pixel.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PLANES</b>
          </description>
          <description>
            <para>Number of color planes.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NUMBRUSHES</b>
          </description>
          <description>
            <para>Number of device-specific brushes.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NUMPENS</b>
          </description>
          <description>
            <para>Number of device-specific pens.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NUMFONTS</b>
          </description>
          <description>
            <para>Number of device-specific fonts.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NUMCOLORS</b>
          </description>
          <description>
            <para>Number of entries in the device's color table, if the device has a color depth of no more than 8 bits per pixel. For devices with greater color depths, 1 is returned.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ASPECTX</b>
          </description>
          <description>
            <para>Relative width of a device pixel used for line drawing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ASPECTY</b>
          </description>
          <description>
            <para>Relative height of a device pixel used for line drawing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ASPECTXY</b>
          </description>
          <description>
            <para>Diagonal width of the device pixel used for line drawing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PDEVICESIZE</b>
          </description>
          <description>
            <para>Reserved.</para>
          </description>
        </item>
        <item>
          <description>
            <b>CLIPCAPS</b>
          </description>
          <description>
            <para>Flag that indicates the clipping capabilities of the device. If the device can clip to a rectangle, it is 1. Otherwise, it is 0.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SIZEPALETTE</b>
          </description>
          <description>
            <para>Number of entries in the system palette. This index is valid only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index and is available only if the driver is compatible with 16-bit Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NUMRESERVED</b>
          </description>
          <description>
            <para>Number of reserved entries in the system palette. This index is valid only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index and is available only if the driver is compatible with 16-bit Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <b>COLORRES</b>
          </description>
          <description>
            <para>Actual color resolution of the device, in bits per pixel. This index is valid only if the device driver sets the RC_PALETTE bit in the RASTERCAPS index and is available only if the driver is compatible with 16-bit Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PHYSICALWIDTH</b>
          </description>
          <description>
            <para>For printing devices: the width of the physical page, in device units. For example, a printer set to print at 600 dpi on 8.5-x11-inch paper has a physical width value of 5100 device units. Note that the physical page is almost always greater than the printable area of the page, and never smaller.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PHYSICALHEIGHT</b>
          </description>
          <description>
            <para>For printing devices: the height of the physical page, in device units. For example, a printer set to print at 600 dpi on 8.5-by-11-inch paper has a physical height value of 6600 device units. Note that the physical page is almost always greater than the printable area of the page, and never smaller.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PHYSICALOFFSETX</b>
          </description>
          <description>
            <para>For printing devices: the distance from the left edge of the physical page to the left edge of the printable area, in device units. For example, a printer set to print at 600 dpi on 8.5-by-11-inch paper, that cannot print on the leftmost 0.25-inch of paper, has a horizontal physical offset of 150 device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PHYSICALOFFSETY</b>
          </description>
          <description>
            <para>For printing devices: the distance from the top edge of the physical page to the top edge of the printable area, in device units. For example, a printer set to print at 600 dpi on 8.5-by-11-inch paper, that cannot print on the topmost 0.5-inch of paper, has a vertical physical offset of 300 device units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>VREFRESH</b>
          </description>
          <description>
            <para>For display devices: the current vertical refresh rate of the device, in cycles per second (Hz).</para>
            <para>A vertical refresh rate value of 0 or 1 represents the display hardware's default refresh rate. This default rate is typically set by switches on a display card or computer motherboard, or by a configuration program that does not use display functions such as <see cref="ChangeDisplaySettings" />.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SCALINGFACTORX</b>
          </description>
          <description>
            <para>Scaling factor for the x-axis of the printer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SCALINGFACTORY</b>
          </description>
          <description>
            <para>Scaling factor for the y-axis of the printer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>BLTALIGNMENT</b>
          </description>
          <description>
            <para>Preferred horizontal drawing alignment, expressed as a multiple of pixels. For best drawing performance, windows should be horizontally aligned to a multiple of this value. A value of zero indicates that the device is accelerated, and any alignment may be used.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SHADEBLENDCAPS</b>
          </description>
          <description>
            <para>Value that indicates the shading and blending capabilities of the device. See Remarks for further comments.</para>
            <list type="table">
              <listheader>
                <description>SB_CONST_ALPHA</description>
                <description>Handles the <b>SourceConstantAlpha</b> member of the <see cref="BLENDFUNCTION" /> structure, which is referenced by the blendFunction parameter of the <see cref="AlphaBlend" /> function.</description>
              </listheader>
              <item>
                <description>SB_GRAD_RECT</description>
                <description>Capable of doing <see cref="GradientFill" /> rectangles.</description>
              </item>
              <item>
                <description>SB_GRAD_TRI</description>
                <description>Capable of doing <see cref="GradientFill" /> triangles.</description>
              </item>
              <item>
                <description>SB_NONE</description>
                <description>Device does not support any of these capabilities.</description>
              </item>
              <item>
                <description>SB_PIXEL_ALPHA</description>
                <description>Capable of handling per-pixel alpha in <see cref="AlphaBlend" />.</description>
              </item>
              <item>
                <description>SB_PREMULT_ALPHA</description>
                <description>Capable of handling premultiplied alpha in <see cref="AlphaBlend" />.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>RASTERCAPS</b>
          </description>
          <description>
            <para>Value that indicates the raster capabilities of the device, as shown in the following table.</para>
            <list type="table">
              <listheader>
                <description>RC_BANDING</description>
                <description>Requires banding support.</description>
              </listheader>
              <item>
                <description>RC_BITBLT</description>
                <description>Capable of transferring bitmaps.</description>
              </item>
              <item>
                <description>RC_BITMAP64</description>
                <description>Capable of supporting bitmaps larger than 64 KB.</description>
              </item>
              <item>
                <description>RC_DI_BITMAP</description>
                <description>Capable of supporting the <see cref="SetDIBits" /> and <see cref="GetDIBits" /> functions.</description>
              </item>
              <item>
                <description>RC_DIBTODEV</description>
                <description>Capable of supporting the <see cref="SetDIBitsToDevice" /> function.</description>
              </item>
              <item>
                <description>RC_FLOODFILL</description>
                <description>Capable of performing flood fills.</description>
              </item>
              <item>
                <description>RC_PALETTE</description>
                <description>Specifies a palette-based device.</description>
              </item>
              <item>
                <description>RC_SCALING</description>
                <description>Capable of scaling.</description>
              </item>
              <item>
                <description>RC_STRETCHBLT</description>
                <description>Capable of performing the <see cref="StretchBlt" /> function.</description>
              </item>
              <item>
                <description>RC_STRETCHDIB</description>
                <description>Capable of performing the <see cref="StretchDIBits" /> function.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>CURVECAPS</b>
          </description>
          <description>
            <para>Value that indicates the curve capabilities of the device, as shown in the following table.</para>
            <list type="table">
              <listheader>
                <description>CC_NONE</description>
                <description>Device does not support curves.</description>
              </listheader>
              <item>
                <description>CC_CHORD</description>
                <description>Device can draw chord arcs.</description>
              </item>
              <item>
                <description>CC_CIRCLES</description>
                <description>Device can draw circles.</description>
              </item>
              <item>
                <description>CC_ELLIPSES</description>
                <description>Device can draw ellipses.</description>
              </item>
              <item>
                <description>CC_INTERIORS</description>
                <description>Device can draw interiors.</description>
              </item>
              <item>
                <description>CC_PIE</description>
                <description>Device can draw pie wedges.</description>
              </item>
              <item>
                <description>CC_ROUNDRECT</description>
                <description>Device can draw rounded rectangles.</description>
              </item>
              <item>
                <description>CC_STYLED</description>
                <description>Device can draw styled borders.</description>
              </item>
              <item>
                <description>CC_WIDE</description>
                <description>Device can draw wide borders.</description>
              </item>
              <item>
                <description>CC_WIDESTYLED</description>
                <description>Device can draw borders that are wide and styled.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>LINECAPS</b>
          </description>
          <description>
            <para>Value that indicates the line capabilities of the device, as shown in the following table:</para>
            <list type="table">
              <listheader>
                <description>LC_NONE</description>
                <description>Device does not support lines.</description>
              </listheader>
              <item>
                <description>LC_INTERIORS</description>
                <description>Device can draw interiors.</description>
              </item>
              <item>
                <description>LC_MARKER</description>
                <description>Device can draw a marker.</description>
              </item>
              <item>
                <description>LC_POLYLINE</description>
                <description>Device can draw a polyline.</description>
              </item>
              <item>
                <description>LC_POLYMARKER</description>
                <description>Device can draw multiple markers.</description>
              </item>
              <item>
                <description>LC_STYLED</description>
                <description>Device can draw styled lines.</description>
              </item>
              <item>
                <description>LC_WIDE</description>
                <description>Device can draw wide lines.</description>
              </item>
              <item>
                <description>LC_WIDESTYLED</description>
                <description>Device can draw lines that are wide and styled.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>POLYGONALCAPS</b>
          </description>
          <description>
            <para>Value that indicates the polygon capabilities of the device, as shown in the following table.</para>
            <list type="table">
              <listheader>
                <description>PC_NONE</description>
                <description>Device does not support polygons.</description>
              </listheader>
              <item>
                <description>PC_INTERIORS</description>
                <description>Device can draw interiors.</description>
              </item>
              <item>
                <description>PC_POLYGON</description>
                <description>Device can draw alternate-fill polygons.</description>
              </item>
              <item>
                <description>PC_RECTANGLE</description>
                <description>Device can draw rectangles.</description>
              </item>
              <item>
                <description>PC_SCANLINE</description>
                <description>Device can draw a single scanline.</description>
              </item>
              <item>
                <description>PC_STYLED</description>
                <description>Device can draw styled borders.</description>
              </item>
              <item>
                <description>PC_WIDE</description>
                <description>Device can draw wide borders.</description>
              </item>
              <item>
                <description>PC_WIDESTYLED</description>
                <description>Device can draw borders that are wide and styled.</description>
              </item>
              <item>
                <description>PC_WINDPOLYGON</description>
                <description>Device can draw winding-fill polygons.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>TEXTCAPS</b>
          </description>
          <description>
            <para>Value that indicates the text capabilities of the device, as shown in the following table.</para>
            <list type="table">
              <listheader>
                <description>TC_OP_CHARACTER</description>
                <description>Device is capable of character output precision.</description>
              </listheader>
              <item>
                <description>TC_OP_STROKE</description>
                <description>Device is capable of stroke output precision.</description>
              </item>
              <item>
                <description>TC_CP_STROKE</description>
                <description>Device is capable of stroke clip precision.</description>
              </item>
              <item>
                <description>TC_CR_90</description>
                <description>Device is capable of 90-degree character rotation.</description>
              </item>
              <item>
                <description>TC_CR_ANY</description>
                <description>Device is capable of any character rotation.</description>
              </item>
              <item>
                <description>TC_SF_X_YINDEP</description>
                <description>Device can scale independently in the x- and y-directions.</description>
              </item>
              <item>
                <description>TC_SA_DOUBLE</description>
                <description>Device is capable of doubled character for scaling.</description>
              </item>
              <item>
                <description>TC_SA_INTEGER</description>
                <description>Device uses integer multiples only for character scaling.</description>
              </item>
              <item>
                <description>TC_SA_CONTIN</description>
                <description>Device uses any multiples for exact character scaling.</description>
              </item>
              <item>
                <description>TC_EA_DOUBLE</description>
                <description>Device can draw double-weight characters.</description>
              </item>
              <item>
                <description>TC_IA_ABLE</description>
                <description>Device can italicize.</description>
              </item>
              <item>
                <description>TC_UA_ABLE</description>
                <description>Device can underline.</description>
              </item>
              <item>
                <description>TC_SO_ABLE</description>
                <description>Device can draw strikeouts.</description>
              </item>
              <item>
                <description>TC_RA_ABLE</description>
                <description>Device can draw raster fonts.</description>
              </item>
              <item>
                <description>TC_VA_ABLE</description>
                <description>Device can draw vector fonts.</description>
              </item>
              <item>
                <description>TC_RESERVED</description>
                <description>Reserved; must be zero.</description>
              </item>
              <item>
                <description>TC_SCROLLBLT</description>
                <description>Device cannot scroll using a bit-block transfer. Note that this meaning may be the opposite of what you expect.</description>
              </item>
            </list>
          </description>
        </item>
        <item>
          <description>
            <b>COLORMGMTCAPS</b>
          </description>
          <description>
            <para>Value that indicates the color management capabilities of the device.</para>
            <list type="table">
              <listheader>
                <description>CM_CMYK_COLOR</description>
                <description>Device can accept CMYK color space ICC color profile.</description>
              </listheader>
              <item>
                <description>CM_DEVICE_ICM</description>
                <description>Device can perform ICM on either the device driver or the device itself.</description>
              </item>
              <item>
                <description>CM_GAMMA_RAMP</description>
                <description>Device supports <see cref="GetDeviceGammaRamp" /> and <see cref="SetDeviceGammaRamp" /></description>
              </item>
              <item>
                <description>CM_NONE</description>
                <description>Device does not support ICM.</description>
              </item>
            </list>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The return value specifies the value of the desired item.</para>
      <para>When <i>nIndex</i> is BITSPIXEL and the device has 15bpp or 16bpp, the return value is 16.</para>
    </returns>
    <remarks>
      <para>When <i>nIndex</i> is SHADEBLENDCAPS:</para>
      <list type="bullet">
        <item>
          <description>For a printer, <b>GetDeviceCaps</b> returns whatever the printer reports.</description>
        </item>
        <item>
          <description>For a display device, all blending operations are available; besides SB_NONE, the only return values are SB_CONST_ALPHA and SB_PIXEL_ALPHA, which indicate whether these operations are accelerated.</description>
        </item>
      </list>
      <para>On a multiple monitor system, if <i>hdc</i> is the desktop, <b>GetDeviceCaps</b> returns the capabilities of the primary monitor. If you want info for other monitors, you must use the <a href="https://docs.microsoft.com//windows/desktop/gdi/multiple-display-monitors-reference">multi-monitor APIs</a> or <see cref="CreateDC" /> to get a HDC for the device context (DC) of a specific monitor.</para>
      <para>
        <b>Note</b>  Display1 is typically the primary monitor, but not always.</para>
      <para>
        <b>GetDeviceCaps</b> provides the following six indexes in place of printer escapes.</para>
      <list type="table">
        <listheader>
          <description>Index</description>
          <description>Printer escape replaced</description>
        </listheader>
        <item>
          <description>PHYSICALWIDTH</description>
          <description>GETPHYSPAGESIZE</description>
        </item>
        <item>
          <description>PHYSICALHEIGHT</description>
          <description>GETPHYSPAGESIZE</description>
        </item>
        <item>
          <description>PHYSICALOFFSETX</description>
          <description>GETPRINTINGOFFSET</description>
        </item>
        <item>
          <description>PHYSICALOFFSETY</description>
          <description>GETPHYSICALOFFSET</description>
        </item>
        <item>
          <description>SCALINGFACTORX</description>
          <description>GETSCALINGFACTOR</description>
        </item>
        <item>
          <description>SCALINGFACTORY</description>
          <description>GETSCALINGFACTOR</description>
        </item>
      </list>
      <para>
        <b>Note</b>  <b>GetDeviceCaps</b> reports info that the display driver provides. If the display driver declines to report any info, <b>GetDeviceCaps</b> calculates the info based on fixed calculations. If the display driver reports invalid info, <b>GetDeviceCaps</b> returns the invalid info. Also, if the display driver declines to report info, <b>GetDeviceCaps</b> might calculate incorrect info because it assumes either fixed DPI (96 DPI) or a fixed size (depending on the info that the display driver did and didn’t provide). Unfortunately, a display driver that is implemented to the Windows Display Driver Model (WDDM) (introduced in Windows Vista) causes GDI to not get the info, so <b>GetDeviceCaps</b> must always calculate the info.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/preparing-to-print">Preparing to Print</a>.</para>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso cref="CreateIC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetObjectType" />
    <seealso cref="SetDIBits" />
    <seealso cref="SetDIBitsToDevice" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.GetDeviceGammaRamp">
    <summary>
      <para>The <b>GetDeviceGammaRamp</b> function gets the <a href="https://docs.microsoft.com//windows/win32/wcs/g">gamma ramp</a> on direct color display boards having drivers that support downloadable gamma ramps in hardware.</para>
      <blockquote>
        <para>[!IMPORTANT]
We strongly recommend that you don't use this API. Use of this API is subject to major limitations. See <see cref="SetDeviceGammaRamp" /> for more information.</para>
      </blockquote>
    </summary>
    <param name="hdc">
      <para>Specifies the device context of the direct color display board in question.</para>
    </param>
    <param name="lpRamp">
      <para>Points to a buffer where the function can place the current gamma ramp of the color display board. The gamma ramp is specified in three arrays of 256 <b>WORD</b> elements each, which contain the mapping between RGB values in the frame buffer and digital-analog-converter (DAC) values. The sequence of the arrays is red, green, blue.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct color video boards support loadable gamma ramps. <b>GetDeviceGammaRamp</b> succeeds only for devices with drivers that support downloadable gamma ramps in hardware.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetDIBColorTable">
    <summary>
      <para>The <b>GetDIBColorTable</b> function retrieves RGB (red, green, blue) color values from a range of entries in the color table of the DIB section bitmap that is currently selected into a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context. A DIB section bitmap must be selected into this device context.</para>
    </param>
    <param name="iStart">
      <para>A zero-based color table index that specifies the first color table entry to retrieve.</para>
    </param>
    <param name="cEntries">
      <para>The number of color table entries to retrieve.</para>
    </param>
    <param name="prgbq">
      <para>A pointer to a buffer that receives an array of <see cref="RGBQUAD" /> data structures containing color information from the DIB color table. The buffer must be large enough to contain as many <b>RGBQUAD</b> data structures as the value of <i>cEntries</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of color table entries that the function retrieves.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetDIBColorTable</b> function should be called to retrieve the color table for DIB section bitmaps that use 1, 4, or 8 bpp. The <b>biBitCount</b> member of a bitmap associated <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> structure specifies the number of bits-per-pixel. DIB section bitmaps with a <b>biBitCount</b> value greater than eight do not have a color table, but they do have associated color masks. Call the <see cref="GetObject" /> function to retrieve those color masks.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso cref="GetObject" />
    <seealso cref="RGBQUAD" />
    <seealso cref="SetDIBColorTable" />
  </member>
  <member name="Windows.GetDIBits">
    <summary>
      <para>The <b>GetDIBits</b> function retrieves the bits of the specified compatible bitmap and copies them into a buffer as a DIB using the specified format.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hbm">
      <para>A handle to the bitmap. This must be a compatible bitmap (DDB).</para>
    </param>
    <param name="start">
      <para>The first scan line to retrieve.</para>
    </param>
    <param name="cLines">
      <para>The number of scan lines to retrieve.</para>
    </param>
    <param name="lpvBits">
      <para>A pointer to a buffer to receive the bitmap data. If this parameter is <b>NULL</b>, the function passes the dimensions and format of the bitmap to the <see cref="BITMAPINFO" /> structure pointed to by the <i>lpbi</i> parameter.</para>
    </param>
    <param name="lpbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that specifies the desired format for the DIB data.</para>
    </param>
    <param name="usage">
      <para>The format of the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure. It must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>The color table should consist of an array of 16-bit indexes into the current logical palette.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>The color table should consist of literal red, green, blue (RGB) values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the <i>lpvBits</i> parameter is non-<b>NULL</b> and the function succeeds, the return value is the number of scan lines copied from the bitmap.</para>
      <para>If the <i>lpvBits</i> parameter is <b>NULL</b> and <b>GetDIBits</b> successfully fills the <see cref="BITMAPINFO" /> structure, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
      <para>This function can return the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the requested format for the DIB matches its internal format, the RGB values for the bitmap are copied. If the requested format doesn't match the internal format, a color table is synthesized. The following table describes the color table synthesized for each format.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>1_BPP</description>
          <description>The color table consists of a black and a white entry.</description>
        </item>
        <item>
          <description>4_BPP</description>
          <description>The color table consists of a mix of colors identical to the standard VGA palette.</description>
        </item>
        <item>
          <description>8_BPP</description>
          <description>The color table consists of a general mix of 256 colors defined by GDI. (Included in these 256 colors are the 20 colors found in the default logical palette.)</description>
        </item>
        <item>
          <description>24_BPP</description>
          <description>No color table is returned.</description>
        </item>
      </list>
      <para>If the <i>lpvBits</i> parameter is a valid pointer, the first six members of the <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> structure must be initialized to specify the size and format of the DIB. The scan lines must be aligned on a <b>DWORD</b> except for RLE compressed bitmaps.</para>
      <para>A bottom-up DIB is specified by setting the height to a positive number, while a top-down DIB is specified by setting the height to a negative number. The bitmap color table will be appended to the <see cref="BITMAPINFO" /> structure.</para>
      <para>If <i>lpvBits</i> is <b>NULL</b>, <b>GetDIBits</b> examines the first member of the first structure pointed to by <i>lpbi</i>. This member must specify the size, in bytes, of a <see cref="BITMAPCOREHEADER" /> or a <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> structure. The function uses the specified size to determine how the remaining members should be initialized.</para>
      <para>If <i>lpvBits</i> is <b>NULL</b> and the bit count member of <see cref="BITMAPINFO" /> is initialized to zero, <b>GetDIBits</b> fills in a <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> structure or <see cref="BITMAPCOREHEADER" /> without the color table. This technique can be used to query bitmap attributes.</para>
      <para>The bitmap identified by the <i>hbmp</i> parameter must not be selected into a device context when the application calls this function.</para>
      <para>The origin for a bottom-up DIB is the lower-left corner of the bitmap; the origin for a top-down DIB is the upper-left corner.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/capturing-an-image">Capturing an Image</a>.</para>
    </remarks>
    <seealso cref="BITMAPCOREHEADER" />
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="SetDIBits" />
  </member>
  <member name="Windows.GetEnhMetaFile">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileA">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileW">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileBits">
    <summary>
      <para>The <b>GetEnhMetaFileBits</b> function retrieves the contents of the specified enhanced-format metafile and copies them into a buffer.</para>
    </summary>
    <param name="hEMF">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="nSize">
      <para>The size, in bytes, of the buffer to receive the data.</para>
    </param>
    <param name="lpData">
      <para>A pointer to a buffer that receives the metafile data. The buffer must be sufficiently large to contain the data. If <i>lpbBuffer</i> is <b>NULL</b>, the function returns the size necessary to hold the data.</para>
    </param>
    <returns>
      <para>If the function succeeds and the buffer pointer is <b>NULL</b>, the return value is the size of the enhanced metafile, in bytes.</para>
      <para>If the function succeeds and the buffer pointer is a valid pointer, the return value is the number of bytes copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>After the enhanced-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the <see cref="SetEnhMetaFileBits" /> function.</para>
      <para>The <b>GetEnhMetaFileBits</b> function does not invalidate the enhanced-metafile handle. The application must call the <see cref="DeleteEnhMetaFile" /> function to delete the handle when it is no longer needed.</para>
      <para>The metafile contents retrieved by this function are in the enhanced format. To retrieve the metafile contents in the Windows format, use the <see cref="GetWinMetaFileBits" /> function.</para>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetEnhMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileDescription">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileDescriptionA">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileDescriptionW">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileDescription">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileDescriptionA">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileDescriptionW">
    <summary>
      <para>The <b>GetEnhMetaFileDescription</b> function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cchBuffer">
      <para>The size, in characters, of the buffer to receive the data. Only this many characters will be copied.</para>
    </param>
    <param name="lpDescription">
      <para>A pointer to a buffer that receives the optional text description.</para>
    </param>
    <returns>
      <para>If the optional text description exists and the buffer pointer is <b>NULL</b>, the return value is the length of the text string, in characters.</para>
      <para>If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer.</para>
      <para>If the optional text description does not exist, the return value is zero.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null characters, for example, "XYZ Graphics Editor\0Bald Eagle\0\0" where \0 represents the null character.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFileDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
  </member>
  <member name="Windows.GetEnhMetaFileHeader">
    <summary>
      <para>The <b>GetEnhMetaFileHeader</b> function retrieves the record containing the header for the specified enhanced-format metafile.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile for which the header is to be retrieved.</para>
    </param>
    <param name="nSize">
      <para>The size, in bytes, of the buffer to receive the data. Only this many bytes will be copied.</para>
    </param>
    <param name="lpEnhMetaHeader">
      <para>A pointer to an <see cref="ENHMETAHEADER" /> structure that receives the header record. If this parameter is <b>NULL</b>, the function returns the size of the header record.</para>
    </param>
    <returns>
      <para>If the function succeeds and the structure pointer is <b>NULL</b>, the return value is the size of the record that contains the header; if the structure pointer is a valid pointer, the return value is the number of bytes copied. Otherwise, it is zero.</para>
    </returns>
    <remarks>
      <para>An enhanced-metafile header contains such information as the metafile's size, in bytes; the dimensions of the picture stored in the metafile; the number of records stored in the metafile; the offset to the optional text description; the size of the optional palette, and the resolution of the device on which the picture was created.</para>
      <para>The record that contains the enhanced-metafile header is always the first record in the metafile.</para>
    </remarks>
    <seealso cref="ENHMETAHEADER" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
  </member>
  <member name="Windows.GetEnhMetaFilePaletteEntries">
    <summary>
      <para>The <b>GetEnhMetaFilePaletteEntries</b> function retrieves optional palette entries from the specified enhanced metafile.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="nNumEntries">
      <para>The number of entries to be retrieved from the optional palette.</para>
    </param>
    <param name="lpPaletteEntries">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures that receives the palette colors. The array must contain at least as many structures as there are entries specified by the <i>cEntries</i> parameter.</para>
    </param>
    <returns>
      <para>If the array pointer is <b>NULL</b> and the enhanced metafile contains an optional palette, the return value is the number of entries in the enhanced metafile's palette; if the array pointer is a valid pointer and the enhanced metafile contains an optional palette, the return value is the number of entries copied; if the metafile does not contain an optional palette, the return value is zero. Otherwise, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>An application can store an optional palette in an enhanced metafile by calling the <see cref="CreatePalette" /> and <see cref="SetPaletteEntries" /> functions before creating the picture and storing it in the metafile. By doing this, the application can achieve consistent colors when the picture is displayed on a variety of devices.</para>
      <para>An application that displays a picture stored in an enhanced metafile can call the <b>GetEnhMetaFilePaletteEntries</b> function to determine whether the optional palette exists. If it does, the application can call the <b>GetEnhMetaFilePaletteEntries</b> function a second time to retrieve the palette entries and then create a logical palette (by using the <see cref="CreatePalette" /> function), select it into its device context (by using the <see cref="SelectPalette" /> function), and then realize it (by using the <see cref="RealizePalette" /> function). After the logical palette has been realized, calling the <see cref="PlayEnhMetaFile" /> function displays the picture using its original colors.</para>
    </remarks>
    <seealso cref="CreatePalette" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</seealso>
    <seealso cref="PlayEnhMetaFile" />
    <seealso cref="RealizePalette" />
    <seealso cref="SelectPalette" />
  </member>
  <member name="Windows.GetEnhMetaFilePixelFormat">
    <summary>
      <para>The <b>GetEnhMetaFilePixelFormat</b> function retrieves pixel format information for an enhanced metafile.</para>
    </summary>
    <param name="hemf">
      <para>Identifies the enhanced metafile.</para>
    </param>
    <param name="cbBuffer">
      <para>Specifies the size, in bytes, of the buffer into which the pixel format information is copied.</para>
    </param>
    <param name="ppfd">
      <para>Pointer to a <see cref="PIXELFORMATDESCRIPTOR" /> structure that contains the logical pixel format specification. The metafile uses this structure to record the logical pixel format specification.</para>
    </param>
    <returns>
      <para>If the function succeeds and finds a pixel format, the return value is the size of the metafile's pixel format.</para>
      <para>If no pixel format is present, the return value is zero.</para>
      <para>If an error occurs and the function fails, the return value is GDI_ERROR. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When an enhanced metafile specifies a pixel format in its <b>ENHMETAHEADER</b> structure and the pixel format fits in the buffer, the pixel format information is copied into <i>ppfd</i>. When <i>cbBuffer</i> is too small to contain the pixel format of the metafile, the pixel format is not copied to the buffer. In either case, the function returns the size of the metafile's pixel format.</para>
      <para>For information on metafile recording and other operations, see Enhanced Metafile Operations.</para>
    </remarks>
    <seealso cref="ENHMETAHEADER" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.GetEnhMetaFile">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileA">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetEnhMetaFileW">
    <summary>
      <para>The <b>GetEnhMetaFile</b> function creates a handle that identifies the enhanced-format metafile stored in the specified file.</para>
    </summary>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of an enhanced metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>A Windows-format metafile must be converted to the enhanced format before it can be processed by the <b>GetEnhMetaFile</b> function. To convert the file, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetEnhMetaFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetFontData">
    <summary>
      <para>The <b>GetFontData</b> function retrieves font metric data for a TrueType font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="dwTable">
      <para>The name of a font metric table from which the font data is to be retrieved. This parameter can identify one of the metric tables documented in the TrueType Font Files specification published by Microsoft Corporation. If this parameter is zero, the information is retrieved starting at the beginning of the file for TrueType font files or from the beginning of the data for the currently selected font for TrueType Collection files. To retrieve the data from the beginning of the file for TrueType Collection files specify 'ttcf' (0x66637474).</para>
    </param>
    <param name="dwOffset">
      <para>The offset from the beginning of the font metric table to the location where the function should begin retrieving information. If this parameter is zero, the information is retrieved starting at the beginning of the table specified by the <i>dwTable</i> parameter. If this value is greater than or equal to the size of the table, an error occurs.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to a buffer that receives the font information. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the font data.</para>
    </param>
    <param name="cjBuffer">
      <para>The length, in bytes, of the information to be retrieved. If this parameter is zero, <b>GetFontData</b> returns the size of the data specified in the <i>dwTable</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes returned.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function is intended to be used to retrieve TrueType font information directly from the font file by font-manipulation applications. For information about embedding fonts see the <a href="https://docs.microsoft.com//windows/desktop/gdi/font-embedding-reference">Font Embedding Reference</a>.</para>
      <para>An application can sometimes use the <b>GetFontData</b> function to save a TrueType font with a document. To do this, the application determines whether the font can be embedded by checking the <b>otmfsType</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure. If bit 1 of <b>otmfsType</b> is set, embedding is not permitted for the font. If bit 1 is clear, the font can be embedded. If bit 2 is set, the embedding is read-only. If embedding is permitted, the application can retrieve the entire font file, specifying zero for the <i>dwTable</i>, <i>dwOffset</i>, and <i>cbData</i> parameters.</para>
      <para>If an application attempts to use this function to retrieve information for a non-TrueType font, an error occurs.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
  </member>
  <member name="Windows.GetFontLanguageInfo">
    <summary>
      <para>The <b>GetFontLanguageInfo</b> function returns information about the currently selected font for the specified display context. Applications typically use this information and the <see cref="GetCharacterPlacement" /> function to prepare a character string for display.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a display device context.</para>
    </param>
    <returns>
      <para>The return value identifies characteristics of the currently selected font. The function returns 0 if the font is "normalized" and can be treated as a simple Latin font; it returns GCP_ERROR if an error occurs. Otherwise, the function returns a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>GCP_DBCS</description>
          <description>The character set is DBCS.</description>
        </item>
        <item>
          <description>GCP_DIACRITIC</description>
          <description>The font/language contains diacritic glyphs.</description>
        </item>
        <item>
          <description>FLI_GLYPHS</description>
          <description>The font contains extra glyphs not normally accessible using the code page. Use <see cref="GetCharacterPlacement" /> to access the glyphs. This value is for information only and is not intended to be passed to <b>GetCharacterPlacement</b>.</description>
        </item>
        <item>
          <description>GCP_GLYPHSHAPE</description>
          <description>The font/language contains multiple glyphs per code point or per code point combination (supports shaping and/or ligation), and the font contains advanced glyph tables to provide extra glyphs for the extra shapes. If this value is specified, the <b>lpGlyphs</b> array must be used with the <see cref="GetCharacterPlacement" /> function and the ETO_GLYPHINDEX value must be passed to the <see cref="ExtTextOut" /> function when the string is drawn.</description>
        </item>
        <item>
          <description>GCP_KASHIDA</description>
          <description>The font/ language permits Kashidas.</description>
        </item>
        <item>
          <description>GCP_LIGATE</description>
          <description>The font/language contains ligation glyphs which can be substituted for specific character combinations.</description>
        </item>
        <item>
          <description>GCP_USEKERNING</description>
          <description>The font contains a kerning table which can be used to provide better spacing between the characters and glyphs.</description>
        </item>
        <item>
          <description>GCP_REORDER</description>
          <description>The language requires reordering for display for example, Hebrew or Arabic.</description>
        </item>
      </list>
      <para>The return value, when masked with FLI_MASK, can be passed directly to the <see cref="GetCharacterPlacement" /> function.</para>
    </returns>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetCharacterPlacement" />
  </member>
  <member name="Windows.GetFontUnicodeRanges">
    <summary>
      <para>The <b>GetFontUnicodeRanges</b> function returns information about which Unicode characters are supported by a font. The information is returned as a <see cref="GLYPHSET" /> structure.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpgs">
      <para>A pointer to a <see cref="GLYPHSET" /> structure that receives the glyph set information. If this parameter is <b>NULL</b>, the function returns the size of the <b>GLYPHSET</b> structure required to store the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns number of bytes written to the GLYPHSET structure or, if the <i>lpgs</i> parameter is <b>NULL</b>, it returns the size of the GLYPHSET structure required to store the information.</para>
      <para>If the function fails, it returns zero. No extended error information is available.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHSET" />
  </member>
  <member name="Windows.GetGlyphIndices">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphIndicesA">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphIndicesW">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphIndices">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphIndicesA">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphIndicesW">
    <summary>
      <para>The <b>GetGlyphIndices</b> function translates a string into an array of glyph indices. The function can be used to determine whether a glyph exists in a font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpstr">
      <para>A pointer to the string to be converted.</para>
    </param>
    <param name="c">
      <para>The length of both the <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpstr</i> and the size (in WORDs) of the buffer pointed to by <i>pgi</i>.</para>
    </param>
    <param name="pgi">
      <para>This buffer must be of dimension c. On successful return, contains an array of glyph indices corresponding to the characters in the string.</para>
    </param>
    <param name="fl">
      <para>Specifies how glyphs should be handled if they are not supported. This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGI_MARK_NONEXISTING_GLYPHS</b>
          </description>
          <description>
            <para>Marks unsupported glyphs with the hexadecimal value 0xffff.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the number of bytes (for the ANSI function) or WORDs (for the Unicode function) converted.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function attempts to identify a single-glyph representation for each character in the string pointed to by <i>lpstr</i>. While this is useful for certain low-level purposes (such as manipulating font files), higher-level applications that wish to map a string to glyphs will typically wish to use the <a href="https://docs.microsoft.com//windows/desktop/Intl/uniscribe">Uniscribe</a> functions.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphIndices as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetFontUnicodeRanges" />
  </member>
  <member name="Windows.GetGlyphOutline">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGlyphOutlineA">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGlyphOutlineW">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGlyphOutline">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGlyphOutlineA">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGlyphOutlineW">
    <summary>
      <para>The <b>GetGlyphOutline</b> function retrieves the outline or bitmap for a character in the TrueType font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="uChar">
      <para>The character for which data is to be returned.</para>
    </param>
    <param name="fuFormat">
      <para>The format of the data that the function retrieves. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GGO_BEZIER</b>
          </description>
          <description>
            <para>The function retrieves the curve data as a cubic Bézier spline (not in quadratic spline format).</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves the glyph bitmap. For information about memory allocation, see the following Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GLYPH_INDEX</b>
          </description>
          <description>
            <para>Indicates that the <i>uChar</i> parameter is a TrueType Glyph Index rather than a character code. See the <see cref="ExtTextOut" /> function for additional remarks on Glyph Indexing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY2_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains five levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY4_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 17 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_GRAY8_BITMAP</b>
          </description>
          <description>
            <para>The function retrieves a glyph bitmap that contains 65 levels of gray.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_METRICS</b>
          </description>
          <description>
            <para>The function only retrieves the <see cref="GLYPHMETRICS" /> structure specified by <i>lpgm</i>. The <i>lpvBuffer</i> is ignored. This value affects the meaning of the function's return value upon failure; see the Return Values section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_NATIVE</b>
          </description>
          <description>
            <para>The function retrieves the curve data points in the rasterizer's native format and uses the font's design units.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GGO_UNHINTED</b>
          </description>
          <description>
            <para>The function only returns unhinted outlines. This flag only works in conjunction with GGO_BEZIER and GGO_NATIVE.</para>
          </description>
        </item>
      </list>
      <para>Note that, for the GGO_GRAYn_BITMAP values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus one) levels of gray.</para>
    </param>
    <param name="lpgm">
      <para>A pointer to the <see cref="GLYPHMETRICS" /> structure describing the placement of the glyph in the character cell.</para>
    </param>
    <param name="cjBuffer">
      <para>The size, in bytes, of the buffer (*<i>lpvBuffer</i>) where the function is to copy information about the outline character. If this value is zero, the function returns the required size of the buffer.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives information about the outline character. If this value is <b>NULL</b>, the function returns the required size of the buffer.</para>
    </param>
    <param name="lpmat2">
      <para>A pointer to a <see cref="MAT2" /> structure specifying a transformation matrix for the character.</para>
    </param>
    <returns>
      <para>If GGO_BITMAP, GGO_GRAY2_BITMAP, GGO_GRAY4_BITMAP, GGO_GRAY8_BITMAP, or GGO_NATIVE is specified and the function succeeds, the return value is greater than zero; otherwise, the return value is GDI_ERROR. If one of these flags is specified and the buffer size or address is zero, the return value specifies the required buffer size, in bytes.</para>
      <para>If GGO_METRICS is specified and the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The glyph outline returned by the <b>GetGlyphOutline</b> function is for a grid-fitted glyph. (A grid-fitted glyph is a glyph that has been modified so that its bitmapped image conforms as closely as possible to the original design of the glyph.) If an application needs an unmodified glyph outline, it can request the glyph outline for a character in a font whose size is equal to the font's em unit. The value for a font's em unit is stored in the <b>otmEMSquare</b> member of the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>The glyph bitmap returned by <b>GetGlyphOutline</b> when GGO_BITMAP is specified is a DWORD-aligned, row-oriented, monochrome bitmap. When GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 4. When GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 16. When GGO_GRAY8_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.</para>
      <para>The native buffer returned by <b>GetGlyphOutline</b> when GGO_NATIVE is specified is a glyph outline. A glyph outline is returned as a series of one or more contours defined by a <see cref="TTPOLYGONHEADER" /> structure followed by one or more curves. Each curve in the contour is defined by a <see cref="TTPOLYCURVE" /> structure followed by a number of <see cref="POINTFX" /> data points. <b>POINTFX</b> points are absolute positions, not relative moves. The starting point of a contour is given by the <b>pfxStart</b> member of the <b>TTPOLYGONHEADER</b> structure. The starting point of each curve is the last point of the previous curve or the starting point of the contour. The count of data points in a curve is stored in the <b>cpfx</b> member of <b>TTPOLYCURVE</b> structure. The size of each contour in the buffer, in bytes, is stored in the <b>cb</b> member of <b>TTPOLYGONHEADER</b> structure. Additional curve definitions are packed into the buffer following preceding curves and additional contours are packed into the buffer following preceding contours. The buffer contains as many contours as fit within the buffer returned by <b>GetGlyphOutline</b>.</para>
      <para>The <see cref="GLYPHMETRICS" /> structure specifies the width of the character cell and the location of a glyph within the character cell. The origin of the character cell is located at the left side of the cell at the baseline of the font. The location of the glyph origin is relative to the character cell origin. The height of a character cell, the baseline, and other metrics global to the font are given by the <see cref="OUTLINETEXTMETRIC" /> structure.</para>
      <para>An application can alter the characters retrieved in bitmap or native format by specifying a 2-by-2 transformation matrix in the <i>lpMatrix</i> parameter. For example the glyph can be modified by shear, rotation, scaling, or any combination of the three using matrix multiplication.</para>
      <para>Additional information on a glyph outlines is located in the TrueType and the OpenType technical specifications.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetGlyphOutline as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/form-info-1">FORM_INFO_1</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="MAT2" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="POINTFX" />
    <seealso cref="TTPOLYCURVE" />
    <seealso cref="TTPOLYGONHEADER" />
  </member>
  <member name="Windows.GetGraphicsMode">
    <summary>
      <para>The <b>GetGraphicsMode</b> function retrieves the current graphics mode for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current graphics mode. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>GM_COMPATIBLE</description>
          <description>The current graphics mode is the compatible graphics mode, a mode that is compatible with 16-bit Windows. In this graphics mode, an application cannot set or modify the world transformation for the specified device context. The compatible graphics mode is the default graphics mode.</description>
        </item>
        <item>
          <description>GM_ADVANCED</description>
          <description>The current graphics mode is the advanced graphics mode, a mode that allows world transformations. In this graphics mode, an application can set or modify the world transformation for the specified device context.</description>
        </item>
      </list>
      <para>Otherwise, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can set the graphics mode for a device context by calling the <see cref="SetGraphicsMode" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="SetGraphicsMode" />
  </member>
  <member name="Windows.GetGValue">
    <summary>
      <para>The <b>GetGValue</b> macro retrieves an intensity value for the green component of a red, green, blue (RGB) value.</para>
    </summary>
    <param name="rgb">
      <para>Specifies an RGB color value.</para>
    </param>
    <remarks>
      <para>The intensity value is in the range 0 through 255.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetBValue" />
    <seealso cref="GetRValue" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</seealso>
    <seealso cref="PALETTERGB" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.GetICMProfile">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetICMProfileA">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetICMProfileW">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="DeleteColorSpaceW" />
    <seealso href="https://docs.microsoft.com//windows/win32/api/wingdi/nc-wingdi-icmenumproca">ICMENUMPROCA callback function</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetICMProfile">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetICMProfileA">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetICMProfileW">
    <summary>
      <para>The <b>GetICMProfile</b> function retrieves the file name of the current output color profile for a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context from which to retrieve the color profile.</para>
    </param>
    <param name="pBufSize">
      <para>Pointer to a <b>DWORD</b> that contains the size of the buffer pointed to by <i>lpszFilename</i>. For the ANSI version of this function, the size is in bytes. For the Unicode version, the size is in WCHARs. If this function is successful, on return this parameter contains the size of the buffer actually used. However, if the buffer is not large enough, this function returns <b>FALSE</b>. In this case, the <b>GetLastError()</b> function returns ERROR_INSUFFICIENT_BUFFER and the <b>DWORD</b> pointed to by this parameter contains the size needed for the <i>lpszFilename</i> buffer.</para>
    </param>
    <param name="pszFilename">
      <para>Points to the buffer that receives the path name of the profile.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>. It also returns <b>TRUE</b> if the <i>lpszFilename</i> parameter is <b>NULL</b> and the size required for the buffer is copied into <i>lpcbName.</i></para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>GetICMProfile</b> obtains the file name of the current output profile regardless of whether or not color management is enabled for the device context.</para>
      <para>Given a device context, <b>GetICMProfile</b> will output, through the parameter <i>lpszFilename</i>, the path name of the file containing the color profile currently being used by the device context. It will also output, through the parameter <i>lpcbName</i>, the length of the string containing the path name.</para>
      <para>It is possible that the profile name returned by <b>GetICMProfile</b> will not be in the list of profiles returned by <see cref="EnumICMProfiles" />. The <b>EnumICMProfiles</b> function returns all color space profiles that are associated with a device context (DC) whose settings match that of the DC. If the <see cref="SetICMProfile" /> function is used to set the current profile, a profile may be associated with the DC that does not match its settings. For instance, the <b>SetICMProfile</b> function can be used to associate the device-independent sRGB profile with a DC. This profile will be used as the current WCS profile for that DC, and calls to <b>GetICMProfile</b> will return its file name. However, the profile will not appear in the list of profiles that is returned from <b>EnumICMProfiles</b>.</para>
      <para>If this function is called before any calls to the <b>SetICMProfile</b> function, it can be used to get the default profile for a device context.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="SetICMProfileW" />
  </member>
  <member name="Windows.GetKerningPairs">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKerningPairsA">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKerningPairsW">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKerningPairs">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKerningPairsA">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKerningPairsW">
    <summary>
      <para>The <b>GetKerningPairs</b> function retrieves the character-kerning pairs for the currently selected font for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="nPairs">
      <para>The number of pairs in the <i>lpkrnpair</i> array. If the font has more than <i>nNumPairs</i> kerning pairs, the function returns an error.</para>
    </param>
    <param name="lpKernPair">
      <para>A pointer to an array of <see cref="KERNINGPAIR" /> structures that receives the kerning pairs. The array must contain at least as many structures as specified by the <i>nNumPairs</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of kerning pairs for the font.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of kerning pairs returned.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetKerningPairs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="KERNINGPAIR" />
  </member>
  <member name="Windows.GetKValue">
    <summary>
      <para>The <b>GetKValue</b> macro retrieves the black color value from a CMYK color value.</para>
    </summary>
    <param name="cmyk">
      <para>CMYK color value from which the black color value will be retrieved.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="CMYK" />
    <seealso cref="GetCValue" />
    <seealso cref="GetMValue" />
    <seealso cref="GetYValue" />
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/macros-for-cmyk-values-and-colors">Macros for CMYK values and colors</seealso>
  </member>
  <member name="Windows.GetLayout">
    <summary>
      <para>The <b>GetLayout</b> function returns the layout of a device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns the layout flags for the current device context.</para>
      <para>If the function fails, it returns GDI_ERROR. For extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The layout specifies the order in which text and graphics are revealed in a window or device context. The default is left to right. The <b>GetLayout</b> function tells you if the default has been changed through a call to <see cref="SetLayout" />. For more information, see "Window Layout and Mirroring" in <a href="https://docs.microsoft.com//windows/desktop/winmsg/window-features">Window Features</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SetLayout" />
  </member>
  <member name="Windows.GetLogColorSpace">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetLogColorSpaceA">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetLogColorSpaceW">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetLogColorSpace">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetLogColorSpaceA">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetLogColorSpaceW">
    <summary>
      <para>The <b>GetLogColorSpace</b> function retrieves the <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> definition identified by a specified handle.</para>
    </summary>
    <param name="hColorSpace">
      <para>Specifies the handle to a color space.</para>
    </param>
    <param name="lpBuffer">
      <para>Points to a buffer to receive the <see cref="LOGCOLORSPACE" /> structure.</para>
    </param>
    <param name="nSize">
      <para>Specifies the maximum size of the buffer.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is TRUE.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>GetLogColorSpaceW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetLogColorSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.GetMapMode">
    <summary>
      <para>The <b>GetMapMode</b> function retrieves the current mapping mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the mapping mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The following are the various mapping modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>MM_ANISOTROPIC</description>
          <description>Logical units are mapped to arbitrary units with arbitrarily scaled axes. Use the <see cref="SetWindowExtEx" /> and <see cref="SetViewportExtEx" /> functions to specify the units, orientation, and scaling required.</description>
        </item>
        <item>
          <description>MM_HIENGLISH</description>
          <description>Each logical unit is mapped to 0.001 inch. Positive x is to the right; positive y is up.</description>
        </item>
        <item>
          <description>MM_HIMETRIC</description>
          <description>Each logical unit is mapped to 0.01 millimeter. Positive x is to the right; positive y is up.</description>
        </item>
        <item>
          <description>MM_ISOTROPIC</description>
          <description>Logical units are mapped to arbitrary units with equally scaled axes; that is, one unit along the x-axis is equal to one unit along the y-axis. Use the <see cref="SetWindowExtEx" /> and <see cref="SetViewportExtEx" /> functions to specify the units and the orientation of the axes. Graphics device interface makes adjustments as necessary to ensure the x and y units remain the same size. (When the windows extent is set, the viewport will be adjusted to keep the units isotropic).</description>
        </item>
        <item>
          <description>MM_LOENGLISH</description>
          <description>Each logical unit is mapped to 0.01 inch. Positive x is to the right; positive y is up.</description>
        </item>
        <item>
          <description>MM_LOMETRIC</description>
          <description>Each logical unit is mapped to 0.1 millimeter. Positive x is to the right; positive y is up.</description>
        </item>
        <item>
          <description>MM_TEXT</description>
          <description>Each logical unit is mapped to one device pixel. Positive x is to the right; positive y is down.</description>
        </item>
        <item>
          <description>MM_TWIPS</description>
          <description>Each logical unit is mapped to one twentieth of a printer's point (1/1440 inch, also called a "twip"). Positive x is to the right; positive y is up.</description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="SetMapMode" />
    <seealso cref="SetViewportExtEx" />
    <seealso cref="SetWindowExtEx" />
  </member>
  <member name="Windows.GetMetaFileBitsEx">
    <summary>
      <para>The <b>GetMetaFileBitsEx</b> function retrieves the contents of a Windows-format metafile and copies them into the specified buffer.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="GetEnhMetaFileBits" />.</para>
    </summary>
    <param name="hMF">
      <para>A handle to a Windows-format metafile.</para>
    </param>
    <param name="cbBuffer">
      <para>The size, in bytes, of the buffer to receive the data.</para>
    </param>
    <param name="lpData">
      <para>A pointer to a buffer that receives the metafile data. The buffer must be sufficiently large to contain the data. If <i>lpvData</i> is <b>NULL</b>, the function returns the number of bytes required to hold the data.</para>
    </param>
    <returns>
      <para>If the function succeeds and the buffer pointer is <b>NULL</b>, the return value is the number of bytes required for the buffer; if the function succeeds and the buffer pointer is a valid pointer, the return value is the number of bytes copied.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>After the Windows-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the <see cref="SetMetaFileBitsEx" /> function.</para>
      <para>The <b>GetMetaFileBitsEx</b> function does not invalidate the metafile handle. An application must delete this handle by calling the <see cref="DeleteMetaFile" /> function.</para>
      <para>To convert a Windows-format metafile into an enhanced-format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetEnhMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetMetaFileBitsEx" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetMetaRgn">
    <summary>
      <para>The <b>GetMetaRgn</b> function retrieves the current metaregion for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>A handle to an existing region before the function is called. After the function returns, this parameter is a handle to a copy of the current metaregion.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the function succeeds, <i>hrgn</i> is a handle to a copy of the current metaregion. Subsequent changes to this copy will not affect the current metaregion.</para>
      <para>The current clipping region of a device context is defined by the intersection of its clipping region and its metaregion.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="SetMetaRgn" />
  </member>
  <member name="Windows.GetMiterLimit">
    <summary>
      <para>The <b>GetMiterLimit</b> function retrieves the miter limit for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="plimit">
      <para>Pointer to a floating-point value that receives the current miter limit.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The miter limit is used when drawing geometric lines that have miter joins.</para>
    </remarks>
    <seealso cref="ExtCreatePen" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="SetMiterLimit" />
  </member>
  <member name="Windows.GetMValue">
    <summary>
      <para>The <b>GetMValue</b> macro retrieves the magenta color value from a CMYK color value.</para>
    </summary>
    <param name="cmyk">
      <para>CMYK color value from which the magenta color value will be retrieved.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="CMYK" />
    <seealso cref="GetCValue" />
    <seealso cref="GetKValue" />
    <seealso cref="GetYValue" />
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/macros-for-cmyk-values-and-colors">Macros for CMYK values and colors</seealso>
  </member>
  <member name="Windows.GetNearestColor">
    <summary>
      <para>The <b>GetNearestColor</b> function retrieves a color value identifying a color from the system palette that will be displayed when the specified color value is used.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="color">
      <para>A color value that identifies a requested color. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a color from the system palette that corresponds to the given color value.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd144903(v=vs.85)">GetNearestPaletteIndex</seealso>
    <seealso cref="RGB" />
  </member>
  <member name="Windows.GetNearestPaletteIndex">
    <summary>
      <para>The <b>GetNearestPaletteIndex</b> function retrieves the index for the entry in the specified logical palette most closely matching a specified color value.</para>
    </summary>
    <param name="h">
      <para>A handle to a logical palette.</para>
    </param>
    <param name="color">
      <para>A color to be matched. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the index of an entry in a logical palette.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>If the given logical palette contains entries with the PC_EXPLICIT flag set, the return value is undefined.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetNearestColor" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetSystemPaletteEntries" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.GetObject">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectA">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectW">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObject">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectA">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectW">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectType">
    <summary>
      <para>The <b>GetObjectType</b> retrieves the type of the specified object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies the object. This value can be one of the following.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>OBJ_BITMAP</description>
          <description>Bitmap</description>
        </item>
        <item>
          <description>OBJ_BRUSH</description>
          <description>Brush</description>
        </item>
        <item>
          <description>OBJ_COLORSPACE</description>
          <description>Color space</description>
        </item>
        <item>
          <description>OBJ_DC</description>
          <description>Device context</description>
        </item>
        <item>
          <description>OBJ_ENHMETADC</description>
          <description>Enhanced metafile DC</description>
        </item>
        <item>
          <description>OBJ_ENHMETAFILE</description>
          <description>Enhanced metafile</description>
        </item>
        <item>
          <description>OBJ_EXTPEN</description>
          <description>Extended pen</description>
        </item>
        <item>
          <description>OBJ_FONT</description>
          <description>Font</description>
        </item>
        <item>
          <description>OBJ_MEMDC</description>
          <description>Memory DC</description>
        </item>
        <item>
          <description>OBJ_METAFILE</description>
          <description>Metafile</description>
        </item>
        <item>
          <description>OBJ_METADC</description>
          <description>Metafile DC</description>
        </item>
        <item>
          <description>OBJ_PAL</description>
          <description>Palette</description>
        </item>
        <item>
          <description>OBJ_PEN</description>
          <description>Pen</description>
        </item>
        <item>
          <description>OBJ_REGION</description>
          <description>Region</description>
        </item>
      </list>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetObject" />
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.GetObject">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectA">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetObjectW">
    <summary>
      <para>The <b>GetObject</b> function retrieves information for the specified graphics object.</para>
    </summary>
    <param name="h">
      <para>A handle to the graphics object of interest. This can be a handle to one of the following: a logical bitmap, a brush, a font, a palette, a pen, or a device independent bitmap created by calling the <see cref="CreateDIBSection" /> function.</para>
    </param>
    <param name="c">
      <para>The number of bytes of information to be written to the buffer.</para>
    </param>
    <param name="pv">
      <para>A pointer to a buffer that receives the information about the specified graphics object.</para>
      <para>The following table shows the type of information the buffer receives for each type of graphics object you can specify with <i>hgdiobj</i>.</para>
      <list type="table">
        <listheader>
          <description>Object type</description>
          <description>Data written to buffer</description>
        </listheader>
        <item>
          <description>
            <b>
              <b>HBITMAP</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="BITMAP" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBITMAP</b> returned from a call to <see cref="CreateDIBSection" /></b>
          </description>
          <description>
            <para>
              <see cref="DIBSECTION" />, if <i>cbBuffer</i> is set to<code> sizeof (DIBSECTION)</code>, or <see cref="BITMAP" />, if <i>cbBuffer</i> is set to <code>sizeof (BITMAP)</code>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPALETTE</b>
            </b>
          </description>
          <description>
            <para>A <b>WORD</b> count of the number of entries in the logical palette</para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b> returned from a call to <see cref="ExtCreatePen" /></b>
          </description>
          <description>
            <para>
              <see cref="EXTLOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HPEN</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGPEN" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HBRUSH</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGBRUSH" />
            </para>
          </description>
        </item>
        <item>
          <description>
            <b>
              <b>HFONT</b>
            </b>
          </description>
          <description>
            <para>
              <see cref="LOGFONT" />
            </para>
          </description>
        </item>
      </list>
      <para>If the <i>lpvObject</i> parameter is <b>NULL</b>, the function return value is the number of bytes required to store the information it writes to the buffer for the specified graphics object.</para>
      <para>The address of <i>lpvObject</i> must be on a 4-byte boundary; otherwise, <b>GetObject</b> fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, and <i>lpvObject</i> is a valid pointer, the return value is the number of bytes stored into the buffer.</para>
      <para>If the function succeeds, and <i>lpvObject</i> is <b>NULL</b>, the return value is the number of bytes required to hold the information the function would store into the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by the <i>lpvObject</i> parameter must be sufficiently large to receive the information about the graphics object. Depending on the graphics object, the function uses a <see cref="BITMAP" />, <see cref="DIBSECTION" />, <see cref="EXTLOGPEN" />, <see cref="LOGBRUSH" />, <see cref="LOGFONT" />, or <see cref="LOGPEN" /> structure, or a count of table entries (for a logical palette).</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by calling <see cref="CreateDIBSection" />, and the specified buffer is large enough, the <b>GetObject</b> function returns a <see cref="DIBSECTION" /> structure. In addition, the <b>bmBits</b> member of the <see cref="BITMAP" /> structure contained within the <b>DIBSECTION</b> will contain a pointer to the bitmap's bit values.</para>
      <para>If <i>hgdiobj</i> is a handle to a bitmap created by any other means, <b>GetObject</b> returns only the width, height, and color format information of the bitmap. You can obtain the bitmap's bit values by calling the <see cref="GetDIBits" /> or <see cref="GetBitmapBits" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a logical palette, <b>GetObject</b> retrieves a 2-byte integer that specifies the number of entries in the palette. The function does not retrieve the <see cref="LOGPALETTE" /> structure defining the palette. To retrieve information about palette entries, an application can call the <see cref="GetPaletteEntries" /> function.</para>
      <para>If <i>hgdiobj</i> is a handle to a font, the <see cref="LOGFONT" /> that is returned is the <b>LOGFONT</b> used to create the font. If Windows had to make some interpolation of the font because the precise <b>LOGFONT</b> could not be represented, the interpolation will not be reflected in the <b>LOGFONT</b>. For example, if you ask for a vertical version of a font that doesn't support vertical painting, the <b>LOGFONT</b> indicates the font is vertical, but Windows will paint it horizontally.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/storing-an-image">Storing an Image</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetObject as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BITMAP" />
    <seealso cref="CreateDIBSection" />
    <seealso cref="DIBSECTION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="EXTLOGPEN" />
    <seealso cref="GetBitmapBits" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetPaletteEntries" />
    <seealso cref="GetRegionData" />
    <seealso cref="LOGBRUSH" />
    <seealso cref="LOGFONT" />
    <seealso cref="LOGPALETTE" />
    <seealso cref="LOGPEN" />
  </member>
  <member name="Windows.GetOutlineTextMetrics">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetOutlineTextMetricsA">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetOutlineTextMetricsW">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetOutlineTextMetrics">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetOutlineTextMetricsA">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetOutlineTextMetricsW">
    <summary>
      <para>The <b>GetOutlineTextMetrics</b> function retrieves text metrics for TrueType fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="cjCopy">
      <para>The size, in bytes, of the array that receives the text metrics.</para>
    </param>
    <param name="potm">
      <para>A pointer to an <see cref="OUTLINETEXTMETRIC" /> structure. If this parameter is <b>NULL</b>, the function returns the size of the buffer required for the retrieved metric data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero or the size of the required buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <see cref="OUTLINETEXTMETRIC" /> structure contains most of the text metric information provided for TrueType fonts (including a <see cref="TEXTMETRIC" /> structure). The sizes returned in <b>OUTLINETEXTMETRIC</b> are in logical units; they depend on the current mapping mode.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetOutlineTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextMetrics" />
    <seealso cref="OUTLINETEXTMETRIC" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetPaletteEntries">
    <summary>
      <para>The <b>GetPaletteEntries</b> function retrieves a specified range of palette entries from the given logical palette.</para>
    </summary>
    <param name="hpal">
      <para>A handle to the logical palette.</para>
    </param>
    <param name="iStart">
      <para>The first entry in the logical palette to be retrieved.</para>
    </param>
    <param name="cEntries">
      <para>The number of entries in the logical palette to be retrieved.</para>
    </param>
    <param name="pPalEntries">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures to receive the palette entries. The array must contain at least as many structures as specified by the <i>nEntries</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds and the handle to the logical palette is a valid pointer (not <b>NULL</b>), the return value is the number of entries retrieved from the logical palette. If the function succeeds and handle to the logical palette is <b>NULL</b>, the return value is the number of entries in the given palette.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>If the <i>nEntries</i> parameter specifies more entries than exist in the palette, the remaining members of the <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structure are not altered.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetSystemPaletteEntries" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</seealso>
    <seealso cref="SetPaletteEntries" />
  </member>
  <member name="Windows.GetPath">
    <summary>
      <para>The <b>GetPath</b> function retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context that contains a closed path.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that receives the line endpoints and curve control points, in logical coordinates.</para>
    </param>
    <param name="aj">
      <para>A pointer to an array of bytes that receives the vertex types. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Type</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>PT_MOVETO</b>
          </description>
          <description>
            <para>Specifies that the corresponding point in the <i>lpPoints</i> parameter starts a disjoint figure.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PT_LINETO</b>
          </description>
          <description>
            <para>Specifies that the previous point and the corresponding point in <i>lpPoints</i> are the endpoints of a line.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PT_BEZIERTO</b>
          </description>
          <description>
            <para>Specifies that the corresponding point in <i>lpPoints</i> is a control point or ending point for a Bézier curve.</para>
            <para>PT_BEZIERTO values always occur in sets of three. The point in the path immediately preceding them defines the starting point for the Bézier curve. The first two PT_BEZIERTO points are the control points, and the third PT_BEZIERTO point is the ending (if hard-coded) point.</para>
          </description>
        </item>
      </list>
      <para>A PT_LINETO or PT_BEZIERTO value may be combined with the following value (by using the bitwise operator OR) to indicate that the corresponding point is the last point in a figure and the figure should be closed.</para>
      <list type="table">
        <listheader>
          <description>Flag</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>PT_CLOSEFIGURE</b>
          </description>
          <description>
            <para>Specifies that the figure is automatically closed after the corresponding line or curve is drawn. The figure is closed by drawing a line from the line or curve endpoint to the point corresponding to the last PT_MOVETO.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="cpt">
      <para>The total number of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that can be stored in the array pointed to by <i>lpPoints</i>. This value must be the same as the number of bytes that can be placed in the array pointed to by <i>lpTypes</i>.</para>
    </param>
    <returns>
      <para>If the <i>nSize</i> parameter is nonzero, the return value is the number of points enumerated. If <i>nSize</i> is 0, the return value is the total number of points in the path (and <b>GetPath</b> writes nothing to the buffers). If <i>nSize</i> is nonzero and is less than the number of points in the path, the return value is 1.</para>
    </returns>
    <remarks>
      <para>The device context identified by the <i>hdc</i> parameter must contain a closed path.</para>
      <para>The points of the path are returned in logical coordinates. Points are stored in the path in device coordinates, so <b>GetPath</b> changes the points from device coordinates to logical coordinates by using the inverse of the current transformation.</para>
      <para>The <see cref="FlattenPath" /> function may be called before <b>GetPath</b> to convert all curves in the path into line segments.</para>
    </remarks>
    <seealso cref="FlattenPath" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="PolyDraw" />
    <seealso cref="WidenPath" />
  </member>
  <member name="Windows.GetPixel">
    <summary>
      <para>The <b>GetPixel</b> function retrieves the red, green, blue (RGB) color value of the pixel at the specified coordinates.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the <a href="https://docs.microsoft.com//windows/win32/gdi/device-contexts">device context</a>.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the pixel to be examined.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the pixel to be examined.</para>
    </param>
    <returns>
      <para>The return value is the <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value that specifies the RGB of the pixel. If the pixel is outside of the current clipping region, the return value is CLR_INVALID (0xFFFFFFFF defined in Wingdi.h).</para>
    </returns>
    <remarks>
      <para>The pixel must be within the boundaries of the current clipping region.</para>
      <para>Not all devices support <b>GetPixel</b>. An application should call <see cref="GetDeviceCaps" /> to determine whether a specified device supports this function.</para>
      <para>A bitmap must be selected within the device context, otherwise, CLR_INVALID is returned on all pixels.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="SetPixel" />
  </member>
  <member name="Windows.GetPixelFormat">
    <summary>
      <para>The <b>GetPixelFormat</b> function obtains the index of the currently selected pixel format of the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context of the currently selected pixel format index returned by the function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the currently selected pixel format index of the specified device context. This is a positive, one-based index value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="ChoosePixelFormat" />
    <seealso cref="DescribePixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="SetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.GetPolyFillMode">
    <summary>
      <para>The <b>GetPolyFillMode</b> function retrieves the current polygon fill mode.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the polygon fill mode, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>ALTERNATE</description>
          <description>Selects alternate mode (fills area between odd-numbered and even-numbered polygon sides on each scan line).</description>
        </item>
        <item>
          <description>WINDING</description>
          <description>Selects winding mode (fills any region with a nonzero winding value).</description>
        </item>
      </list>
      <para>If an error occurs, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
    <seealso cref="SetPolyFillMode" />
  </member>
  <member name="Windows.GetRandomRgn">
    <summary>
      <para>The <b>GetRandomRgn</b> function copies the system clipping region of a specified device context to a specific region.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>A handle to a region. Before the function is called, this identifies an existing region. After the function returns, this identifies a copy of the current system region. The old region identified by <i>hrgn</i> is overwritten.</para>
    </param>
    <param name="i">
      <para>This parameter must be SYSRGN.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is 1. If the function fails, the return value is -1. If the region to be retrieved is <b>NULL</b>, the return value is 0. If the function fails or the region to be retrieved is <b>NULL</b>, <i>hrgn</i> is not initialized.</para>
    </returns>
    <remarks>
      <para>When using the SYSRGN flag, note that the system clipping region might not be current because of window movements. Nonetheless, it is safe to retrieve and use the system clipping region within the <see cref="BeginPaint" />-<see cref="EndPaint" /> block during <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-paint">WM_PAINT</a> processing. In this case, the system region is the intersection of the update region and the current visible area of the window. Any window movement following the return of <b>GetRandomRgn</b> and before <b>EndPaint</b> will result in a new <b>WM_PAINT</b> message. Any other use of the SYSRGN flag may result in painting errors in your application.</para>
      <para>The region returned is in screen coordinates.</para>
    </remarks>
    <seealso cref="BeginPaint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="EndPaint" />
    <seealso cref="ExtSelectClipRgn" />
    <seealso cref="GetClipBox" />
    <seealso cref="GetClipRgn" />
    <seealso cref="GetRegionData" />
    <seealso cref="OffsetRgn" />
  </member>
  <member name="Windows.GetRasterizerCaps">
    <summary>
      <para>The <b>GetRasterizerCaps</b> function returns flags indicating whether TrueType fonts are installed in the system.</para>
    </summary>
    <param name="lpraststat">
      <para>A pointer to a <see cref="RASTERIZER_STATUS" /> structure that receives information about the rasterizer.</para>
    </param>
    <param name="cjBytes">
      <para>The number of bytes to be copied into the structure pointed to by the <i>lprs</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetRasterizerCaps</b> function enables applications and printer drivers to determine whether TrueType fonts are installed.</para>
      <para>If the TT_AVAILABLE flag is set in the <b>wFlags</b> member of the <see cref="RASTERIZER_STATUS" /> structure, at least one TrueType font is installed. If the TT_ENABLED flag is set, TrueType is enabled for the system.</para>
      <para>The actual number of bytes copied is either the member specified in the <i>cb</i> parameter or the length of the <see cref="RASTERIZER_STATUS" /> structure, whichever is less.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetOutlineTextMetrics" />
    <seealso cref="RASTERIZER_STATUS" />
  </member>
  <member name="Windows.GetRegionData">
    <summary>
      <para>The <b>GetRegionData</b> function fills the specified buffer with data describing a region. This data includes the dimensions of the rectangles that make up the region.</para>
    </summary>
    <param name="hrgn">
      <para>A handle to the region.</para>
    </param>
    <param name="nCount">
      <para>The size, in bytes, of the <i>lpRgnData</i> buffer.</para>
    </param>
    <param name="lpRgnData">
      <para>A pointer to a <see cref="RGNDATA" /> structure that receives the information. The dimensions of the region are in logical units. If this parameter is <b>NULL</b>, the return value contains the number of bytes needed for the region data.</para>
    </param>
    <returns>
      <para>If the function succeeds and <i>dwCount</i> specifies an adequate number of bytes, the return value is always <i>dwCount</i>. If <i>dwCount</i> is too small or the function fails, the return value is 0. If <i>lpRgnData</i> is <b>NULL</b>, the return value is the required number of bytes.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetRegionData</b> function is used in conjunction with the <see cref="ExtCreateRegion" /> function.</para>
    </remarks>
    <seealso cref="CreatePolyPolygonRgn" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateRoundRectRgn" />
    <seealso cref="ExtCreateRegion" />
    <seealso cref="RGNDATA" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.GetRgnBox">
    <summary>
      <para>The <b>GetRgnBox</b> function retrieves the bounding rectangle of the specified region.</para>
    </summary>
    <param name="hrgn">
      <para>A handle to the region.</para>
    </param>
    <param name="lprc">
      <para>A pointer to a <see cref="RECT" /> structure that receives the bounding rectangle in logical units.</para>
    </param>
    <returns>
      <para>The return value specifies the region's complexity. It can be one of the following values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>NULLREGION</description>
          <description>Region is empty.</description>
        </item>
        <item>
          <description>SIMPLEREGION</description>
          <description>Region is a single rectangle.</description>
        </item>
        <item>
          <description>COMPLEXREGION</description>
          <description>Region is more than a single rectangle.</description>
        </item>
      </list>
      <para>If the <i>hrgn</i> parameter does not identify a valid region, the return value is zero.</para>
    </returns>
    <seealso cref="RECT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.GetROP2">
    <summary>
      <para>The <b>GetROP2</b> function retrieves the foreground mix mode of the specified device context. The mix mode specifies how the pen or interior color and the color already on the screen are combined to yield a new color.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the foreground mix mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Following are the foreground mix modes.</para>
      <list type="table">
        <listheader>
          <description>Mix mode</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>R2_BLACK</description>
          <description>Pixel is always 0.</description>
        </item>
        <item>
          <description>R2_COPYPEN</description>
          <description>Pixel is the pen color.</description>
        </item>
        <item>
          <description>R2_MASKNOTPEN</description>
          <description>Pixel is a combination of the colors common to both the screen and the inverse of the pen.</description>
        </item>
        <item>
          <description>R2_MASKPEN</description>
          <description>Pixel is a combination of the colors common to both the pen and the screen.</description>
        </item>
        <item>
          <description>R2_MASKPENNOT</description>
          <description>Pixel is a combination of the colors common to both the pen and the inverse of the screen.</description>
        </item>
        <item>
          <description>R2_MERGENOTPEN</description>
          <description>Pixel is a combination of the screen color and the inverse of the pen color.</description>
        </item>
        <item>
          <description>R2_MERGEPEN</description>
          <description>Pixel is a combination of the pen color and the screen color.</description>
        </item>
        <item>
          <description>R2_MERGEPENNOT</description>
          <description>Pixel is a combination of the pen color and the inverse of the screen color.</description>
        </item>
        <item>
          <description>R2_NOP</description>
          <description>Pixel remains unchanged.</description>
        </item>
        <item>
          <description>R2_NOT</description>
          <description>Pixel is the inverse of the screen color.</description>
        </item>
        <item>
          <description>R2_NOTCOPYPEN</description>
          <description>Pixel is the inverse of the pen color.</description>
        </item>
        <item>
          <description>R2_NOTMASKPEN</description>
          <description>Pixel is the inverse of the R2_MASKPEN color.</description>
        </item>
        <item>
          <description>R2_NOTMERGEPEN</description>
          <description>Pixel is the inverse of the R2_MERGEPEN color.</description>
        </item>
        <item>
          <description>R2_NOTXORPEN</description>
          <description>Pixel is the inverse of the R2_XORPEN color.</description>
        </item>
        <item>
          <description>R2_WHITE</description>
          <description>Pixel is always 1.</description>
        </item>
        <item>
          <description>R2_XORPEN</description>
          <description>Pixel is a combination of the colors in the pen and in the screen, but not in both.</description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="SetROP2" />
  </member>
  <member name="Windows.GetRValue">
    <summary>
      <para>The <b>GetRValue</b> macro retrieves an intensity value for the red component of a red, green, blue (RGB) value.</para>
    </summary>
    <param name="rgb">
      <para>Specifies an RGB color value.</para>
    </param>
    <remarks>
      <para>The intensity value is in the range 0 through 255.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetBValue" />
    <seealso cref="GetGValue" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</seealso>
    <seealso cref="PALETTERGB" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.GetStockObject">
    <summary>
      <para>The <b>GetStockObject</b> function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.</para>
    </summary>
    <param name="i">
      <para>The type of stock object. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>BLACK_BRUSH</b>
          </description>
          <description>
            <para>Black brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DKGRAY_BRUSH</b>
          </description>
          <description>
            <para>Dark gray brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_BRUSH</b>
          </description>
          <description>
            <para>Solid color brush. The default color is white. The color can be changed by using the <see cref="SetDCBrushColor" /> function. For more information, see the Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GRAY_BRUSH</b>
          </description>
          <description>
            <para>Gray brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>HOLLOW_BRUSH</b>
          </description>
          <description>
            <para>Hollow brush (equivalent to NULL_BRUSH).</para>
          </description>
        </item>
        <item>
          <description>
            <b>LTGRAY_BRUSH</b>
          </description>
          <description>
            <para>Light gray brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NULL_BRUSH</b>
          </description>
          <description>
            <para>Null brush (equivalent to HOLLOW_BRUSH).</para>
          </description>
        </item>
        <item>
          <description>
            <b>WHITE_BRUSH</b>
          </description>
          <description>
            <para>White brush.</para>
          </description>
        </item>
        <item>
          <description>
            <b>BLACK_PEN</b>
          </description>
          <description>
            <para>Black pen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DC_PEN</b>
          </description>
          <description>
            <para>Solid pen color. The default color is white. The color can be changed by using the <see cref="SetDCPenColor" /> function. For more information, see the Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NULL_PEN</b>
          </description>
          <description>
            <para>Null pen. The null pen draws nothing.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WHITE_PEN</b>
          </description>
          <description>
            <para>White pen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ANSI_FIXED_FONT</b>
          </description>
          <description>
            <para>Windows fixed-pitch (monospace) system font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ANSI_VAR_FONT</b>
          </description>
          <description>
            <para>Windows variable-pitch (proportional space) system font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEVICE_DEFAULT_FONT</b>
          </description>
          <description>
            <para>Device-dependent font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_GUI_FONT</b>
          </description>
          <description>
            <para>Default font for user interface objects such as menus and dialog boxes. It is not recommended that you use DEFAULT_GUI_FONT or SYSTEM_FONT to obtain the font used by dialogs and windows; for more information, see the remarks section.</para>
            <para>The default font is Tahoma.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OEM_FIXED_FONT</b>
          </description>
          <description>
            <para>Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SYSTEM_FONT</b>
          </description>
          <description>
            <para>System font. By default, the system uses the system font to draw menus, dialog box controls, and text. It is not recommended that you use DEFAULT_GUI_FONT or SYSTEM_FONT to obtain the font used by dialogs and windows; for more information, see the remarks section.</para>
            <para>The default system font is Tahoma.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SYSTEM_FIXED_FONT</b>
          </description>
          <description>
            <para>Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEFAULT_PALETTE</b>
          </description>
          <description>
            <para>Default palette. This palette consists of the static colors in the system palette.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the requested logical object.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>It is not recommended that you employ this method to obtain the current font used by dialogs and windows. Instead, use the <see cref="SystemParametersInfo" /> function with the SPI_GETNONCLIENTMETRICS parameter to retrieve the current font. <see cref="SystemParametersInfo" /> will take into account the current theme and provides font information for captions, menus, and message dialogs.</para>
      <para>Use the DKGRAY_BRUSH, GRAY_BRUSH, and LTGRAY_BRUSH stock objects only in windows with the CS_HREDRAW and CS_VREDRAW styles. Using a gray stock brush in any other style of window can lead to misalignment of brush patterns after a window is moved or sized. The origins of stock brushes cannot be adjusted.</para>
      <para>The HOLLOW_BRUSH and NULL_BRUSH stock objects are equivalent.</para>
      <para>It is not necessary (but it is not harmful) to delete stock objects by calling <see cref="DeleteObject" />.</para>
      <para>Both DC_BRUSH and DC_PEN can be used interchangeably with other stock objects like BLACK_BRUSH and BLACK_PEN. For information on retrieving the current pen or brush color, see <see cref="GetDCBrushColor" /> and <see cref="GetDCPenColor" />. See <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a> for an example of setting colors. The <b>GetStockObject</b> function with an argument of DC_BRUSH or DC_PEN can be used interchangeably with the <see cref="SetDCPenColor" /> and <see cref="SetDCBrushColor" /> functions.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a>.</para>
    </remarks>
    <seealso cref="DeleteObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SelectObject" />
  </member>
  <member name="Windows.GetStretchBltMode">
    <summary>
      <para>The <b>GetStretchBltMode</b> function retrieves the current stretching mode. The stretching mode defines how color data is added to or removed from bitmaps that are stretched or compressed when the <see cref="StretchBlt" /> function is called.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current stretching mode. This can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>BLACKONWHITE</description>
          <description>Performs a Boolean AND operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves black pixels at the expense of white pixels.</description>
        </item>
        <item>
          <description>COLORONCOLOR</description>
          <description>Deletes the pixels. This mode deletes all eliminated lines of pixels without trying to preserve their information.</description>
        </item>
        <item>
          <description>HALFTONE</description>
          <description>Maps pixels from the source rectangle into blocks of pixels in the destination rectangle. The average color over the destination block of pixels approximates the color of the source pixels.</description>
        </item>
        <item>
          <description>STRETCH_ANDSCANS</description>
          <description>Same as BLACKONWHITE.</description>
        </item>
        <item>
          <description>STRETCH_DELETESCANS</description>
          <description>Same as COLORONCOLOR.</description>
        </item>
        <item>
          <description>STRETCH_HALFTONE</description>
          <description>Same as HALFTONE.</description>
        </item>
        <item>
          <description>STRETCH_ORSCANS</description>
          <description>Same as WHITEONBLACK.</description>
        </item>
        <item>
          <description>WHITEONBLACK</description>
          <description>Performs a Boolean OR operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves white pixels at the expense of black pixels.</description>
        </item>
      </list>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="SetStretchBltMode" />
  </member>
  <member name="Windows.GetSystemPaletteEntries">
    <summary>
      <para>The <b>GetSystemPaletteEntries</b> function retrieves a range of palette entries from the system palette that is associated with the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iStart">
      <para>The first entry to be retrieved from the system palette.</para>
    </param>
    <param name="cEntries">
      <para>The number of entries to be retrieved from the system palette.</para>
    </param>
    <param name="pPalEntries">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures to receive the palette entries. The array must contain at least as many structures as specified by the <i>cEntries</i> parameter. If this parameter is <b>NULL</b>, the function returns the total number of entries in the palette.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of entries retrieved from the palette.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetPaletteEntries" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</seealso>
  </member>
  <member name="Windows.GetSystemPaletteUse">
    <summary>
      <para>The <b>GetSystemPaletteUse</b> function retrieves the current state of the system (physical) palette for the specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current state of the system palette. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>SYSPAL_NOSTATIC</description>
          <description>The system palette contains no static colors except black and white.</description>
        </item>
        <item>
          <description>SYSPAL_STATIC</description>
          <description>The system palette contains static colors that will not change when an application realizes its logical palette.</description>
        </item>
        <item>
          <description>SYSPAL_ERROR</description>
          <description>The given device context is invalid or does not support a color palette.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>By default, the system palette contains 20 static colors that are not changed when an application realizes its logical palette. An application can gain access to most of these colors by calling the <see cref="SetSystemPaletteUse" /> function.</para>
      <para>The device context identified by the <i>hdc</i> parameter must represent a device that supports color palettes.</para>
      <para>An application can determine whether a device supports color palettes by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="SetSystemPaletteUse" />
  </member>
  <member name="Windows.GetTextCharacterExtra">
    <summary>
      <para>The <b>GetTextCharacterExtra</b> function retrieves the current intercharacter spacing for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current intercharacter spacing, in logical coordinates.</para>
      <para>If the function fails, the return value is 0x8000000.</para>
    </returns>
    <remarks>
      <para>The intercharacter spacing defines the extra space, in logical units along the base line, that the <see cref="TextOut" /> or <see cref="ExtTextOut" /> functions add to each character as a line is written. The spacing is used to expand lines of text.</para>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.GetTextCharset">
    <summary>
      <para>Retrieves a character set identifier for the font that is currently selected into a specified device context.
<b>Note</b>  A call to this function is equivalent to a call to <see cref="GetTextCharsetInfo" /> passing <b>NULL</b> for the data buffer.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context. The function obtains a character set identifier for the font that is selected into this device context.</para>
    </param>
    <returns>
      <para>If successful, returns a value identifying the character set of the font that is currently selected into the specified device context. The following character set identifiers are defined:</para>
      <para>If the function fails, it returns DEFAULT_CHARSET.</para>
    </returns>
    <seealso cref="GetTextCharsetInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-set-functions">Unicode and Character Set Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-sets">Unicode and Character Sets</seealso>
  </member>
  <member name="Windows.GetTextCharsetInfo">
    <summary>
      <para>Retrieves information about the character set of the font that is currently selected into a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context. The function obtains information about the font that is selected into this device context.</para>
    </param>
    <param name="lpSig">
      <para>Pointer to a <see cref="FONTSIGNATURE" /> data structure that receives font-signature information.</para>
      <para>If a TrueType font is currently selected into the device context, the <see cref="FONTSIGNATURE" /> structure receives information that identifies the code page and Unicode subranges for which the font provides glyphs.</para>
      <para>If a font other than TrueType is currently selected into the device context, the <see cref="FONTSIGNATURE" /> structure receives zeros. In this case, the application should use the <see cref="TranslateCharsetInfo" /> function to obtain generic font-signature information for the character set.</para>
      <para>The <i>lpSig</i> parameter specifies <b>NULL</b> if the application does not require the <see cref="FONTSIGNATURE" /> information. In this case, the application can also call the       <see cref="GetTextCharset" /> function, which is equivalent to calling       <b>GetTextCharsetInfo</b> with <i>lpSig</i> set to <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>Reserved; must be set to 0.</para>
    </param>
    <returns>
      <para>If successful, returns a value identifying the character set of the font currently selected into the specified device context. The following character set identifiers are defined:</para>
      <para>If the function fails, the return value is DEFAULT_CHARSET.</para>
    </returns>
    <seealso cref="FONTSIGNATURE" />
    <seealso cref="GetTextCharset" />
    <seealso cref="TranslateCharsetInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-set-functions">Unicode and Character Set Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-sets">Unicode and Character Sets</seealso>
  </member>
  <member name="Windows.GetTextColor">
    <summary>
      <para>The <b>GetTextColor</b> function retrieves the current text color for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the current text color as a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value.</para>
      <para>If the function fails, the return value is CLR_INVALID. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>The text color defines the foreground color of characters drawn by using the <see cref="TextOut" /> or <see cref="ExtTextOut" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="SetTextColor" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.GetTextExtentExPoint">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPointA">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPointW">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPointI">
    <summary>
      <para>The <b>GetTextExtentExPointI</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpwszString">
      <para>A pointer to an array of glyph indices for which extents are to be retrieved.</para>
    </param>
    <param name="cwchString">
      <para>The number of glyphs in the array pointed to by the <i>pgiIn</i> parameter.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial glyph extents. Each element in the array gives the distance, in logical units, between the beginning of the glyph indices array and one of the glyphs that fits in the space specified by the <i>nMaxExtent</i> parameter. Although this array should have at least as many elements as glyph indices specified by the <i>cgi</i> parameter, the function fills the array with extents only for as many glyph indices as are specified by the <i>lpnFit</i> parameter. If <i>lpnFit</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the glyph indices array, in logical units. This value cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPointI</b> function is equivalent to calling the <see cref="GetTextExtentPointI" /> function.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPoint">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPointA">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentExPointW">
    <summary>
      <para>The <b>GetTextExtentExPoint</b> function retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters. (A text extent is the distance between the beginning of the space and a character that will fit in the space.) This information is useful for word-wrapping calculations.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpszString">
      <para>A pointer to the null-terminated string for which extents are to be retrieved.</para>
    </param>
    <param name="cchString">
      <para>The number of characters in the string pointed to by the <i>lpszStr</i> parameter. For an ANSI call it specifies the string length in bytes and for a Unicode it specifies the string length in WORDs. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="nMaxExtent">
      <para>The maximum allowable width, in logical units, of the formatted string.</para>
    </param>
    <param name="lpnFit">
      <para>A pointer to an integer that receives a count of the maximum number of characters that will fit in the space specified by the <i>nMaxExtent</i> parameter. When the <i>lpnFit</i> parameter is <b>NULL</b>, the <i>nMaxExtent</i> parameter is ignored.</para>
    </param>
    <param name="lpnDx">
      <para>A pointer to an array of integers that receives partial string extents. Each element in the array gives the distance, in logical units, between the beginning of the string and one of the characters that fits in the space specified by the <i>nMaxExtent</i> parameter. This array must have at least as many elements as characters specified by the <i>cchString</i> parameter because the entire array is used internally. The function fills the array with valid extents for as many characters as are specified by the <i>lpnFit</i> parameter. Any values in the rest of the array should be ignored. If <i>alpDx</i> is <b>NULL</b>, the function does not compute partial string widths.</para>
      <para>For complex scripts, where a sequence of characters may be represented by any number of glyphs, the values in the <i>alpDx</i> array up to the number specified by the <i>lpnFit</i> parameter match one-to-one with code points. Again, you should ignore the rest of the values in the <i>alpDx</i> array.</para>
    </param>
    <param name="lpSize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units. This parameter cannot be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If both the <i>lpnFit</i> and <i>alpDx</i> parameters are <b>NULL</b>, calling the <b>GetTextExtentExPoint</b> function is equivalent to calling the <see cref="GetTextExtentPoint" /> function.</para>
      <para>For the ANSI version of <b>GetTextExtentExPoint</b>, the <i>lpDx</i> array has the same number of INT values as there are bytes in <i>lpString</i>. The INT values that correspond to the two bytes of a DBCS character are each the extent of the entire composite character.</para>
      <para>Note, the <i>alpDx</i> values for <b>GetTextExtentExPoint</b> are not the same as the <i>lpDx</i> values for <see cref="ExtTextOut" />. To use the <i>alpDx</i> values in <i>lpDx</i>, you must first process them.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>This function returns the extent of each successive character in a string. When these are rounded to logical units, you get different results than what is returned from the <see cref="GetCharWidth" />, which returns the width of each individual character rounded to logical units.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentExPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.GetTextExtentPoint32">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint32A">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint32W">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint32">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint32A">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint32W">
    <summary>
      <para>The <b>GetTextExtentPoint32</b> function computes the width and height of the specified string of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to a buffer that specifies the text string. The string does not need to be null-terminated, because the <i>c</i> parameter specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="psizl">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint32</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. This is true for both displaying on a screen and for printing. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. In addition, for EMF, the print result always takes both intercharacter spacing and justification into account.</para>
      <para>When dealing with text displayed on a screen, the calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function and the justification set by <see cref="SetTextJustification" />. However, if <i>lpDx</i> is set in <see cref="ExtTextOut" />, <b>GetTextExtentPoint32</b> does not take into account either intercharacter spacing or justification. However, when printing with EMF:</para>
      <list type="bullet">
        <item>
          <description>The print result ignores intercharacter spacing, although <b>GetTextExtentPoint32</b> takes it into account.</description>
        </item>
        <item>
          <description>The print result takes justification into account, although <b>GetTextExtentPoint32</b> ignores it.</description>
        </item>
      </list>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>
        <b>GetTextExtentPoint32</b> doesn't consider "\n" (new line) or "\r\n" (carriage return and new line) characters when it computes the height of a text string.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint32 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
    <seealso cref="SetTextJustification" />
  </member>
  <member name="Windows.GetTextExtentPoint">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPointA">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPointW">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPointI">
    <summary>
      <para>The <b>GetTextExtentPointI</b> function computes the width and height of the specified array of glyph indices.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="pgiIn">
      <para>Pointer to array of glyph indices.</para>
    </param>
    <param name="cgi">
      <para>Specifies the number of glyph indices.</para>
    </param>
    <param name="psize">
      <para>Pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPointI</b> function uses the currently selected font to compute the dimensions of the array of glyph indices. The width and height, in logical units, are computed without considering any clipping.</para>
      <para>When this function returns the text extent, it assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if you use a font that specifies a nonzero escapement, this function doesn't use the angle while it computes the text extent. The app must convert it explicitly. However, when the graphics mode is set to <see cref="GM_ADVANCED" /> and the character orientation is 90 degrees from the print orientation, the values that this function return do not follow this rule. When the character orientation and the print orientation match for a given string, this function returns the dimensions of the string in the <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure as { cx : 116, cy : 18 }.  When the character orientation and the print orientation are 90 degrees apart for the same string, this function returns the dimensions of the string in the <b>SIZE</b> structure as { cx : 18, cy : 116 }.</para>
      <para>Because some devices kern characters, the sum of the extents of the individual glyph indices may not be equal to the extent of the entire array of glyph indices.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPoint">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPointA">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextExtentPointW">
    <summary>
      <para>The <b>GetTextExtentPoint</b> function computes the width and height of the specified string of text.</para>
      <para>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should call the <see cref="GetTextExtentPoint32" /> function, which provides more accurate results.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string that specifies the text. The string does not need to be zero-terminated, since <i>cbString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the dimensions of the string, in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>GetTextExtentPoint</b> function uses the currently selected font to compute the dimensions of the string. The width and height, in logical units, are computed without considering any clipping. Also, this function assumes that the text is horizontal, that is, that the escapement is always 0. This is true for both the horizontal and vertical measurements of the text. Even if using a font specifying a nonzero escapement, this function will not use the angle while computing the text extent. The application must convert it explicitly.</para>
      <para>Because some devices kern characters, the sum of the extents of the characters in a string may not be equal to the extent of the string.</para>
      <para>The calculated string width takes into account the intercharacter spacing set by the <see cref="SetTextCharacterExtra" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextExtentPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetTextCharacterExtra" />
  </member>
  <member name="Windows.GetTextFace">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextFaceA">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextFaceW">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextFace">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextFaceA">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextFaceW">
    <summary>
      <para>The <b>GetTextFace</b> function retrieves the typeface name of the font that is selected into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="c">
      <para>The length of the buffer pointed to by <i>lpFaceName</i>. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function, most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.</para>
    </param>
    <param name="lpName">
      <para>A pointer to the buffer that receives the typeface name. If this parameter is <b>NULL</b>, the function returns the number of characters in the name, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters copied to the buffer.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The typeface name is copied as a null-terminated character string.</para>
      <para>If the name is longer than the number of characters specified by the <i>nCount</i> parameter, the name is truncated.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextFace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextColor" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
  </member>
  <member name="Windows.GetTextMetrics">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsA">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsW">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetrics">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsA">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsW">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetrics">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsA">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetTextMetricsW">
    <summary>
      <para>The <b>GetTextMetrics</b> function fills the specified buffer with the metrics for the currently selected font.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lptm">
      <para>A pointer to the <see cref="TEXTMETRIC" /> structure that receives the text metrics.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To determine whether a font is a TrueType font, first select it into a DC, then call <b>GetTextMetrics</b>, and then check for TMPF_TRUETYPE in TEXTMETRIC.tmPitchAndFamily. Note that <see cref="GetDC" /> returns an uninitialized DC, which has "System" (a bitmap font) as the default font; thus the need to select a font into the DC.</para>
      <h4>Examples</h4>
      <para>For an example, see "Displaying Keyboard Input" in <a href="https://docs.microsoft.com//windows/desktop/inputdev/using-keyboard-input">Using Keyboard Input</a> or <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-text-from-different-fonts-on-the-same-line">Drawing Text from Different Fonts on the Same Line</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines GetTextMetrics as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextFace" />
    <seealso cref="SetTextJustification" />
    <seealso cref="TEXTMETRIC" />
  </member>
  <member name="Windows.GetViewportExtEx">
    <summary>
      <para>The <b>GetViewportExtEx</b> function retrieves the x-extent and y-extent of the current viewport for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpsize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the x- and y-extents, in device units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWindowExtEx" />
    <seealso cref="SetViewportExtEx" />
    <seealso cref="SetWindowExtEx" />
  </member>
  <member name="Windows.GetViewportOrgEx">
    <summary>
      <para>The <b>GetViewportOrgEx</b> function retrieves the x-coordinates and y-coordinates of the viewport origin for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppoint">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the coordinates of the origin, in device units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWindowOrgEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="SetViewportOrgEx" />
    <seealso cref="SetWindowOrgEx" />
  </member>
  <member name="Windows.GetWindowExtEx">
    <summary>
      <para>This function retrieves the x-extent and y-extent of the window for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpsize">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the x- and y-extents in page-space units, that is, logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportExtEx" />
    <seealso cref="SetViewportExtEx" />
    <seealso cref="SetWindowExtEx" />
  </member>
  <member name="Windows.GetWindowOrgEx">
    <summary>
      <para>The <b>GetWindowOrgEx</b> function retrieves the x-coordinates and y-coordinates of the window origin for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppoint">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the coordinates, in logical units, of the window origin.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportOrgEx" />
    <seealso cref="SetViewportOrgEx" />
    <seealso cref="SetWindowOrgEx" />
  </member>
  <member name="Windows.GetWinMetaFileBits">
    <summary>
      <para>The <b>GetWinMetaFileBits</b> function converts the enhanced-format records from a metafile into Windows-format records and stores the converted records in the specified buffer.</para>
    </summary>
    <param name="hemf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="cbData16">
      <para>The size, in bytes, of the buffer into which the converted records are to be copied.</para>
    </param>
    <param name="pData16">
      <para>A pointer to the buffer that receives the converted records. If <i>lpbBuffer</i> is <b>NULL</b>, <b>GetWinMetaFileBits</b> returns the number of bytes required to store the converted metafile records.</para>
    </param>
    <param name="iMapMode">
      <para>The mapping mode to use in the converted metafile.</para>
    </param>
    <param name="hdcRef">
      <para>A handle to the reference device context.</para>
    </param>
    <returns>
      <para>If the function succeeds and the buffer pointer is <b>NULL</b>, the return value is the number of bytes required to store the converted records; if the function succeeds and the buffer pointer is a valid pointer, the return value is the size of the metafile data in bytes.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This function converts an enhanced metafile into a Windows-format metafile so that its picture can be displayed in an application that recognizes the older format.</para>
      <para>The system uses the reference device context to determine the resolution of the converted metafile.</para>
      <para>The <b>GetWinMetaFileBits</b> function does not invalidate the enhanced metafile handle. An application should call the <see cref="DeleteEnhMetaFile" /> function to release the handle when it is no longer needed.</para>
      <para>To create a scalable Windows-format metafile, specify MM_ANISOTROPIC as the <i>fnMapMode</i> parameter.</para>
      <para>The upper-left corner of the metafile picture is always mapped to the origin of the reference device.</para>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetMapMode" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.GetWorldTransform">
    <summary>
      <para>The <b>GetWorldTransform</b> function retrieves the current world-space to page-space transformation.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpxf">
      <para>A pointer to an <see cref="XFORM" /> structure that receives the current world-space to page-space transformation.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The precision of the transformation may be altered if an application calls the <see cref="ModifyWorldTransform" /> function prior to calling <b>GetWorldTransform</b>. (This is because the internal format for storing transformation values uses a higher precision than a <b>FLOAT</b> value.)</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="ModifyWorldTransform" />
    <seealso cref="SetWorldTransform" />
  </member>
  <member name="Windows.GetYValue">
    <summary>
      <para>The <b>GetYValue</b> macro retrieves the yellow color value from a CMYK color value.</para>
    </summary>
    <param name="cmyk">
      <para>CMYK color value from which the yellow color value will be retrieved.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="CMYK" />
    <seealso cref="GetCValue" />
    <seealso cref="GetKValue" />
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/macros-for-cmyk-values-and-colors">Macros for CMYK values and colors</seealso>
  </member>
  <member name="Windows.GradientFill">
    <summary>
      <para>The <b>GradientFill</b> function fills rectangle and triangle structures.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="pVertex">
      <para>A pointer to an array of <see cref="TRIVERTEX" /> structures that each define a vertex.</para>
    </param>
    <param name="nVertex">
      <para>The number of vertices in <i>pVertex</i>.</para>
    </param>
    <param name="pMesh">
      <para>An array of <see cref="GRADIENT_TRIANGLE" /> structures in triangle mode, or an array of <see cref="GRADIENT_RECT" /> structures in rectangle mode.</para>
    </param>
    <param name="nMesh">
      <para>The number of elements (triangles or rectangles) in <i>pMesh</i>.</para>
    </param>
    <param name="ulMode">
      <para>The gradient fill mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GRADIENT_FILL_RECT_H</b>
          </description>
          <description>
            <para>In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the <see cref="TRIVERTEX" /> structure) for the left and right edges. GDI interpolates the color from the left to right edge and fills the interior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GRADIENT_FILL_RECT_V</b>
          </description>
          <description>
            <para>In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the <see cref="TRIVERTEX" /> structure) for the top and bottom edges. GDI interpolates the color from the top to bottom edge and fills the interior.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GRADIENT_FILL_TRIANGLE</b>
          </description>
          <description>
            <para>In this mode, an array of <see cref="TRIVERTEX" /> structures is passed to GDI along with a list of array indexes that describe separate triangles. GDI performs linear interpolation between triangle vertices and fills the interior. Drawing is done directly in 24- and 32-bpp modes. Dithering is performed in 16-, 8-, 4-, and 1-bpp mode.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>To add smooth shading to a triangle, call the <b>GradientFill</b> function with the three triangle endpoints. GDI will linearly interpolate and fill the triangle. Here is the drawing output of a shaded triangle.</para>
      <para>
        <img alt="Illustration of a triangle that fills from orange at the top point to magenta on the bottom line " src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillTriangle.png" />
      </para>
      <para>To add smooth shading to a rectangle, call <b>GradientFill</b> with the upper-left and lower-right coordinates of the rectangle. There are two shading modes used when drawing a rectangle. In horizontal mode, the rectangle is shaded from left-to-right. In vertical mode, the rectangle is shaded from top-to-bottom. Here is the drawing output of two shaded rectangles - one in horizontal mode, the other in vertical mode:</para>
      <para>
        <img alt="Illustration of a rectangle that shades from dark on the left side to light on the right side" src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillRectangle.png" />
        <img alt="Illustration of a rectangle that shades from dark on the top to light on the bottom" src="https://docs.microsoft.com/windows/win32/api/wingdi/images/GradientFillRectangle2.png" />
      </para>
      <para>The <b>GradientFill</b> function uses a mesh method to specify the endpoints of the object to draw. All vertices are passed to <b>GradientFill</b> in the <i>pVertex</i> array. The <i>pMesh</i> parameter specifies how these vertices are connected to form an object. When filling a rectangle, <i>pMesh</i> points to an array of <see cref="GRADIENT_RECT" /> structures. Each <b>GRADIENT_RECT</b> structure specifies the index of two vertices in the <i>pVertex</i> array. These two vertices form the upper-left and lower-right boundary of one rectangle.</para>
      <para>In the case of filling a triangle, <i>pMesh</i> points to an array of <see cref="GRADIENT_TRIANGLE" /> structures. Each <b>GRADIENT_TRIANGLE</b> structure specifies the index of three vertices in the <i>pVertex</i> array. These three vertices form one triangle.</para>
      <para>To simplify hardware acceleration, this routine is not required to be pixel-perfect in the triangle interior.</para>
      <para>Note that GradientFill does not use the Alpha member of the <see cref="TRIVERTEX" /> structure. To use GradientFill with transparency, call GradientFill and then call <see cref="AlphaBlend" /> with the desired values for the alpha channel of each vertex.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/gdi/smooth-shading">Smooth Shading</a>, <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-shaded-triangle">Drawing a Shaded Triangle</a>, and <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-shaded-rectangle">Drawing a Shaded Rectangle</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="EMRGRADIENTFILL" />
    <seealso cref="GRADIENT_RECT" />
    <seealso cref="GRADIENT_TRIANGLE" />
    <seealso cref="TRIVERTEX" />
  </member>
  <member name="Windows.IntersectClipRect">
    <summary>
      <para>The <b>IntersectClipRect</b> function creates a new clipping region from the intersection of the current clipping region and the specified rectangle.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical units, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical units, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical units, of the lower-right corner of the rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical units, of the lower-right corner of the rectangle.</para>
    </param>
    <returns>
      <para>The return value specifies the new clipping region's type and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred. (The current clipping region is unaffected.)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The lower and right-most edges of the given rectangle are excluded from the clipping region.</para>
      <para>If a clipping region does not already exist then the system may apply a default clipping region to the specified HDC. A clipping region is then created from the intersection of that default clipping region and the rectangle specified in the function parameters.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="ExcludeClipRect" />
  </member>
  <member name="Windows.InvertRgn">
    <summary>
      <para>The <b>InvertRgn</b> function inverts the colors in the specified region.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>Handle to the region for which colors are inverted. The region's coordinates are presumed to be logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>On monochrome screens, the <b>InvertRgn</b> function makes white pixels black and black pixels white. On color screens, this inversion is dependent on the type of technology used to generate the colors for the screen.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
    </remarks>
    <seealso cref="FillRgn" />
    <seealso cref="PaintRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.LineDDA">
    <summary>
      <para>The <b>LineDDA</b> function determines which pixels should be highlighted for a line defined by the specified starting and ending points.</para>
    </summary>
    <param name="xStart">
      <para>Specifies the x-coordinate, in logical units, of the line's starting point.</para>
    </param>
    <param name="yStart">
      <para>Specifies the y-coordinate, in logical units, of the line's starting point.</para>
    </param>
    <param name="xEnd">
      <para>Specifies the x-coordinate, in logical units, of the line's ending point.</para>
    </param>
    <param name="yEnd">
      <para>Specifies the y-coordinate, in logical units, of the line's ending point.</para>
    </param>
    <param name="lpProc">
      <para>Pointer to an application-defined callback function. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-lineddaproc">LineDDAProc</a> callback function.</para>
    </param>
    <param name="data">
      <para>Pointer to the application-defined data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>LineDDA</b> function passes the coordinates for each point along the line, except for the line's ending point, to the application-defined callback function. In addition to passing the coordinates of a point, this function passes any existing application-defined data.</para>
      <para>The coordinates passed to the callback function match pixels on a video display only if the default transformations and mapping modes are used.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-lineddaproc">LineDDAProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
  </member>
  <member name="Windows.LineTo">
    <summary>
      <para>The <b>LineTo</b> function draws a line from the current position up to, but not including, the specified point.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context.</para>
    </param>
    <param name="x">
      <para>Specifies the x-coordinate, in logical units, of the line's ending point.</para>
    </param>
    <param name="y">
      <para>Specifies the y-coordinate, in logical units, of the line's ending point.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The line is drawn by using the current pen and, if the pen is a geometric pen, the current brush.</para>
      <para>If <b>LineTo</b> succeeds, the current position is set to the specified ending point.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-markers">Drawing Markers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso cref="Polyline" />
    <seealso cref="PolylineTo" />
  </member>
  <member name="Windows.LPtoDP">
    <summary>
      <para>The <b>LPtoDP</b> function converts logical coordinates into device coordinates. The conversion depends on the mapping mode of the device context, the settings of the origins and extents for the window and viewport, and the world transformation.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lppt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures. The x-coordinates and y-coordinates contained in each of the <b>POINT</b> structures will be transformed.</para>
    </param>
    <param name="c">
      <para>The number of points in the array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>LPtoDP</b> function fails if the logical coordinates exceed 32 bits, or if the converted device coordinates exceed 27 bits. In the case of such an overflow, the results for all the points are undefined.</para>
      <para>
        <b>LPtoDP</b> calculates complex floating-point arithmetic, and it has a caching system for efficiency. Therefore, the conversion result of an initial call to <b>LPtoDP</b> might not exactly match the conversion result of a later call to <b>LPtoDP</b>. We recommend not to write code that relies on the exact match of the conversion results from multiple calls to <b>LPtoDP</b> even if the parameters that are passed to each call are identical.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="DPtoLP" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
  </member>
  <member name="Windows.MAKEPOINTS">
    <summary>
      <para>The <b>MAKEPOINTS</b> macro converts a value that contains the x- and y-coordinates of a point into a <a href="https://docs.microsoft.com//previous-versions/dd162808(v=vs.85)">POINTS</a> structure.</para>
    </summary>
    <param name="l">
      <para>The coordinates of a point. The x-coordinate is in the low-order word, and the y-coordinate is in the high-order word.</para>
    </param>
    <seealso cref="GetMessagePos" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/rectangle-macros">Rectangle Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/rectangles">Rectangles Overview</seealso>
  </member>
  <member name="Windows.MAKEROP4">
    <summary>
      <para>The <b>MAKEROP4</b> macro creates a quaternary raster operation code for use with the <see cref="MaskBlt" /> function. The macro takes two ternary raster operation codes as input, one for the foreground and one for the background, and packs their Boolean operation indexes into the high-order word of a 32-bit value. The low-order word of this value will be ignored.</para>
    </summary>
    <param name="fore">
      <para>The foreground ternary raster operation code.</para>
    </param>
    <param name="back">
      <para>The background ternary raster operation code.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-macros">Bitmap Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="MaskBlt" />
  </member>
  <member name="Windows.MaskBlt">
    <summary>
      <para>The <b>MaskBlt</b> function combines the color data for the source and destination bitmaps using the specified mask and raster operation.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="width">
      <para>The width, in logical units, of the destination rectangle and source bitmap.</para>
    </param>
    <param name="height">
      <para>The height, in logical units, of the destination rectangle and source bitmap.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the device context from which the bitmap is to be copied. It must be zero if the <i>dwRop</i> parameter specifies a raster operation that does not include a source.</para>
    </param>
    <param name="xSrc">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source bitmap.</para>
    </param>
    <param name="ySrc">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source bitmap.</para>
    </param>
    <param name="hbmMask">
      <para>A handle to the monochrome mask bitmap combined with the color bitmap in the source device context.</para>
    </param>
    <param name="xMask">
      <para>The horizontal pixel offset for the mask bitmap specified by the <i>hbmMask</i> parameter.</para>
    </param>
    <param name="yMask">
      <para>The vertical pixel offset for the mask bitmap specified by the <i>hbmMask</i> parameter.</para>
    </param>
    <param name="rop">
      <para>The foreground and background ternary raster operation codes (ROPs) that the function uses to control the combination of source and destination data. The background raster operation code is stored in the high-order byte of the high-order word of this value; the foreground raster operation code is stored in the low-order byte of the high-order word of this value; the low-order word of this value is ignored, and should be zero. The macro <see cref="MAKEROP4" /> creates such combinations of foreground and background raster operation codes.</para>
      <para>For a discussion of foreground and background in the context of this function, see the following Remarks section.</para>
      <para>For a list of common raster operation codes (ROPs), see the <see cref="BitBlt" /> function. Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>MaskBlt</b> function uses device-dependent bitmaps.</para>
      <para>A value of 1 in the mask specified by <i>hbmMask</i> indicates that the foreground raster operation code specified by <i>dwRop</i> should be applied at that location. A value of 0 in the mask indicates that the background raster operation code specified by <i>dwRop</i> should be applied at that location.</para>
      <para>If the raster operations require a source, the mask rectangle must cover the source rectangle. If it does not, the function will fail. If the raster operations do not require a source, the mask rectangle must cover the destination rectangle. If it does not, the function will fail.</para>
      <para>If a rotation or shear transformation is in effect for the source device context when this function is called, an error occurs. However, other types of transformation are allowed.</para>
      <para>If the color formats of the source, pattern, and destination bitmaps differ, this function converts the pattern or source format, or both, to match the destination format.</para>
      <para>If the mask bitmap is not a monochrome bitmap, an error occurs.</para>
      <para>When an enhanced metafile is being recorded, an error occurs (and the function returns <b>FALSE</b>) if the source device context identifies an enhanced-metafile device context.</para>
      <para>Not all devices support the <b>MaskBlt</b> function. An application should call the <see cref="GetDeviceCaps" /> function with the <i>nIndex</i> parameter as RC_BITBLT to determine whether a device supports this function.</para>
      <para>If no mask bitmap is supplied, this function behaves exactly like <see cref="BitBlt" />, using the foreground raster operation code.</para>
      <para>
        <b>ICM:</b> No color management is performed when blits occur.</para>
      <para>When used in a multiple monitor system, both <i>hdcSrc</i> and <i>hdcDest</i> must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap (compatible bitmap, or DDB) to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
    </remarks>
    <seealso cref="BitBlt" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="PlgBlt" />
    <seealso cref="SetDIBits" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.ModifyWorldTransform">
    <summary>
      <para>The <b>ModifyWorldTransform</b> function changes the world transformation for a device context using the specified mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpxf">
      <para>A pointer to an <see cref="XFORM" /> structure used to modify the world transformation for the given device context.</para>
    </param>
    <param name="mode">
      <para>Specifies how the transformation data modifies the current world transformation. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>MWT_IDENTITY</b>
          </description>
          <description>
            <para>Resets the current world transformation by using the identity matrix. If this mode is specified, the <see cref="XFORM" /> structure pointed to by <i>lpXform</i> is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MWT_LEFTMULTIPLY</b>
          </description>
          <description>
            <para>Multiplies the current transformation by the data in the <see cref="XFORM" /> structure. (The data in the <b>XFORM</b> structure becomes the left multiplicand, and the data for the current transformation becomes the right multiplicand.)</para>
          </description>
        </item>
        <item>
          <description>
            <b>MWT_RIGHTMULTIPLY</b>
          </description>
          <description>
            <para>Multiplies the current transformation by the data in the <see cref="XFORM" /> structure. (The data in the <b>XFORM</b> structure becomes the right multiplicand, and the data for the current transformation becomes the left multiplicand.)</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>ModifyWorldTransform</b> function will fail unless graphics mode for the specified device context has been set to GM_ADVANCED by previously calling the <see cref="SetGraphicsMode" /> function. Likewise, it will not be possible to reset the graphics mode for the device context to the default GM_COMPATIBLE mode, unless world transform has first been reset to the default identity transform by calling <see cref="SetWorldTransform" /> or <b>ModifyWorldTransform</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWorldTransform" />
    <seealso cref="SetGraphicsMode" />
    <seealso cref="SetWorldTransform" />
    <seealso cref="XFORM" />
  </member>
  <member name="Windows.MoveToEx">
    <summary>
      <para>The <b>MoveToEx</b> function updates the current position to the specified point and optionally returns the previous position.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context.</para>
    </param>
    <param name="x">
      <para>Specifies the x-coordinate, in logical units, of the new position, in logical units.</para>
    </param>
    <param name="y">
      <para>Specifies the y-coordinate, in logical units, of the new position, in logical units.</para>
    </param>
    <param name="lppt">
      <para>Pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the previous current position. If this parameter is a <b>NULL</b> pointer, the previous position is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>MoveToEx</b> function affects all drawing functions.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-markers">Drawing Markers</a>.</para>
    </remarks>
    <seealso cref="AngleArc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso cref="LineTo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyBezierTo" />
    <seealso cref="PolylineTo" />
  </member>
  <member name="Windows.OffsetClipRgn">
    <summary>
      <para>The <b>OffsetClipRgn</b> function moves the clipping region of a device context by the specified offsets.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The number of logical units to move left or right.</para>
    </param>
    <param name="y">
      <para>The number of logical units to move up or down.</para>
    </param>
    <returns>
      <para>The return value specifies the new region's complexity and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred. (The current clipping region is unaffected.)</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="SelectClipRgn" />
  </member>
  <member name="Windows.OffsetRgn">
    <summary>
      <para>The <b>OffsetRgn</b> function moves a region by the specified offsets.</para>
    </summary>
    <param name="hrgn">
      <para>Handle to the region to be moved.</para>
    </param>
    <param name="x">
      <para>Specifies the number of logical units to move left or right.</para>
    </param>
    <param name="y">
      <para>Specifies the number of logical units to move up or down.</para>
    </param>
    <returns>
      <para>The return value specifies the new region's complexity. It can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>NULLREGION</description>
          <description>Region is empty.</description>
        </item>
        <item>
          <description>SIMPLEREGION</description>
          <description>Region is a single rectangle.</description>
        </item>
        <item>
          <description>COMPLEXREGION</description>
          <description>Region is more than one rectangle.</description>
        </item>
        <item>
          <description>ERROR</description>
          <description>An error occurred; region is unaffected.</description>
        </item>
      </list>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.OffsetViewportOrgEx">
    <summary>
      <para>The <b>OffsetViewportOrgEx</b> function modifies the viewport origin for a device context using the specified horizontal and vertical offsets.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The horizontal offset, in device units.</para>
    </param>
    <param name="y">
      <para>The vertical offset, in device units.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure. The previous viewport origin, in device units, is placed in this structure. If <i>lpPoint</i> is <b>NULL</b>, the previous viewport origin is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The new origin is the sum of the current origin and the horizontal and vertical offsets.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportOrgEx" />
    <seealso cref="OffsetWindowOrgEx" />
    <seealso cref="SetViewportOrgEx" />
  </member>
  <member name="Windows.OffsetWindowOrgEx">
    <summary>
      <para>The <b>OffsetWindowOrgEx</b> function modifies the window origin for a device context using the specified horizontal and vertical offsets.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The horizontal offset, in logical units.</para>
    </param>
    <param name="y">
      <para>The vertical offset, in logical units.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure. The logical coordinates of the previous window origin are placed in this structure. If <i>lpPoint</i> is <b>NULL</b>, the previous origin is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportOrgEx" />
    <seealso cref="OffsetViewportOrgEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
  </member>
  <member name="Windows.PaintRgn">
    <summary>
      <para>The <b>PaintRgn</b> function paints the specified region by using the brush currently selected into the device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>Handle to the region to be filled. The region's coordinates are presumed to be logical coordinates.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <seealso cref="FillRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.PALETTEINDEX">
    <summary>
      <para>The <b>PALETTEINDEX</b> macro accepts an index to a logical-color palette entry and returns a palette-entry specifier consisting of a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value that specifies the color associated with the given index. An application using a logical palette can pass this specifier, instead of an explicit red, green, blue (RGB) value, to GDI functions that expect a color. This allows the function to use the color in the specified palette entry.</para>
    </summary>
    <param name="i">
      <para>An index to the palette entry containing the color to be used for a graphics operation.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="PALETTERGB" />
    <seealso cref="RGB" />
  </member>
  <member name="Windows.PALETTERGB">
    <summary>
      <para>The <b>PALETTERGB</b> macro accepts three values that represent the relative intensities of red, green, and blue and returns a palette-relative red, green, blue (RGB) specifier consisting of 2 in the high-order byte and an RGB value in the three low-order bytes. An application using a color palette can pass this specifier, instead of an explicit RGB value, to functions that expect a color.</para>
    </summary>
    <param name="r">
      <para>The intensity of the red color field.</para>
    </param>
    <param name="g">
      <para>The intensity of the green color field.</para>
    </param>
    <param name="b">
      <para>The intensity of the blue color field.</para>
    </param>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</seealso>
    <seealso cref="RGB" />
  </member>
  <member name="Windows.PatBlt">
    <summary>
      <para>The <b>PatBlt</b> function paints the specified rectangle using the brush that is currently selected into the specified device context. The brush color and the surface color or colors are combined by using the specified raster operation.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.</para>
    </param>
    <param name="w">
      <para>The width, in logical units, of the rectangle.</para>
    </param>
    <param name="h">
      <para>The height, in logical units, of the rectangle.</para>
    </param>
    <param name="rop">
      <para>The raster operation code. This code can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PATCOPY</b>
          </description>
          <description>
            <para>Copies the specified pattern into the destination bitmap.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PATINVERT</b>
          </description>
          <description>
            <para>Combines the colors of the specified pattern with the colors of the destination rectangle by using the Boolean XOR operator.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DSTINVERT</b>
          </description>
          <description>
            <para>Inverts the destination rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>BLACKNESS</b>
          </description>
          <description>
            <para>Fills the destination rectangle using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)</para>
          </description>
        </item>
        <item>
          <description>
            <b>WHITENESS</b>
          </description>
          <description>
            <para>Fills the destination rectangle using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The values of the <i>dwRop</i> parameter for this function are a limited subset of the full 256 ternary raster-operation codes; in particular, an operation code that refers to a source rectangle cannot be used.</para>
      <para>Not all devices support the <b>PatBlt</b> function. For more information, see the description of the RC_BITBLT capability in the <see cref="GetDeviceCaps" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see "Example of Menu-Item Bitmaps" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.PathToRegion">
    <summary>
      <para>The <b>PathToRegion</b> function creates a region from the path that is selected into the specified device context. The resulting region uses device coordinates.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context that contains a closed path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies a valid region.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>When you no longer need the <b>HRGN</b> object call the <see cref="DeleteObject" /> function to delete it.</para>
      <para>The device context identified by the <i>hdc</i> parameter must contain a closed path.</para>
      <para>After <b>PathToRegion</b> converts a path into a region, the system discards the closed path from the specified device context.</para>
    </remarks>
  </member>
  <member name="Windows.Pie">
    <summary>
      <para>The <b>Pie</b> function draws a pie-shaped wedge bounded by the intersection of an ellipse and two radials. The pie is outlined by using the current pen and filled by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle.</para>
    </param>
    <param name="xr1">
      <para>The x-coordinate, in logical coordinates, of the endpoint of the first radial.</para>
    </param>
    <param name="yr1">
      <para>The y-coordinate, in logical coordinates, of the endpoint of the first radial.</para>
    </param>
    <param name="xr2">
      <para>The x-coordinate, in logical coordinates, of the endpoint of the second radial.</para>
    </param>
    <param name="yr2">
      <para>The y-coordinate, in logical coordinates, of the endpoint of the second radial.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The curve of the pie is defined by an ellipse that fits the specified bounding rectangle. The curve begins at the point where the ellipse intersects the first radial and extends counterclockwise to the point where the ellipse intersects the second radial.</para>
      <para>The current position is neither used nor updated by the <b>Pie</b> function.</para>
    </remarks>
    <seealso cref="AngleArc " />
    <seealso cref="Arc " />
    <seealso cref="ArcTo " />
    <seealso cref="Chord " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
  </member>
  <member name="Windows.PlayEnhMetaFile">
    <summary>
      <para>The <b>PlayEnhMetaFile</b> function displays the picture stored in the specified enhanced-format metafile.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the output device on which the picture will appear.</para>
    </param>
    <param name="hmf">
      <para>A handle to the enhanced metafile.</para>
    </param>
    <param name="lprect">
      <para>A pointer to a <see cref="RECT" /> structure that contains the coordinates of the bounding rectangle used to display the picture. The coordinates are specified in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>When an application calls the <b>PlayEnhMetaFile</b> function, the system uses the picture frame in the enhanced-metafile header to map the picture onto the rectangle pointed to by the <i>lpRect</i> parameter. (This picture may be sheared or rotated by setting the world transform in the output device before calling <b>PlayEnhMetaFile</b>.) Points along the edges of the rectangle are included in the picture.</para>
      <para>An enhanced-metafile picture can be clipped by defining the clipping region in the output device before playing the enhanced metafile.</para>
      <para>If an enhanced metafile contains an optional palette, an application can achieve consistent colors by setting up a color palette on the output device before calling <b>PlayEnhMetaFile</b>. To retrieve the optional palette, use the <see cref="GetEnhMetaFilePaletteEntries" /> function.</para>
      <para>An enhanced metafile can be embedded in a newly created enhanced metafile by calling <b>PlayEnhMetaFile</b> and playing the source enhanced metafile into the device context for the new enhanced metafile.</para>
      <para>The states of the output device context are preserved by this function. Any object created but not deleted in the enhanced metafile is deleted by this function.</para>
      <para>To stop this function, an application can call the <see cref="CancelDC" /> function from another thread to terminate the operation. In this case, the function returns <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/opening-an-enhanced-metafile-and-displaying-its-contents">Opening an Enhanced Metafile and Displaying Its Contents</a>.</para>
    </remarks>
    <seealso cref="CancelDC" />
    <seealso cref="GetEnhMetaFileHeader" />
    <seealso cref="GetEnhMetaFilePaletteEntries" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="RECT" />
  </member>
  <member name="Windows.PlayEnhMetaFileRecord">
    <summary>
      <para>The <b>PlayEnhMetaFileRecord</b> function plays an enhanced-metafile record by executing the graphics device interface (GDI) functions identified by the record.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context passed to the <see cref="EnumEnhMetaFile" /> function.</para>
    </param>
    <param name="pht">
      <para>A pointer to a table of handles to GDI objects used when playing the metafile. The first entry in this table contains the enhanced-metafile handle.</para>
    </param>
    <param name="pmr">
      <para>A pointer to the enhanced-metafile record to be played.</para>
    </param>
    <param name="cht">
      <para>The number of handles in the handle table.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This is an enhanced-metafile function.</para>
      <para>An application typically uses <b>PlayEnhMetaFileRecord</b> in conjunction with the <see cref="EnumEnhMetaFile" /> function to process and play an enhanced-format metafile one record at a time.</para>
      <para>The <i>hdc</i>, <i>lpHandletable</i>, and <i>nHandles</i> parameters must be exactly those passed to the <a href="https://docs.microsoft.com//previous-versions/dd162606(v=vs.85)">EnhMetaFileProc</a> callback procedure by the <see cref="EnumEnhMetaFile" /> function.</para>
      <para>If <b>PlayEnhMetaFileRecord</b> does not recognize a record, it ignores the record and returns <b>TRUE</b>.</para>
    </remarks>
    <seealso cref="EnumEnhMetaFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
  </member>
  <member name="Windows.PlayMetaFile">
    <summary>
      <para>The <b>PlayMetaFile</b> function displays the picture stored in the given Windows-format metafile on the specified device.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="PlayEnhMetaFile" />.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context.</para>
    </param>
    <param name="hmf">
      <para>Handle to a Windows-format metafile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To convert a Windows-format metafile into an enhanced format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>A Windows-format metafile can be played multiple times.</para>
      <para>A Windows-format metafile can be embedded in a second Windows-format metafile by calling the <b>PlayMetaFile</b> function and playing the source metafile into the device context for the target metafile.</para>
      <para>Any object created but not deleted in the Windows-format metafile is deleted by this function.</para>
      <para>To stop this function, an application can call the <see cref="CancelDC" /> function from another thread to terminate the operation. In this case, the function returns <b>FALSE</b>.</para>
    </remarks>
    <seealso cref="CancelDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.PlayMetaFileRecord">
    <summary>
      <para>The <b>PlayMetaFileRecord</b> function plays a Windows-format metafile record by executing the graphics device interface (GDI) function contained within that record.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="PlayEnhMetaFileRecord" />.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="lpHandleTable">
      <para>A pointer to a <see cref="HANDLETABLE" /> structure representing the table of handles to GDI objects used when playing the metafile.</para>
    </param>
    <param name="lpMR">
      <para>A pointer to the Windows-format metafile record.</para>
    </param>
    <param name="noObjs">
      <para>The number of handles in the handle table.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To convert a Windows-format metafile into an enhanced-format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>An application typically uses <b>PlayMetaFileRecord</b> in conjunction with the <see cref="EnumMetaFile" /> function to process and play a Windows-format metafile one record at a time.</para>
      <para>The <i>lpHandletable</i> and <i>nHandles</i> parameters must be identical to those passed to the <a href="https://docs.microsoft.com//previous-versions/dd162630(v=vs.85)">EnumMetaFileProc</a> callback procedure by <see cref="EnumMetaFile" />.</para>
      <para>If the <b>PlayMetaFileRecord</b> function does not recognize a record, it ignores the record and returns <b>TRUE</b>.</para>
    </remarks>
    <seealso cref="EnumMetaFile" />
    <seealso cref="HANDLETABLE" />
    <seealso cref="METARECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayMetaFile" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.PlgBlt">
    <summary>
      <para>The <b>PlgBlt</b> function performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the destination device context. If the given bitmask handle identifies a valid monochrome bitmap, the function uses this bitmap to mask the bits of color data from the source rectangle.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="lpPoint">
      <para>A pointer to an array of three points in logical space that identify three corners of the destination parallelogram. The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right corner to the second point in this array, and the lower-left corner to the third point. The lower-right corner of the source rectangle is mapped to the implicit fourth point in the parallelogram.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xSrc">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="ySrc">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="width">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="height">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="hbmMask">
      <para>A handle to an optional monochrome bitmap that is used to mask the colors of the source rectangle.</para>
    </param>
    <param name="xMask">
      <para>The x-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.</para>
    </param>
    <param name="yMask">
      <para>The y-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>PlgBlt</b> function works with device-dependent bitmaps.</para>
      <para>The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C ) as vectors and computing D = B +CA.</para>
      <para>If the bitmask exists, a value of one in the mask indicates that the source pixel color should be copied to the destination. A value of zero in the mask indicates that the destination pixel color is not to be changed. If the mask rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern.</para>
      <para>Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation and shear transformations are not. If the mask bitmap is not a monochrome bitmap, an error occurs. The stretching mode for the destination device context is used to determine how to stretch or compress the pixels, if that is necessary.</para>
      <para>When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context.</para>
      <para>The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context. If the source transformation has a rotation or shear, an error is returned.</para>
      <para>If the destination and source rectangles do not have the same color format, <b>PlgBlt</b> converts the source rectangle to match the destination rectangle.</para>
      <para>Not all devices support the <b>PlgBlt</b> function. For more information, see the description of the RC_BITBLT raster capability in the <see cref="GetDeviceCaps" /> function.</para>
      <para>If the source and destination device contexts represent incompatible devices, <b>PlgBlt</b> returns an error.</para>
      <para>When used in a multiple monitor system, both <i>hdcSrc</i> and <i>hdcDest</i> must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
    </remarks>
    <seealso cref="BitBlt" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="MaskBlt" />
    <seealso cref="SetDIBits" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.PolyBezier">
    <summary>
      <para>The <b>PolyBezier</b> function draws one or more Bézier curves.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that contain the endpoints and control points of the curve(s), in logical units.</para>
    </param>
    <param name="cpt">
      <para>The number of points in the <i>lppt</i> array. This value must be one more than three times the number of curves to be drawn, because each Bézier curve requires two control points and an endpoint, and the initial curve requires an additional starting point.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>PolyBezier</b> function draws cubic Bézier curves by using the endpoints and control points specified by the <i>lppt</i> parameter. The first curve is drawn from the first point to the fourth point by using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point.</para>
      <para>The current position is neither used nor updated by the <b>PolyBezier</b> function. The figure is not filled.</para>
      <para>This function draws lines by using the current pen.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/redrawing-in-the-update-region">Redrawing in the Update Region</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyBezierTo" />
  </member>
  <member name="Windows.PolyBezierTo">
    <summary>
      <para>The <b>PolyBezierTo</b> function draws one or more Bézier curves.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that contains the endpoints and control points, in logical units.</para>
    </param>
    <param name="cpt">
      <para>The number of points in the <i>lppt</i> array. This value must be three times the number of curves to be drawn because each Bézier curve requires two control points and an ending point.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This function draws cubic Bézier curves by using the control points specified by the <i>lppt</i> parameter. The first curve is drawn from the current position to the third point by using the first two points as control points. For each subsequent curve, the function needs exactly three more points, and uses the ending point of the previous curve as the starting point for the next.</para>
      <para>
        <b>PolyBezierTo</b> moves the current position to the ending point of the last Bézier curve. The figure is not filled.</para>
      <para>This function draws lines by using the current pen.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyBezier" />
  </member>
  <member name="Windows.PolyDraw">
    <summary>
      <para>The <b>PolyDraw</b> function draws a set of line segments and Bézier curves.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that contains the endpoints for each line segment and the endpoints and control points for each Bézier curve, in logical units.</para>
    </param>
    <param name="aj">
      <para>A pointer to an array that specifies how each point in the <i>lppt</i> array is used. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Type</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PT_MOVETO</b>
          </description>
          <description>
            <para>Specifies that this point starts a disjoint figure. This point becomes the new current position.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PT_LINETO</b>
          </description>
          <description>
            <para>Specifies that a line is to be drawn from the current position to this point, which then becomes the new current position.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PT_BEZIERTO</b>
          </description>
          <description>
            <para>Specifies that this point is a control point or ending point for a Bézier curve.</para>
            <para>PT_BEZIERTO types always occur in sets of three. The current position defines the starting point for the Bézier curve. The first two PT_BEZIERTO points are the control points, and the third PT_BEZIERTO point is the ending point. The ending point becomes the new current position. If there are not three consecutive PT_BEZIERTO points, an error results.</para>
          </description>
        </item>
      </list>
      <para>A PT_LINETO or PT_BEZIERTO type can be combined with the following value by using the bitwise operator OR to indicate that the corresponding point is the last point in a figure and the figure is closed.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PT_CLOSEFIGURE</b>
          </description>
          <description>
            <para>Specifies that the figure is automatically closed after the PT_LINETO or PT_BEZIERTO type for this point is done. A line is drawn from this point to the most recent PT_MOVETO or <see cref="MoveToEx" /> point.</para>
            <para>This value is combined with the PT_LINETO type for a line, or with the PT_BEZIERTO type of the ending point for a Bézier curve, by using the bitwise operator OR.</para>
            <para>The current position is set to the ending point of the closing line.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="cpt">
      <para>The total number of points in the <i>lppt</i> array, the same as the number of bytes in the <i>lpbTypes</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>PolyDraw</b> function can be used in place of consecutive calls to <see cref="MoveToEx" />, <see cref="LineTo" />, and <see cref="PolyBezierTo" /> functions to draw disjoint figures. The lines and curves are drawn using the current pen and figures are not filled. If there is an active path started by calling <see cref="BeginPath" />, <b>PolyDraw</b> adds to the path.</para>
      <para>The points contained in the <i>lppt</i> array and in the <i>lpbTypes</i> array indicate whether each point is part of a <see cref="MoveTo" />, <see cref="LineTo" />, or <see cref="PolyBezierTo" /> operation. It is also possible to close figures.</para>
      <para>This function updates the current position.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="EndPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso cref="LineTo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyBezierTo" />
    <seealso cref="PolyLine" />
  </member>
  <member name="Windows.Polygon">
    <summary>
      <para>The <b>Polygon</b> function draws a polygon consisting of two or more vertices connected by straight lines. The polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that specify the vertices of the polygon, in logical coordinates.</para>
    </param>
    <param name="cpt">
      <para>The number of vertices in the array. This value must be greater than or equal to 2.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The polygon is closed automatically by drawing a line from the last vertex to the first.</para>
      <para>The current position is neither used nor updated by the <b>Polygon</b> function.</para>
      <para>Any extra points are ignored. To draw a line with more points, divide your data into groups, each of which have less than the maximum number of points, and call the function for each group of points. Remember to connect the line segments.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
    <seealso cref="GetPolyFillMode " />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT
</seealso>
    <seealso cref="PolyPolygon " />
    <seealso cref="Polyline " />
    <seealso cref="PolylineTo " />
    <seealso cref="SetPolyFillMode " />
  </member>
  <member name="Windows.Polyline">
    <summary>
      <para>The <b>Polyline</b> function draws a series of line segments by connecting the points in the specified array.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures, in logical units.</para>
    </param>
    <param name="cpt">
      <para>The number of points in the array. This number must be greater than or equal to two.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The lines are drawn from the first point through subsequent points by using the current pen. Unlike the <see cref="LineTo" /> or <see cref="PolylineTo" /> functions, the <b>Polyline</b> function neither uses nor updates the current position.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso cref="LineTo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyPolyline" />
    <seealso cref="PolylineTo" />
  </member>
  <member name="Windows.PolylineTo">
    <summary>
      <para>The <b>PolylineTo</b> function draws one or more straight lines.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that contains the vertices of the line, in logical units.</para>
    </param>
    <param name="cpt">
      <para>The number of points in the array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Unlike the <see cref="Polyline" /> function, the <b>PolylineTo</b> function uses and updates the current position.</para>
      <para>A line is drawn from the current position to the first point specified by the <i>lppt</i> parameter by using the current pen. For each additional line, the function draws from the ending point of the previous line to the next point specified by <i>lppt</i>.</para>
      <para>
        <b>PolylineTo</b> moves the current position to the ending point of the last line.</para>
      <para>If the line segments drawn by this function form a closed figure, the figure is not filled.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso cref="LineTo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso cref="MoveToEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="PolyPolyline" />
    <seealso cref="Polyline" />
  </member>
  <member name="Windows.PolyPolygon">
    <summary>
      <para>The <b>PolyPolygon</b> function draws a series of closed polygons. Each polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode. The polygons drawn by this function can overlap.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that define the vertices of the polygons, in logical coordinates. The polygons are specified consecutively. Each polygon is closed automatically by drawing a line from the last vertex to the first. Each vertex should be specified once.</para>
    </param>
    <param name="asz">
      <para>A pointer to an array of integers, each of which specifies the number of points in the corresponding polygon. Each integer must be greater than or equal to 2.</para>
    </param>
    <param name="csz">
      <para>The total number of polygons.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current position is neither used nor updated by this function.</para>
      <para>Any extra points are ignored. To draw the polygons with more points, divide your data into groups, each of which have less than the maximum number of points, and call the function for each group of points. Note, it is best to have a polygon in only one of the groups.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
    <seealso cref="GetPolyFillMode " />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT
</seealso>
    <seealso cref="Polygon" />
    <seealso cref="Polyline " />
    <seealso cref="PolylineTo " />
    <seealso cref="SetPolyFillMode " />
  </member>
  <member name="Windows.PolyPolyline">
    <summary>
      <para>The <b>PolyPolyline</b> function draws multiple series of connected line segments.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="apt">
      <para>A pointer to an array of <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structures that contains the vertices of the polylines, in logical units. The polylines are specified consecutively.</para>
    </param>
    <param name="asz">
      <para>A pointer to an array of variables specifying the number of points in the <i>lppt</i> array for the corresponding polyline. Each entry must be greater than or equal to two.</para>
    </param>
    <param name="csz">
      <para>The total number of entries in the <i>lpdwPolyPoints</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The line segments are drawn by using the current pen. The figures formed by the segments are not filled.</para>
      <para>The current position is neither used nor updated by this function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="Polyline" />
    <seealso cref="PolylineTo" />
  </member>
  <member name="Windows.PolyTextOut">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PolyTextOutA">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PolyTextOutW">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PolyTextOut">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PolyTextOutA">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PolyTextOutW">
    <summary>
      <para>The <b>PolyTextOut</b> function draws several strings using the font and text colors currently selected in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="ppt">
      <para>A pointer to an array of <see cref="POLYTEXT" /> structures describing the strings to be drawn. The array contains one structure for each string to be drawn.</para>
    </param>
    <param name="nstrings">
      <para>The number of <see cref="POLYTEXT" /> structures in the <i>pptxt</i> array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each <see cref="POLYTEXT" /> structure contains the coordinates of a reference point that Windows uses to align the corresponding string of text. An application can specify how the reference point is used by calling the <see cref="SetTextAlign" /> function. An application can determine the current text-alignment setting for the specified device context by calling the <see cref="GetTextAlign" /> function.</para>
      <para>To draw a single string of text, the application should call the <see cref="ExtTextOut" /> function.</para>
      <para>
        <b>PolyTextOut</b> will not handle international scripting support automatically. To get international scripting support, use <b>ExtTextOut</b> instead. <b>ExtTextOut</b> will use <a href="https://docs.microsoft.com//windows/win32/intl/uniscribe">Uniscribe</a> when necessary resulting in font fallback. Additionally, <b>ExtTextOut</b> will perform internal batching of calls before transitioning to kernel mode, mitigating some of the performance concerns when weighing usage of <b>PolyTextOut</b> versus <b>ExtTextOut</b>.</para>
      <blockquote>
        <para>[!TIP]
<b>ExtTextOut</b> is strongly recommended over <b>PolyTextOut</b> for modern development due to its ability to handle display of different languages.</para>
      </blockquote>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines PolyTextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="POLYTEXT" />
    <seealso cref="SetTextAlign" />
  </member>
  <member name="Windows.PtInRegion">
    <summary>
      <para>The <b>PtInRegion</b> function determines whether the specified point is inside the specified region.</para>
    </summary>
    <param name="hrgn">
      <para>Handle to the region to be examined.</para>
    </param>
    <param name="x">
      <para>Specifies the x-coordinate of the point in logical units.</para>
    </param>
    <param name="y">
      <para>Specifies the y-coordinate of the point in logical units.</para>
    </param>
    <returns>
      <para>If the specified point is in the region, the return value is nonzero.</para>
      <para>If the specified point is not in the region, the return value is zero.</para>
    </returns>
    <seealso cref="RectInRegion" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.PtVisible">
    <summary>
      <para>The <b>PtVisible</b> function determines whether the specified point is within the clipping region of a device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the point.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the point.</para>
    </param>
    <returns>
      <para>If the specified point is within the clipping region of the device context, the return value is <b>TRUE</b>(1).</para>
      <para>If the specified point is not within the clipping region of the device context, the return value is <b>FALSE</b>(0).</para>
      <para>If the <b>HDC</b> is not valid, the return value is (BOOL)-1.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="RectVisible" />
  </member>
  <member name="Windows.RealizePalette">
    <summary>
      <para>The <b>RealizePalette</b> function maps palette entries from the current logical palette to the system palette.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context into which a logical palette has been selected.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of entries in the logical palette mapped to the system palette.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>The <b>RealizePalette</b> function modifies the palette for the device associated with the specified device context. If the device context is a memory DC, the color table for the bitmap selected into the DC is modified. If the device context is a display DC, the physical palette for that device is modified.</para>
      <para>A logical palette is a buffer between color-intensive applications and the system, allowing these applications to use as many colors as needed without interfering with colors displayed by other windows.</para>
      <para>When an application's window has the focus and it calls the <b>RealizePalette</b> function, the system attempts to realize as many of the requested colors as possible. The same is also true for applications with inactive windows.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="CreatePalette" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="SelectPalette" />
  </member>
  <member name="Windows.Rectangle">
    <summary>
      <para>The <b>Rectangle</b> function draws a rectangle. The rectangle is outlined by using the current pen and filled by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current position is neither used nor updated by <b>Rectangle</b>.</para>
      <para>The rectangle that is drawn excludes the bottom and right edges.</para>
      <para>If a PS_NULL pen is used, the dimensions of the rectangle are 1 pixel less in height and 1 pixel less in width.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-filled-shapes">Using Filled Shapes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
    <seealso cref="RoundRect " />
  </member>
  <member name="Windows.RectInRegion">
    <summary>
      <para>The <b>RectInRegion</b> function determines whether any part of the specified rectangle is within the boundaries of a region.</para>
    </summary>
    <param name="hrgn">
      <para>Handle to the region.</para>
    </param>
    <param name="lprect">
      <para>Pointer to a <see cref="RECT" /> structure containing the coordinates of the rectangle in logical units. The lower and right edges of the rectangle are not included.</para>
    </param>
    <returns>
      <para>If any part of the specified rectangle lies within the boundaries of the region, the return value is nonzero.</para>
      <para>If no part of the specified rectangle lies within the boundaries of the region, the return value is zero.</para>
    </returns>
    <seealso cref="PtInRegion" />
    <seealso cref="RECT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.RectVisible">
    <summary>
      <para>The <b>RectVisible</b> function determines whether any part of the specified rectangle lies within the clipping region of a device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lprect">
      <para>A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the specified rectangle.</para>
    </param>
    <returns>
      <para>If the current transform does not have a rotation and the rectangle lies within the clipping region, the return value is <b>TRUE</b> (1).</para>
      <para>If the current transform does not have a rotation and the rectangle does not lie within the clipping region, the return value is <b>FALSE</b> (0).</para>
      <para>If the current transform has a rotation and the rectangle lies within the clipping region, the return value is 2.</para>
      <para>If the current transform has a rotation and the rectangle does not lie within the clipping region, the return value is 1.</para>
      <para>All other return values are considered error codes. If the any parameter is not valid, the return value is undefined.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="CreateRectRgn" />
    <seealso cref="PtVisible" />
    <seealso cref="RECT" />
    <seealso cref="SelectClipRgn" />
  </member>
  <member name="Windows.RemoveFontMemResourceEx">
    <summary>
      <para>The <b>RemoveFontMemResourceEx</b> function removes the fonts added from a memory image file.</para>
    </summary>
    <param name="h">
      <para>A handle to the font-resource. This handle is returned by the <see cref="AddFontMemResourceEx" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function removes a font that was added by the <see cref="AddFontMemResourceEx" /> function. To remove the font, specify the same path and flags as were used in <b>AddFontMemResourceEx</b>. This function will only remove the font that is specified by <i>fh</i>.</para>
    </remarks>
    <seealso cref="AddFontMemResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResource">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceA">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceW">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceEx">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceExA">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceExW">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceEx">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceExA">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceExW">
    <summary>
      <para>The <b>RemoveFontResourceEx</b> function removes the fonts in the specified file from the system font table.</para>
    </summary>
    <param name="name">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <param name="fl">
      <para>The characteristics of the font to be removed from the system. In order for the font to be removed, the flags used must be the same as when the font was added with the <see cref="AddFontResourceEx" /> function. See the <b>AddFontResourceEx</b> function for more information.</para>
    </param>
    <param name="pdv">
      <para>Reserved. Must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. No extended error information is available.</para>
    </returns>
    <remarks>
      <para>This function will only remove the font if the flags specified are the same as when then font was added with the <see cref="AddFontResourceEx" /> function.</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResourceEx</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResourceEx</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResourceEx" /> to reload the font.  We recommend that you call <b>AddFontResourceEx</b> the same number of times as the call to <b>RemoveFontResourceEx</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResourceEx( FontFile, FR_PRIVATE, 0 ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResourceEx( FontFile, FR_PRIVATE, 0 );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResourceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResourceEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResource">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceA">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.RemoveFontResourceW">
    <summary>
      <para>The <b>RemoveFontResource</b> function removes the fonts in the specified file from the system font table.</para>
      <para>If the font was added using the <see cref="AddFontResourceEx" /> function, you must use the <see cref="RemoveFontResourceEx" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that names a font resource file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>We recommend that if an app adds or removes fonts from the system font table that it notify other windows of the change by sending a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-fontchange">WM_FONTCHANGE</a> message to all top-level windows in the system. The app sends this message by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</a> function with the <i>hwnd</i> parameter set to HWND_BROADCAST.</para>
      <para>If there are outstanding references to a font, the associated resource remains loaded until no device context is using it. Furthermore, if the font is listed in the font registry (<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts</b>) and is installed to any location other than the %windir%\fonts\ folder, it may be loaded into other active sessions (including session 0).</para>
      <para>When you try to replace an existing font file that contains a font with outstanding references to it, you might get an error that indicates that the original font can't be deleted because it’s in use even after you call <b>RemoveFontResource</b>. If your app requires that the font file be replaced, to reduce the resource count of the original font to zero, call <b>RemoveFontResource</b> in a loop as shown in this example code. If you continue to get errors, this is an indication that the font file remains loaded in other sessions. Make sure the font isn't listed in the font registry and restart the system to ensure the font is unloaded from all sessions.</para>
      <para>
        <b>Note</b>  Apps where the original font file is in use will still be able to access the original file and won't use the new font until the font reloads. Call <see cref="AddFontResource" /> to reload the font.  We recommend that you call <b>AddFontResource</b> the same number of times as the call to <b>RemoveFontResource</b> succeeded as shown in this example code.</para>
      <code>
int i = 0;
while( RemoveFontResource( FontFile ) )
{
    i++;
}

// TODO: Replace font file

while( i-- )
{
    AddFontResource( FontFile );
}

</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines RemoveFontResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddFontResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="RemoveFontResourceEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oe/oe-ihttpmailtransport-sendmessage">SendMessage</seealso>
  </member>
  <member name="Windows.ResetDC">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResetDCA">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResetDCW">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResetDC">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResetDCA">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResetDCW">
    <summary>
      <para>The <b>ResetDC</b> function updates the specified printer or plotter device context (DC) using the specified information.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC to update.</para>
    </param>
    <param name="lpdm">
      <para>A pointer to a <see cref="DEVMODE" /> structure containing information about the new DC.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the original DC.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application will typically use the <b>ResetDC</b> function when a window receives a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-devmodechange">WM_DEVMODECHANGE</a> message. <b>ResetDC</b> can also be used to change the paper orientation or paper bins while printing a document.</para>
      <para>The <b>ResetDC</b> function cannot be used to change the driver name, device name, or the output port. When the user changes the port connection or device name, the application must delete the original DC and create a new DC with the new information.</para>
      <para>An application can pass an information DC to the <b>ResetDC</b> function. In that situation, <b>ResetDC</b> will always return a printer DC.</para>
      <para>
        <b>ICM:</b> The color profile of the DC specified by the <i>hdc</i> parameter will be reset based on the information contained in the <b>lpInitData</b> member of the <see cref="DEVMODE" /> structure.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines ResetDC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DEVMODE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="DeviceCapabilities" />
    <seealso cref="Escape" />
  </member>
  <member name="Windows.ResizePalette">
    <summary>
      <para>The <b>ResizePalette</b> function increases or decreases the size of a logical palette based on the specified value.</para>
    </summary>
    <param name="hpal">
      <para>A handle to the palette to be changed.</para>
    </param>
    <param name="n">
      <para>The number of entries in the palette after it has been resized.</para>
      <para>The number of entries is limited to 1024.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>If an application calls <b>ResizePalette</b> to reduce the size of the palette, the entries remaining in the resized palette are unchanged. If the application calls <b>ResizePalette</b> to enlarge the palette, the additional palette entries are set to black (the red, green, and blue values are all 0) and their flags are set to zero.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
  </member>
  <member name="Windows.RestoreDC">
    <summary>
      <para>The <b>RestoreDC</b> function restores a device context (DC) to the specified state. The DC is restored by popping state information off a stack created by earlier calls to the <see cref="SaveDC" /> function.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="nSavedDC">
      <para>The saved state to be restored. If this parameter is positive, <i>nSavedDC</i> represents a specific instance of the state to be restored. If this parameter is negative, <i>nSavedDC</i> represents an instance relative to the current state. For example, -1 restores the most recently saved state.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Each DC maintains a stack of saved states. The <see cref="SaveDC" /> function pushes the current state of the DC onto its stack of saved states. That state can be restored only to the same DC from which it was created. After a state is restored, the saved state is destroyed and cannot be reused. Furthermore, any states saved after the restored state was created are also destroyed and cannot be used. In other words, the <b>RestoreDC</b> function pops the restored state (and any subsequent states) from the state information stack.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SaveDC" />
  </member>
  <member name="Windows.RGB">
    <summary>
      <para>The <b>RGB</b> macro selects a red, green, blue (RGB) color based on the arguments supplied and the color capabilities of the output device.</para>
    </summary>
    <param name="r">
      <para>The intensity of the red color.</para>
    </param>
    <param name="g">
      <para>The intensity of the green color.</para>
    </param>
    <param name="b">
      <para>The intensity of the blue color.</para>
    </param>
    <remarks>
      <para>The intensity for each argument is in the range 0 through 255. If all three intensities are zero, the result is black. If all three intensities are 255, the result is white.</para>
      <para>To extract the individual values for the red, green, and blue components of a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="GetRValue" />, <see cref="GetGValue" />, and <see cref="GetBValue" /> macros, respectively.</para>
      <para>When creating or examining a logical palette, use the <see cref="RGBQUAD" /> structure to define color values and examine individual component values. For more information about using color values in a color palette, see the descriptions of the <a href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</a> and <see cref="PALETTERGB" /> macros.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-macros">Color Macros</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetBValue" />
    <seealso cref="GetGValue" />
    <seealso cref="GetRValue" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162770(v=vs.85)">PALETTEINDEX</seealso>
    <seealso cref="PALETTERGB" />
    <seealso cref="RGBQUAD" />
  </member>
  <member name="Windows.RoundRect">
    <summary>
      <para>The <b>RoundRect</b> function draws a rectangle with rounded corners. The rectangle is outlined by using the current pen and filled by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="left">
      <para>The x-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="top">
      <para>The y-coordinate, in logical coordinates, of the upper-left corner of the rectangle.</para>
    </param>
    <param name="right">
      <para>The x-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</para>
    </param>
    <param name="bottom">
      <para>The y-coordinate, in logical coordinates, of the lower-right corner of the rectangle.</para>
    </param>
    <param name="width">
      <para>The width, in logical coordinates, of the ellipse used to draw the rounded corners.</para>
    </param>
    <param name="height">
      <para>The height, in logical coordinates, of the ellipse used to draw the rounded corners.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The current position is neither used nor updated by this function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-filled-shapes">Using Filled Shapes</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shape-functions">Filled Shape Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/filled-shapes">Filled Shapes Overview</seealso>
    <seealso cref="Rectangle " />
  </member>
  <member name="Windows.SaveDC">
    <summary>
      <para>The <b>SaveDC</b> function saves the current state of the specified device context (DC) by copying data describing selected objects and graphic modes (such as the bitmap, brush, palette, font, pen, region, drawing mode, and mapping mode) to a context stack.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC whose state is to be saved.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies the saved state.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>SaveDC</b> function can be used any number of times to save any number of instances of the DC state.</para>
      <para>A saved state can be restored by using the <see cref="RestoreDC" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="RestoreDC " />
  </member>
  <member name="Windows.ScaleViewportExtEx">
    <summary>
      <para>The <b>ScaleViewportExtEx</b> function modifies the viewport for a device context using the ratios formed by the specified multiplicands and divisors.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="xn">
      <para>The amount by which to multiply the current horizontal extent.</para>
    </param>
    <param name="dx">
      <para>The amount by which to divide the current horizontal extent.</para>
    </param>
    <param name="yn">
      <para>The amount by which to multiply the current vertical extent.</para>
    </param>
    <param name="yd">
      <para>The amount by which to divide the current vertical extent.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the previous viewport extents, in device units. If <i>lpSize</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The viewport extents are modified as follows:</para>
      <code>
    xNewVE = (xOldVE * Xnum) / Xdenom
    yNewVE = (yOldVE * Ynum) / Ydenom

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportExtEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.ScaleWindowExtEx">
    <summary>
      <para>The <b>ScaleWindowExtEx</b> function modifies the window for a device context using the ratios formed by the specified multiplicands and divisors.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="xn">
      <para>The amount by which to multiply the current horizontal extent.</para>
    </param>
    <param name="xd">
      <para>The amount by which to divide the current horizontal extent.</para>
    </param>
    <param name="yn">
      <para>The amount by which to multiply the current vertical extent.</para>
    </param>
    <param name="yd">
      <para>The amount by which to divide the current vertical extent.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the previous window extents, in logical units. If <i>lpSize</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The window extents are modified as follows:</para>
      <code>
    xNewWE = (xOldWE * Xnum) / Xdenom
    yNewWE = (yOldWE * Ynum) / Ydenom

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWindowExtEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.SelectClipPath">
    <summary>
      <para>The <b>SelectClipPath</b> function selects the current path as a clipping region for a device context, combining the new region with any existing clipping region using the specified mode.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context of the path.</para>
    </param>
    <param name="mode">
      <para>The way to use the path. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>RGN_AND</b>
          </description>
          <description>
            <para>The new clipping region includes the intersection (overlapping areas) of the current clipping region and the current path.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_COPY</b>
          </description>
          <description>
            <para>The new clipping region is the current path.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_DIFF</b>
          </description>
          <description>
            <para>The new clipping region includes the areas of the current clipping region with those of the current path excluded.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_OR</b>
          </description>
          <description>
            <para>The new clipping region includes the union (combined areas) of the current clipping region and the current path.</para>
          </description>
        </item>
        <item>
          <description>
            <b>RGN_XOR</b>
          </description>
          <description>
            <para>The new clipping region includes the union of the current clipping region and the current path but without the overlapping areas.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The device context identified by the <i>hdc</i> parameter must contain a closed path.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-clipping">Using Clipping</a>.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="EndPath" />
  </member>
  <member name="Windows.SelectClipRgn">
    <summary>
      <para>The <b>SelectClipRgn</b> function selects a region as the current clipping region for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hrgn">
      <para>A handle to the region to be selected.</para>
    </param>
    <returns>
      <para>The return value specifies the region's complexity and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred. (The previous clipping region is unaffected.)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Only a copy of the selected region is used. The region itself can be selected for any number of other device contexts or it can be deleted.</para>
      <para>The <b>SelectClipRgn</b> function assumes that the coordinates for a region are specified in device units.</para>
      <para>To remove a device-context's clipping region, specify a <b>NULL</b> region handle.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/clipping-output">Clipping Output</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="ExtSelectClipRgn" />
  </member>
  <member name="Windows.SelectObject">
    <summary>
      <para>The <b>SelectObject</b> function selects an object into the specified device context (DC). The new object replaces the previous object of the same type.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="h">
      <para>A handle to the object to be selected. The specified object must have been created by using one of the following functions.</para>
      <list type="table">
        <listheader>
          <description>Object</description>
          <description>Functions</description>
        </listheader>
        <item>
          <description>
            <b>Bitmap</b>
          </description>
          <description>
            <para>
              <see cref="CreateBitmap" />, <see cref="CreateBitmapIndirect" />, <see cref="CreateCompatibleBitmap" />, <see cref="CreateDIBitmap" />, <see cref="CreateDIBSection" /></para>
            <para>Bitmaps can only be selected into memory DC's. A single bitmap cannot be selected into more than one DC at the same time.</para>
          </description>
        </item>
        <item>
          <description>
            <b>Brush</b>
          </description>
          <description>
            <para>
              <see cref="CreateBrushIndirect" />, <see cref="CreateDIBPatternBrush" />, <see cref="CreateDIBPatternBrushPt" />, <see cref="CreateHatchBrush" />, <see cref="CreatePatternBrush" />, <see cref="CreateSolidBrush" /></para>
          </description>
        </item>
        <item>
          <description>
            <b>Font</b>
          </description>
          <description>
            <para>
              <see cref="CreateFont" />, <see cref="CreateFontIndirect" /></para>
          </description>
        </item>
        <item>
          <description>
            <b>Pen</b>
          </description>
          <description>
            <para>
              <see cref="CreatePen" />, <see cref="CreatePenIndirect" /></para>
          </description>
        </item>
        <item>
          <description>
            <b>Region</b>
          </description>
          <description>
            <para>
              <see cref="CombineRgn" />, <see cref="CreateEllipticRgn" />, <see cref="CreateEllipticRgnIndirect" />, <see cref="CreatePolygonRgn" />, <see cref="CreateRectRgn" />, <see cref="CreateRectRgnIndirect" /></para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced. If the selected object is a region and the function succeeds, the return value is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>SIMPLEREGION</description>
          <description>Region consists of a single rectangle.</description>
        </item>
        <item>
          <description>COMPLEXREGION</description>
          <description>Region consists of more than one rectangle.</description>
        </item>
        <item>
          <description>NULLREGION</description>
          <description>Region is empty.</description>
        </item>
      </list>
      <para>If an error occurs and the selected object is not a region, the return value is <b>NULL</b>. Otherwise, it is HGDI_ERROR.</para>
    </returns>
    <remarks>
      <para>This function returns the previously selected object of the specified type. An application should always replace a new object with the original, default object after it has finished drawing with the new object.</para>
      <para>An application cannot select a single bitmap into more than one DC at a time.</para>
      <para>
        <b>ICM:</b> If the object being selected is a brush or a pen, color management is performed.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a>.</para>
    </remarks>
    <seealso cref="CombineRgn" />
    <seealso cref="CreateBitmap" />
    <seealso cref="CreateBitmapIndirect" />
    <seealso cref="CreateBrushIndirect" />
    <seealso cref="CreateCompatibleBitmap" />
    <seealso cref="CreateDIBPatternBrush" />
    <seealso cref="CreateDIBitmap" />
    <seealso cref="CreateEllipticRgn" />
    <seealso cref="CreateEllipticRgnIndirect" />
    <seealso cref="CreateFont" />
    <seealso cref="CreateFontIndirect" />
    <seealso cref="CreateHatchBrush" />
    <seealso cref="CreatePatternBrush" />
    <seealso cref="CreatePen" />
    <seealso cref="CreatePenIndirect" />
    <seealso cref="CreatePolygonRgn" />
    <seealso cref="CreateRectRgn" />
    <seealso cref="CreateRectRgnIndirect" />
    <seealso cref="CreateSolidBrush" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="SelectClipRgn" />
    <seealso cref="SelectPalette" />
  </member>
  <member name="Windows.SelectPalette">
    <summary>
      <para>The <b>SelectPalette</b> function selects the specified logical palette into a device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="hPal">
      <para>A handle to the logical palette to be selected.</para>
    </param>
    <param name="bForceBkgd">
      <para>Specifies whether the logical palette is forced to be a background palette. If this value is <b>TRUE</b>, the <see cref="RealizePalette" /> function causes the logical palette to be mapped to the colors already in the physical palette in the best possible way. This is always done, even if the window for which the palette is realized belongs to a thread without active focus.</para>
      <para>If this value is <b>FALSE</b>, <see cref="RealizePalette" /> causes the logical palette to be copied into the device palette when the application is in the foreground. (If the <i>hdc</i> parameter is a memory device context, this parameter is ignored.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the device context's previous logical palette.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>An application can select a logical palette into more than one device context only if device contexts are compatible. Otherwise <b>SelectPalette</b> fails. To create a device context that is compatible with another device context, call <see cref="CreateCompatibleDC" /> with the first device context as the parameter. If a logical palette is selected into more than one device context, changes to the logical palette will affect all device contexts for which it is selected.</para>
      <para>An application might call the <b>SelectPalette</b> function with the <i>bForceBackground</i> parameter set to <b>TRUE</b> if the child windows of a top-level window each realize their own palettes. However, only the child window that needs to realize its palette must set <i>bForceBackground</i> to <b>TRUE</b>; other child windows must set this value to <b>FALSE</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="CreateCompatibleDC" />
    <seealso cref="CreatePalette" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="RealizePalette" />
  </member>
  <member name="Windows.SetAbortProc">
    <summary>
      <para>The <b>SetAbortProc</b> function sets the application-defined abort function that allows a print job to be canceled during spooling.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context for the print job.</para>
    </param>
    <param name="proc">
      <para>Pointer to the application-defined abort function. For more information about the callback function, see the <a href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-abortproc">AbortProc</a> callback function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero.</para>
      <para>If the function fails, the return value is SP_ERROR.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/preparing-to-print">How to Collect Print Job  Information from the User</a>.</para>
    </remarks>
    <seealso cref="AbortDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/wingdi/nc-wingdi-abortproc">AbortProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
  </member>
  <member name="Windows.SetArcDirection">
    <summary>
      <para>The <b>SetArcDirection</b> sets the drawing direction to be used for arc and rectangle functions.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="dir">
      <para>The new arc direction. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AD_COUNTERCLOCKWISE</b>
          </description>
          <description>
            <para>Figures drawn counterclockwise.</para>
          </description>
        </item>
        <item>
          <description>
            <b>AD_CLOCKWISE</b>
          </description>
          <description>
            <para>Figures drawn clockwise.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the old arc direction.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The default direction is counterclockwise.</para>
      <para>The <b>SetArcDirection</b> function specifies the direction in which the following functions draw:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="Arc" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ArcTo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Chord" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Ellipse" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Pie" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Rectangle" />
          </description>
        </item>
        <item>
          <description>
            <see cref="RoundRect" />
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/line-and-curve-functions">Line and Curve Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/lines-and-curves">Lines and Curves Overview</seealso>
  </member>
  <member name="Windows.SetBitmapBits">
    <summary>
      <para>The <b>SetBitmapBits</b> function sets the bits of color data for a bitmap to the specified values.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="SetDIBits" /> function.</para>
    </summary>
    <param name="hbm">
      <para>A handle to the bitmap to be set. This must be a compatible bitmap (DDB).</para>
    </param>
    <param name="cb">
      <para>The number of bytes pointed to by the <i>lpBits</i> parameter.</para>
    </param>
    <param name="pvBits">
      <para>A pointer to an array of bytes that contain color data for the specified bitmap.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes used in setting the bitmap bits.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The array identified by <i>lpBits</i> must be WORD aligned.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetBitmapBits" />
    <seealso cref="SetDIBits" />
  </member>
  <member name="Windows.SetBitmapDimensionEx">
    <summary>
      <para>The <b>SetBitmapDimensionEx</b> function assigns preferred dimensions to a bitmap. These dimensions can be used by applications; however, they are not used by the system.</para>
    </summary>
    <param name="hbm">
      <para>A handle to the bitmap. The bitmap cannot be a DIB-section bitmap.</para>
    </param>
    <param name="w">
      <para>The width, in 0.1-millimeter units, of the bitmap.</para>
    </param>
    <param name="h">
      <para>The height, in 0.1-millimeter units, of the bitmap.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure to receive the previous dimensions of the bitmap. This pointer can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can retrieve the dimensions assigned to a bitmap with the <b>SetBitmapDimensionEx</b> function by calling the <see cref="GetBitmapDimensionEx" /> function.</para>
      <para>The bitmap identified by <i>hBitmap</i> cannot be a DIB section, which is a bitmap created by the <see cref="CreateDIBSection" /> function. If the bitmap is a DIB section, the <b>SetBitmapDimensionEx</b> function fails.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateDIBSection" />
    <seealso cref="GetBitmapDimensionEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
  </member>
  <member name="Windows.SetBkColor">
    <summary>
      <para>The <b>SetBkColor</b> function sets the current background color to the specified color value, or to the nearest physical color if the device cannot represent the specified color value.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="color">
      <para>The new background color. To make a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous background color as a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>This function fills the gaps between styled lines drawn using a pen created by the <see cref="CreatePen" /> function; it does not fill the gaps between styled lines drawn using a pen created by the <see cref="ExtCreatePen" /> function. The <b>SetBkColor</b> function also sets the background colors for <see cref="TextOut" /> and <see cref="ExtTextOut" />.</para>
      <para>If the background mode is OPAQUE, the background color is used to fill gaps between styled lines, gaps between hatched lines in brushes, and character cells. The background color is also used when converting bitmaps from color to monochrome and vice versa.</para>
      <h4>Examples</h4>
      <para>For an example, see "Example of Owner-Drawn Menu Items" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="CreatePen" />
    <seealso cref="ExtCreatePen" />
    <seealso cref="GetBKColor" />
    <seealso cref="GetBkMode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="SetBkMode" />
  </member>
  <member name="Windows.SetBkMode">
    <summary>
      <para>The <b>SetBkMode</b> function sets the background mix mode of the specified device context. The background mix mode is used with text, hatched brushes, and pen styles that are not solid lines.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="mode">
      <para>The background mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>OPAQUE</b>
          </description>
          <description>
            <para>Background is filled with the current background color before the text, hatched brush, or pen is drawn.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TRANSPARENT</b>
          </description>
          <description>
            <para>Background remains untouched.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous background mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>SetBkMode</b> function affects the line styles for lines drawn using a pen created by the <see cref="CreatePen" /> function. <b>SetBkMode</b> does not affect lines drawn using a pen created by the <see cref="ExtCreatePen" /> function.</para>
      <h4>Examples</h4>
      <para>To see how to make the background of a  hatch brush transparent or opaque, refer to the example shown in the <see cref="CreateHatchBrush" />   topic.</para>
      <para>The next example draws a string 36 times, rotating it 10 degrees
counterclockwise each time. It also sets the background mode to transparent to make the text visible.</para>
      <code>#include "strsafe.h"
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int wmId, wmEvent;
    PAINTSTRUCT ps;
    HDC hdc;

    switch (message)
    {

    case WM_PAINT:
        {
        hdc = BeginPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        RECT rc;
        int angle;
        HGDIOBJ hfnt, hfntPrev;
        WCHAR lpszRotate[22] = TEXT("String to be rotated.");
        HRESULT hr;
        size_t pcch = 22;

// Allocate memory for a LOGFONT structure.

PLOGFONT plf = (PLOGFONT) LocalAlloc(LPTR, sizeof(LOGFONT));


// Specify a font typeface name and weight.

hr = StringCchCopy(plf-&gt;lfFaceName, 6, TEXT("Arial"));
if (FAILED(hr))
{
// TODO: write error handler
}

plf-&gt;lfWeight = FW_NORMAL;

// Retrieve the client-rectangle dimensions.

GetClientRect(hWnd, &amp;amp;amp;amp;amp;amp;rc);

// Set the background mode to transparent for the
// text-output operation.

SetBkMode(hdc, TRANSPARENT);

// Draw the string 36 times, rotating 10 degrees
// counter-clockwise each time.

for (angle = 0; angle &lt; 3600; angle += 100)
{
    plf-&gt;lfEscapement = angle;
    hfnt = CreateFontIndirect(plf);
    hfntPrev = SelectObject(hdc, hfnt);

    //
    // The StringCchLength call is fitted to the lpszRotate string
    //
    hr = StringCchLength(lpszRotate, 22, &amp;amp;amp;amp;amp;amp;pcch);
    if (FAILED(hr))
    {
    // TODO: write error handler
    }
    TextOut(hdc, rc.right / 2, rc.bottom / 2,
        lpszRotate, pcch);
    SelectObject(hdc, hfntPrev);
    DeleteObject(hfnt);
}

// Reset the background mode to its default.

SetBkMode(hdc, OPAQUE);

// Free the memory allocated for the LOGFONT structure.

LocalFree((LOCALHANDLE) plf);
        EndPaint(hWnd, &amp;amp;amp;amp;amp;amp;ps);
        break;
        }
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

</code>
    </remarks>
    <seealso cref="CreatePen" />
    <seealso cref="ExtCreatePen" />
    <seealso cref="GetBkMode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
  </member>
  <member name="Windows.SetBoundsRect">
    <summary>
      <para>The <b>SetBoundsRect</b> function controls the accumulation of bounding rectangle information for the specified device context. The system can maintain a bounding rectangle for all drawing operations. An application can examine and set this rectangle. The drawing boundaries are useful for invalidating bitmap caches.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for which to accumulate bounding rectangles.</para>
    </param>
    <param name="lprect">
      <para>A pointer to a <see cref="RECT" /> structure used to set the bounding rectangle. Rectangle dimensions are in logical coordinates. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="flags">
      <para>Specifies how the new rectangle will be combined with the accumulated rectangle. This parameter can be one of more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DCB_ACCUMULATE</b>
          </description>
          <description>
            <para>Adds the rectangle specified by the <i>lprcBounds</i> parameter to the bounding rectangle (using a rectangle union operation). Using both DCB_RESET and DCB_ACCUMULATE sets the bounding rectangle to the rectangle specified by the <i>lprcBounds</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DCB_DISABLE</b>
          </description>
          <description>
            <para>Turns off boundary accumulation.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DCB_ENABLE</b>
          </description>
          <description>
            <para>Turns on boundary accumulation, which is disabled by default.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DCB_RESET</b>
          </description>
          <description>
            <para>Clears the bounding rectangle.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous state of the bounding rectangle. This state can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>DCB_DISABLE</description>
          <description>Boundary accumulation is off.</description>
        </item>
        <item>
          <description>DCB_ENABLE</description>
          <description>Boundary accumulation is on. DCB_ENABLE and DCB_DISABLE are mutually exclusive.</description>
        </item>
        <item>
          <description>DCB_RESET</description>
          <description>Bounding rectangle is empty.</description>
        </item>
        <item>
          <description>DCB_SET</description>
          <description>Bounding rectangle is not empty. DCB_SET and DCB_RESET are mutually exclusive.</description>
        </item>
      </list>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The DCB_SET value is a combination of the bit values DCB_ACCUMULATE and DCB_RESET. Applications that check the DCB_RESET bit to determine whether the bounding rectangle is empty must also check the DCB_ACCUMULATE bit. The bounding rectangle is empty only if the DCB_RESET bit is 1 and the DCB_ACCUMULATE bit is 0.</para>
    </remarks>
    <seealso cref="GetBoundsRect" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
    <seealso cref="RECT" />
  </member>
  <member name="Windows.SetBrushOrgEx">
    <summary>
      <para>The <b>SetBrushOrgEx</b> function sets the brush origin that GDI assigns to the next brush an application selects into the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in device units, of the new brush origin. If this value is greater than the brush width, its value is reduced using the modulus operator (<i>nXOrg</i><b>mod</b> brush width).</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in device units, of the new brush origin. If this value is greater than the brush height, its value is reduced using the modulus operator (<i>nYOrg</i><b>mod</b> brush height).</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the previous brush origin.</para>
      <para>This parameter can be <b>NULL</b> if the previous brush origin is not required.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A brush is a bitmap that the system uses to paint the interiors of filled shapes.</para>
      <para>The brush origin is a pair of coordinates specifying the location of one pixel in the bitmap. The default brush origin coordinates are (0,0). For horizontal coordinates, the value 0 corresponds to the leftmost column of pixels; the width corresponds to the rightmost column. For vertical coordinates, the value 0 corresponds to the uppermost row of pixels; the height corresponds to the lowermost row.</para>
      <para>The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface. The brush origin that is set with this call is relative to the upper-left corner of the client area.</para>
      <para>An application should call <b>SetBrushOrgEx</b> after setting the bitmap stretching mode to HALFTONE by using <see cref="SetStretchBltMode" />. This must be done to avoid brush misalignment.</para>
      <para>The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brush-functions">Brush Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/brushes">Brushes Overview</seealso>
    <seealso cref="GetBrushOrgEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="SelectObject" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="UnrealizeObject" />
  </member>
  <member name="Windows.SetColorAdjustment">
    <summary>
      <para>The <b>SetColorAdjustment</b> function sets the color adjustment values for a device context (DC) using the specified values.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpca">
      <para>A pointer to a <see cref="COLORADJUSTMENT" /> structure containing the color adjustment values.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The color adjustment values are used to adjust the input color of the source bitmap for calls to the <see cref="StretchBlt" /> and <see cref="StretchDIBits" /> functions when HALFTONE mode is set.</para>
    </remarks>
    <seealso cref="COLORADJUSTMENT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetColorAdjustment" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.SetColorSpace">
    <summary>
      <para>The <b>SetColorSpace</b> function defines the input <a href="https://docs.microsoft.com//windows/win32/wcs/c#color-space">color space</a> for a given device context.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the handle to a device context.</para>
    </param>
    <param name="hcs">
      <para>Identifies handle to the color space to set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a handle to the <i>hColorSpace</i> being replaced.</para>
      <para>If this function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.SetDCBrushColor">
    <summary>
      <para>
        <b>SetDCBrushColor</b> function sets the current device context (DC) brush color to the specified color value. If the device cannot represent the specified color value, the color is set to the nearest physical color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="color">
      <para>The new brush color.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous DC brush color as a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>When the stock DC_BRUSH is selected in a DC, all the subsequent drawings will be done using the DC brush color until the stock brush is deselected. The default DC_BRUSH color is WHITE.</para>
      <para>The function returns the previous DC_BRUSH color, even if the stock brush DC_BRUSH is not selected in the DC: however, this will not be used in drawing operations until the stock DC_BRUSH is selected in the DC.</para>
      <para>The <see cref="GetStockObject" /> function with an argument of DC_BRUSH or DC_PEN can be used interchangeably with the <see cref="SetDCPenColor" /> and <b>SetDCBrushColor</b> functions.</para>
      <para>
        <b>ICM:</b> Color management is performed if ICM is enabled.</para>
      <h4>Examples</h4>
      <para>For an example of setting colors, see <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetDCBrushColor " />
  </member>
  <member name="Windows.SetDCPenColor">
    <summary>
      <para>
        <b>SetDCPenColor</b> function sets the current device context (DC) pen color to the specified color value. If the device cannot represent the specified color value, the color is set to the nearest physical color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="color">
      <para>The new pen color.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous DC pen color as a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value. If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>The function returns the previous DC_PEN color, even if the stock pen DC_PEN is not selected in the DC; however, this will not be used in drawing operations until the stock DC_PEN is selected in the DC.</para>
      <para>The <see cref="GetStockObject" /> function with an argument of DC_BRUSH or DC_PEN can be used interchangeably with the <b>SetDCPenColor</b> and <see cref="SetDCBrushColor" /> functions.</para>
      <para>
        <b>ICM:</b> Color management is performed if ICM is enabled.</para>
      <h4>Examples</h4>
      <para>For an example of setting colors, see <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-pen-or-brush-color">Setting the Pen or Brush Color</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetDCPenColor " />
  </member>
  <member name="Windows.SetDeviceGammaRamp">
    <summary>
      <para>The <b>SetDeviceGammaRamp</b> function sets the <a href="https://docs.microsoft.com//windows/win32/wcs/g">gamma ramp</a> on direct color display boards having drivers that support downloadable gamma ramps in hardware.</para>
      <blockquote>
        <para>[!IMPORTANT]
We strongly recommend that you don't use this API. Use of this API is subject to major limitations:</para>
      </blockquote>
      <blockquote>
        <list type="bullet">
          <item>
            <description>
              <b>SetDeviceGammaRamp</b> implements heuristics to check whether a provided ramp will result in an unreadable screen. If a ramp violates those heuristics, then the function fails silently (that is, it returns <b>TRUE</b>, but it doesn't set your ramp). For that reason, you can't expect to use this function to set <i>just any arbitrary</i> gamma ramp. In particular, the heuristics prevent ramps that would result in nearly all pixels approaching a single value (such as fullscreen black/white) as this may prevent a user from recovering the screen.</description>
          </item>
        </list>
      </blockquote>
      <blockquote>
        <list type="bullet">
          <item>
            <description>Because of the function's global nature, any other application on the system could, at any time, overwrite any ramp that you've set. In some cases the operating system itself may reserve the use of this function, causing any existing ramp to be overwritten. The gamma ramp is also reset on most display events (connecting/disconnecting a monitor, resolution changes, etc.). So you can't be certain that any ramp you set is in effect.</description>
          </item>
        </list>
      </blockquote>
      <blockquote>
        <list type="bullet">
          <item>
            <description>This API has undefined behavior in HDR modes.</description>
          </item>
        </list>
      </blockquote>
      <blockquote>
        <list type="bullet">
          <item>
            <description>This API has undefined interaction with both built-in and third-party color calibration solutions.</description>
          </item>
        </list>
      </blockquote>
      <blockquote>
        <para>For color calibration, we recommend that you create an International Color Consortium (ICC) profile, and let the OS apply the profile. For advanced original equipment manufacturer (OEM) scenarios, there's a device driver model that you can use to customize color calibration more directly. See the <a href="https://docs.microsoft.com//windows/win32/wcs/windows-color-system">Windows Color System</a> for information on managing color profiles.</para>
      </blockquote>
      <blockquote>
        <para>For blue light filtering, Windows now provides built-in support called <a href="https://support.microsoft.com/help/4027563/windows-10-set-your-display-for-night-time">Night Light</a>. We recommend directing users to this feature.</para>
      </blockquote>
      <blockquote>
        <para>For color adaptation (for example, adjusting color calibration based on ambient light sensors), Windows now provides built-in support, which we recommend for use by OEMs.</para>
      </blockquote>
      <blockquote>
        <para>For custom filter effects, there are a variety of built-in accessibility <a href="https://support.microsoft.com/help/4344736/windows-10-use-color-filters">color filters</a> to help with a range of cases.</para>
      </blockquote>
    </summary>
    <param name="hdc">
      <para>Specifies the device context of the direct color display board in question.</para>
    </param>
    <param name="lpRamp">
      <para>Pointer to a buffer containing the gamma ramp to be set. The gamma ramp is specified in three arrays of 256 <b>WORD</b> elements each, which contain the mapping between RGB values in the frame buffer and digital-analog-converter (<i>DAC</i> ) values. The sequence of the arrays is red, green, blue. The RGB values must be stored in the most significant bits of each WORD to increase DAC independence.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct color video boards support loadable gamma ramps. <b>SetDeviceGammaRamp</b> succeeds only for devices with drivers that support downloadable gamma ramps in hardware.</para>
      <blockquote>
        <para>[!NOTE]
This API can take a non-trivial amount of time to execute. It may take as long as 200ms to return on some hardware.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
  </member>
  <member name="Windows.SetDIBColorTable">
    <summary>
      <para>The <b>SetDIBColorTable</b> function sets RGB (red, green, blue) color values in a range of entries in the color table of the DIB that is currently selected into a specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A device context. A DIB must be selected into this device context.</para>
    </param>
    <param name="iStart">
      <para>A zero-based color table index that specifies the first color table entry to set.</para>
    </param>
    <param name="cEntries">
      <para>The number of color table entries to set.</para>
    </param>
    <param name="prgbq">
      <para>A pointer to an array of <see cref="RGBQUAD" /> structures containing new color information for the DIB's color table.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of color table entries that the function sets.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This function should be called to set the color table for DIBs that use 1, 4, or 8 bpp. The <b>BitCount</b> member of a bitmap's associated bitmap information header structure.</para>
      <para>
        <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER
</a> structure specifies the number of bits-per-pixel. Device-independent bitmaps with a <b>biBitCount</b> value greater than 8 do not have a color table.</para>
      <para>The <b>bV5BitCount</b> member of a bitmap's associated <see cref="BITMAPV5HEADER" /> structure specifies the number of bits-per-pixel. Device-independent bitmaps with a <b>bV5BitCount</b> value greater than 8 do not have a color table.</para>
      <para>
        <b>ICM:</b> No color management is performed.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER
</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateDIBSection " />
    <seealso cref="DIBSECTION " />
    <seealso cref="GetDIBColorTable " />
    <seealso cref="GetObject " />
    <seealso cref="RGBQUAD " />
  </member>
  <member name="Windows.SetDIBits">
    <summary>
      <para>The <b>SetDIBits</b> function sets the pixels in a compatible bitmap (DDB) using the color data found in the specified DIB.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context.</para>
    </param>
    <param name="hbm">
      <para>A handle to the compatible bitmap (DDB) that is to be altered using the color data from the specified DIB.</para>
    </param>
    <param name="start">
      <para>The starting scan line for the device-independent color data in the array pointed to by the <i>lpvBits</i> parameter.</para>
    </param>
    <param name="cLines">
      <para>The number of scan lines found in the array containing device-independent color data.</para>
    </param>
    <param name="lpBits">
      <para>A pointer to the DIB color data, stored as an array of bytes. The format of the bitmap values depends on the <b>biBitCount</b> member of the <see cref="BITMAPINFO" /> structure pointed to by the <i>lpbmi</i> parameter.</para>
    </param>
    <param name="lpbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that contains information about the DIB.</para>
    </param>
    <param name="ColorUse">
      <para>Indicates whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure was provided and, if so, whether <b>bmiColors</b> contains explicit red, green, blue (RGB) values or palette indexes. The <i>fuColorUse</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>The color table consists of an array of 16-bit indexes into the logical palette of the device context identified by the <i>hdc</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>The color table is provided and contains literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of scan lines copied.</para>
      <para>If the function fails, the return value is zero.</para>
      <para>This can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Optimal bitmap drawing speed is obtained when the bitmap bits are indexes into the system palette.</para>
      <para>Applications can retrieve the system palette colors and indexes by calling the <see cref="GetSystemPaletteEntries" /> function. After the colors and indexes are retrieved, the application can create the DIB. For more information, see <a href="https://docs.microsoft.com//windows/desktop/gdi/system-palette">System Palette</a>.</para>
      <para>The device context identified by the <i>hdc</i> parameter is used only if the DIB_PAL_COLORS constant is set for the <i>fuColorUse</i> parameter; otherwise it is ignored.</para>
      <para>The bitmap identified by the <i>hbmp</i> parameter must not be selected into a device context when the application calls this function.</para>
      <para>The scan lines must be aligned on a <b>DWORD</b> except for RLE-compressed bitmaps.</para>
      <para>The origin for bottom-up DIBs is the lower-left corner of the bitmap; the origin for top-down DIBs is the upper-left corner of the bitmap.</para>
      <para>
        <b>ICM:</b> Color management is performed if color management has been enabled with a call to <see cref="SetICMMode" /> with the <i>iEnableICM</i> parameter set to ICM_ON. If the bitmap specified by <i>lpbmi</i> has a <see cref="BITMAPV4HEADER" /> that specifies the gamma and endpoints members, or a <see cref="BITMAPV5HEADER" /> that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space.</para>
    </remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="GetSystemPaletteEntries" />
  </member>
  <member name="Windows.SetDIBitsToDevice">
    <summary>
      <para>The <b>SetDIBitsToDevice</b> function sets the pixels in the specified rectangle on the device that is associated with the destination device context using color data from a DIB, JPEG, or PNG image.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="xDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="w">
      <para>The width, in logical units, of the image.</para>
    </param>
    <param name="h">
      <para>The height, in logical units, of the image.</para>
    </param>
    <param name="xSrc">
      <para>The x-coordinate, in logical units, of the lower-left corner of the image.</para>
    </param>
    <param name="ySrc">
      <para>The y-coordinate, in logical units, of the lower-left corner of the image.</para>
    </param>
    <param name="StartScan">
      <para>The starting scan line in the image.</para>
    </param>
    <param name="cLines">
      <para>The number of DIB scan lines contained in the array pointed to by the <i>lpvBits</i> parameter.</para>
    </param>
    <param name="lpvBits">
      <para>A pointer to the color data stored as an array of bytes. For more information, see the following Remarks section.</para>
    </param>
    <param name="lpbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that contains information about the DIB.</para>
    </param>
    <param name="ColorUse">
      <para>Indicates whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure contains explicit red, green, blue (RGB) values or indexes into a palette. For more information, see the following Remarks section.</para>
      <para>The <i>fuColorUse</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>The color table consists of an array of 16-bit indexes into the currently selected logical palette.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>The color table contains literal RGB values.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of scan lines set.</para>
      <para>If zero scan lines are set (such as when <i>dwHeight</i> is 0) or the function fails, the function returns zero.</para>
      <para>If the driver cannot support the JPEG or PNG file image passed to <b>SetDIBitsToDevice</b>, the function will fail and return GDI_ERROR. If failure does occur, the application must fall back on its own JPEG or PNG support to decompress the image into a bitmap, and then pass the bitmap to <b>SetDIBitsToDevice</b>.</para>
    </returns>
    <remarks>
      <para>Optimal bitmap drawing speed is obtained when the bitmap bits are indexes into the system palette.</para>
      <para>Applications can retrieve the system palette colors and indexes by calling the <see cref="GetSystemPaletteEntries" /> function. After the colors and indexes are retrieved, the application can create the DIB. For more information about the system palette, see <a href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors</a>.</para>
      <para>The scan lines must be aligned on a <b>DWORD</b> except for RLE-compressed bitmaps.</para>
      <para>The origin of a bottom-up DIB is the lower-left corner of the bitmap; the origin of a top-down DIB is the upper-left corner.</para>
      <para>To reduce the amount of memory required to set bits from a large DIB on a device surface, an application can band the output by repeatedly calling <b>SetDIBitsToDevice</b>, placing a different portion of the bitmap into the <i>lpvBits</i> array each time. The values of the <i>uStartScan</i> and <i>cScanLines</i> parameters identify the portion of the bitmap contained in the <i>lpvBits</i> array.</para>
      <para>The <b>SetDIBitsToDevice</b> function returns an error if it is called by a process that is running in the background while a full-screen MS-DOS session runs in the foreground.</para>
      <list type="bullet">
        <item>
          <description>If the <b>biCompression</b> member of <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> is BI_JPEG or BI_PNG, <i>lpvBits</i> points to a buffer containing a JPEG or PNG image. The <b>biSizeImage</b> member of specifies the size of the buffer. The <i>fuColorUse</i> parameter must be set to DIB_RGB_COLORS.</description>
        </item>
        <item>
          <description>To ensure proper metafile spooling while printing, applications must call the CHECKJPEGFORMAT or CHECKPNGFORMAT escape to verify that the printer recognizes the JPEG or PNG image, respectively, before calling <b>SetDIBitsToDevice</b>.</description>
        </item>
      </list>
      <b>ICM:</b> Color management is performed if color management has been enabled with a call to <see cref="SetICMMode" /> with the <i>iEnableICM</i> parameter set to ICM_ON. If the bitmap specified by <i>lpbmi</i> has a <see cref="BITMAPV4HEADER" /> that specifies the gamma and endpoints members, or a <see cref="BITMAPV5HEADER" /> that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space.
<h4>Examples</h4><para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/testing-a-printer-for-jpeg-or-png-support">Testing a Printer for JPEG or PNG Support</a>.</para></remarks>
    <seealso cref="BITMAPINFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetSystemPaletteEntries" />
    <seealso cref="SetDIBits" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.SetEnhMetaFileBits">
    <summary>
      <para>The <b>SetEnhMetaFileBits</b> function creates a memory-based enhanced-format metafile from the specified data.</para>
    </summary>
    <param name="nSize">
      <para>Specifies the size, in bytes, of the data provided.</para>
    </param>
    <param name="pb">
      <para>Pointer to a buffer that contains enhanced-metafile data. (It is assumed that the data in the buffer was obtained by calling the <see cref="GetEnhMetaFileBits" /> function.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a memory-based enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>The <b>SetEnhMetaFileBits</b> function does not accept metafile data in the Windows format. To import Windows-format metafiles, use the <see cref="SetWinMetaFileBits" /> function.</para>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetEnhMetaFileBits" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.SetGraphicsMode">
    <summary>
      <para>The <b>SetGraphicsMode</b> function sets the graphics mode for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iMode">
      <para>The graphics mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>GM_COMPATIBLE</b>
          </description>
          <description>
            <para>Sets the graphics mode that is compatible with 16-bit Windows. This is the default mode. If this value is specified, the application can only modify the world-to-device transform by calling functions that set window and viewport extents and origins, but not by using <see cref="SetWorldTransform" /> or <see cref="ModifyWorldTransform" />; calls to those functions will fail. Examples of functions that set window and viewport extents and origins are <see cref="SetViewportExtEx" /> and <see cref="SetWindowExtEx" />.</para>
          </description>
        </item>
        <item>
          <description>
            <b>GM_ADVANCED</b>
          </description>
          <description>
            <para>Sets the advanced graphics mode that allows world transformations. This value must be specified if the application will set or modify the world transformation for the specified device context. In this mode all graphics, including text output, fully conform to the world-to-device transformation specified in the device context.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the old graphics mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>There are three areas in which graphics output differs according to the graphics mode:</para>
      <list type="number">
        <item>
          <description>
            <para>Text Output: In the GM_COMPATIBLE mode, TrueType (or vector font) text output behaves much the same way as raster font text output with respect to the world-to-device transformations in the DC. The TrueType text is always written from left to right and right side up, even if the rest of the graphics will be flipped on the x or y axis. Only the height of the TrueType (or vector font) text is scaled. The only way to write text that is not horizontal in the GM_COMPATIBLE mode is to specify nonzero escapement and orientation for the logical font selected in this device context.</para>
            <para>In the GM_ADVANCED mode, TrueType (or vector font) text output fully conforms to the world-to-device transformation in the device context. The raster fonts only have very limited transformation capabilities (stretching by some integer factors). Graphics device interface (GDI) tries to produce the best output it can with raster fonts for nontrivial transformations.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Rectangle Exclusion: If the default GM_COMPATIBLE graphics mode is set, the system excludes bottom and rightmost edges when it draws rectangles.</para>
            <para>The GM_ADVANCED graphics mode is required if applications want to draw rectangles that are lower-right inclusive.</para>
          </description>
        </item>
        <item>
          <description>
            <para>Arc Drawing: If the default GM_COMPATIBLE graphics mode is set, GDI draws arcs using the current arc direction in the device space. With this convention, arcs do not respect page-to-device transforms that require a flip along the x or y axis.</para>
            <para>If the GM_ADVANCED graphics mode is set, GDI always draws arcs in the counterclockwise direction in logical space. This is equivalent to the statement that, in the GM_ADVANCED graphics mode, both arc control points and arcs themselves fully respect the device context's world-to-device transformation.</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-coordinate-spaces-and-transformations">Using Coordinate Spaces and Transformations</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="CreateDC" />
    <seealso cref="GetArcDirection" />
    <seealso cref="GetDC" />
    <seealso cref="GetGraphicsMode" />
    <seealso cref="ModifyWorldTransform" />
    <seealso cref="SetArcDirection" />
    <seealso cref="SetViewportExtent" />
    <seealso cref="SetWindowExtent" />
    <seealso cref="SetWorldTransform" />
  </member>
  <member name="Windows.SetICMMode">
    <summary>
      <para>The <b>SetICMMode</b> function causes Image Color Management to be enabled, disabled, or queried on a given device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Identifies handle to the device context.</para>
    </param>
    <param name="mode">
      <para>Turns on and off image color management. This parameter can take one of the following constant values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ON</b>
          </description>
          <description>
            <para>Turns on color management. Turns off old-style color correction of halftones.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_OFF</b>
          </description>
          <description>
            <para>Turns off color management. Turns on old-style color correction of halftones.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERY</b>
          </description>
          <description>
            <para>Queries the current state of color management.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DONE_OUTSIDEDC</b>
          </description>
          <description>
            <para>Turns off color management inside DC. Under Windows 2000, also turns off old-style color correction of halftones. Not supported under Windows 95.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is a nonzero value.</para>
      <para>If this function fails, the return value is zero.</para>
      <para>If ICM_QUERY is specified and the function succeeds, the nonzero value returned is ICM_ON or ICM_OFF to indicate the current mode.</para>
    </returns>
    <remarks>
      <para>If the system cannot find an ICC color profile to match the state of the device, <b>SetICMMode</b> fails and returns zero.</para>
      <para>Once WCS is enabled for a device context (DC), colors passed into the DC using most Win32 API functions are color matched. The primary exceptions are <b>BitBlt</b> and <b>StretchBlt</b>. The assumption is that when performing a bit block transfer (blit) from one DC to another, the two DCs are already compatible and need no color correction. If this is not the case, color correction may be performed. Specifically, if a device independent bitmap (DIB) is used as the source for a blit, and the blit is performed into a DC that has WCS enabled, color matching will be performed. If this is not what you want, turn WCS off for the destination DC by calling <b>SetICMMode</b> before calling <b>BitBlt</b> or <b>StretchBlt</b>.</para>
      <para>If the <b>CreateCompatibleDC</b> function is used to create a bitmap in a DC, it is possible for the bitmap to be color matched twice, once when it is created and once when a blit is performed. The reason is that a bitmap in a DC created by the <b>CreateCompatibleDC</b> function acquires the current brush, pens, and palette of the source DC. However, WCS will be disabled by default for the new DC. If WCS is later enabled for the new DC by using the <b>SetICMMode</b> function, a color correction will be done. To prevent double color corrections through the use of the <b>CreateCompatibleDC</b> function, use the <b>SetICMMode</b> function to turn WCS off for the source DC before the <b>CreateCompatibleDC</b> function is called.</para>
      <para>When a compatible DC is created from a printer's DC (see <b>CreateCompatibleDC</b> ), the default is for color matching to always be performed if it is enabled for the printer's DC. The default color profile for the printer is used when a blit is performed into the printer's DC using <b>SetDIBitsToDevice</b> or <b>StretchDIBits</b>. If this is not what you want, turn WCS off for the printer's DC by calling <b>SetICMMode</b> before calling <b>SetDIBitsToDevice</b> or <b>StretchDIBits</b>.</para>
      <para>Also, when printing to a printer's DC with WCS turned on, the <b>SetICMMode</b> function needs to be called after every call to the <b>StartPage</b> function to turn back on WCS. The <b>StartPage</b> function calls the <b>RestoreDC</b> and <b>SaveDC</b> functions, which result in WCS being turned off for the printer's DC.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="BitBlt" />
    <seealso cref="CreateCompatibleDC" />
    <seealso cref="SetDIBitsToDevice" />
    <seealso cref="StartPage" />
    <seealso cref="StretchBlt" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.SetICMProfile">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetICMProfileA">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetICMProfileW">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetICMProfile">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetICMProfileA">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetICMProfileW">
    <summary>
      <para>The <b>SetICMProfile</b> function sets a specified color profile as the output profile for a specified device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>Specifies a device context in which to set the color profile.</para>
    </param>
    <param name="lpFileName">
      <para>Specifies the path name of the color profile to be set.</para>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>SetICMProfile</b> associates a color profile with a device context. It becomes the output profile for that device context. The color profile does not have to be associated with any particular device. Device-independent profiles such as sRGB can also be used. If the color profile is not associated with a hardware device, it will be returned by <see cref="GetICMProfile" />, but not by <see cref="EnumICMProfiles" />.</para>
      <para>Note that under Windows 95 or later, the PostScript device driver for printers assumes a CMYK color model. Therefore, all PostScript printers must use a CMYK color profile. Windows 2000 does not have this limitation.</para>
      <para>
        <b>SetICMProfile</b> supports only RGB profiles in compatible DCs.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>SetICMProfileW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines SetICMProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/functions">Functions</seealso>
    <seealso cref="EnumICMProfilesW" />
    <seealso cref="GetICMProfileW" />
  </member>
  <member name="Windows.SetLayout">
    <summary>
      <para>The <b>SetLayout</b> function changes the layout of a device context (DC).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the DC.</para>
    </param>
    <param name="l">
      <para>The DC layout. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LAYOUT_BITMAPORIENTATIONPRESERVED</b>
          </description>
          <description>
            <para>Disables any reflection during <see cref="BitBlt" /> and <see cref="StretchBlt" /> operations.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LAYOUT_RTL</b>
          </description>
          <description>
            <para>Sets the default horizontal layout to be right to left.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns the previous layout of the DC.</para>
      <para>If the function fails, it returns GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The layout specifies the order in which text and graphics are revealed in a window or a device context. The default is left to right. The <b>SetLayout</b> function changes this to be right to left, which is the standard in Arabic and Hebrew cultures.</para>
      <para>Once the LAYOUT_RTL flag is selected, flags normally specifying right or left are reversed. To avoid confusion, consider defining alternate words for standard flags, such as those in the following table.</para>
      <list type="table">
        <listheader>
          <description>Standard flag</description>
          <description>Suggested alternate name</description>
        </listheader>
        <item>
          <description>WS_EX_RIGHT</description>
          <description>WS_EX_TRAILING</description>
        </item>
        <item>
          <description>WS_EX_RTLREADING</description>
          <description>WS_EX_REVERSEREADING</description>
        </item>
        <item>
          <description>WS_EX_LEFTSCROLLBAR</description>
          <description>WS_EX_LEADSCROLLBAR</description>
        </item>
        <item>
          <description>ES_LEFT</description>
          <description>ES_LEAD</description>
        </item>
        <item>
          <description>ES_RIGHT</description>
          <description>ES_TRAIL</description>
        </item>
        <item>
          <description>EC_LEFTMARGIN</description>
          <description>EC_LEADMARGIN</description>
        </item>
        <item>
          <description>EC_RIGHTMARGIN</description>
          <description>EC_TRAILMARGIN</description>
        </item>
      </list>
      <para>
        <b>SetLayout</b> cannot modify drawing directly into the bits of a DIB.</para>
      <para>For more information, see "Window Layout and Mirroring" in <a href="https://docs.microsoft.com//windows/desktop/winmsg/window-features">Window Features</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-context-functions">Device Context Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/device-contexts">Device Contexts Overview</seealso>
    <seealso cref="GetLayout " />
  </member>
  <member name="Windows.SetMapMode">
    <summary>
      <para>The <b>SetMapMode</b> function sets the mapping mode of the specified device context. The mapping mode defines the unit of measure used to transform page-space units into device-space units, and also defines the orientation of the device's x and y axes.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="iMode">
      <para>The new mapping mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>MM_ANISOTROPIC</b>
          </description>
          <description>
            <para>Logical units are mapped to arbitrary units with arbitrarily scaled axes. Use the <see cref="SetWindowExtEx" /> and <see cref="SetViewportExtEx" /> functions to specify the units, orientation, and scaling.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_HIENGLISH</b>
          </description>
          <description>
            <para>Each logical unit is mapped to 0.001 inch. Positive x is to the right; positive y is up.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_HIMETRIC</b>
          </description>
          <description>
            <para>Each logical unit is mapped to 0.01 millimeter. Positive x is to the right; positive y is up.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_ISOTROPIC</b>
          </description>
          <description>
            <para>Logical units are mapped to arbitrary units with equally scaled axes; that is, one unit along the x-axis is equal to one unit along the y-axis. Use the <see cref="SetWindowExtEx" /> and <see cref="SetViewportExtEx" /> functions to specify the units and the orientation of the axes. Graphics device interface (GDI) makes adjustments as necessary to ensure the x and y units remain the same size (When the window extent is set, the viewport will be adjusted to keep the units isotropic).</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_LOENGLISH</b>
          </description>
          <description>
            <para>Each logical unit is mapped to 0.01 inch. Positive x is to the right; positive y is up.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_LOMETRIC</b>
          </description>
          <description>
            <para>Each logical unit is mapped to 0.1 millimeter. Positive x is to the right; positive y is up.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_TEXT</b>
          </description>
          <description>
            <para>Each logical unit is mapped to one device pixel. Positive x is to the right; positive y is down.</para>
          </description>
        </item>
        <item>
          <description>
            <b>MM_TWIPS</b>
          </description>
          <description>
            <para>Each logical unit is mapped to one twentieth of a printer's point (1/1440 inch, also called a twip). Positive x is to the right; positive y is up.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value identifies the previous mapping mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The MM_TEXT mode allows applications to work in device pixels, whose size varies from device to device.</para>
      <para>The MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC, and MM_TWIPS modes are useful for applications drawing in physically meaningful units (such as inches or millimeters).</para>
      <para>The MM_ISOTROPIC mode ensures a 1:1 aspect ratio.</para>
      <para>The MM_ANISOTROPIC mode allows the x-coordinates and y-coordinates to be adjusted independently.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-coordinate-spaces-and-transformations">Using Coordinate Spaces and Transformations</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetMapMode" />
    <seealso cref="SetViewportExtEx" />
    <seealso cref="SetViewportOrgEx" />
    <seealso cref="SetWindowExtEx" />
    <seealso cref="SetWindowOrgEx" />
  </member>
  <member name="Windows.SetMapperFlags">
    <summary>
      <para>The <b>SetMapperFlags</b> function alters the algorithm the font mapper uses when it maps logical fonts to physical fonts.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context that contains the font-mapper flag.</para>
    </param>
    <param name="flags">
      <para>Specifies whether the font mapper should attempt to match a font's aspect ratio to the current device's aspect ratio. If bit zero is set, the mapper selects only matching fonts.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous value of the font-mapper flag.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlag</i> parameter is set and no matching fonts exist, Windows chooses a new aspect ratio and retrieves a font that matches this ratio.</para>
      <para>The remaining bits of the <i>dwFlag</i> parameter must be zero.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetAspectRatioFilterEx" />
  </member>
  <member name="Windows.SetMetaFileBitsEx">
    <summary>
      <para>The <b>SetMetaFileBitsEx</b> function creates a memory-based Windows-format metafile from the supplied data.
<b>Note</b>  This function is provided only for compatibility with Windows-format metafiles. Enhanced-format metafiles provide superior functionality and are recommended for new applications. The corresponding function for an enhanced-format metafile is <see cref="SetEnhMetaFileBits" />.</para>
    </summary>
    <param name="cbBuffer">
      <para>Specifies the size, in bytes, of the Windows-format metafile.</para>
    </param>
    <param name="lpData">
      <para>Pointer to a buffer that contains the Windows-format metafile. (It is assumed that the data was obtained by using the <see cref="GetMetaFileBitsEx" /> function.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a memory-based Windows-format metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>To convert a Windows-format metafile into an enhanced-format metafile, use the <see cref="SetWinMetaFileBits" /> function.</para>
      <para>When the application no longer needs the metafile handle returned by <b>SetMetaFileBitsEx</b>, it should delete it by calling the <see cref="DeleteMetaFile" /> function.</para>
    </remarks>
    <seealso cref="DeleteMetaFile" />
    <seealso cref="GetMetaFileBitsEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="SetEnhMetaFileBits" />
    <seealso cref="SetWinMetaFileBits" />
  </member>
  <member name="Windows.SetMetaRgn">
    <summary>
      <para>The <b>SetMetaRgn</b> function intersects the current clipping region for the specified device context with the current metaregion and saves the combined region as the new metaregion for the specified device context. The clipping region is reset to a null region.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>The return value specifies the new clipping region's complexity and can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>NULLREGION</b>
            </para>
          </description>
          <description>
            <para>Region is empty.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>SIMPLEREGION</b>
            </para>
          </description>
          <description>
            <para>Region is a single rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>COMPLEXREGION</b>
            </para>
          </description>
          <description>
            <para>Region is more than one rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR</b>
            </para>
          </description>
          <description>
            <para>An error occurred. (The previous clipping region is unaffected.)</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The current clipping region of a device context is defined by the intersection of its clipping region and its metaregion.</para>
      <para>The <b>SetMetaRgn</b> function should only be called after an application's original device context was saved by calling the <see cref="SaveDC" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping-functions">Clipping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/clipping">Clipping Overview</seealso>
    <seealso cref="GetMetaRgn" />
    <seealso cref="SaveDC" />
  </member>
  <member name="Windows.SetMiterLimit">
    <summary>
      <para>The <b>SetMiterLimit</b> function sets the limit for the length of miter joins for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Handle to the device context.</para>
    </param>
    <param name="limit">
      <para>Specifies the new miter limit for the device context.</para>
    </param>
    <param name="old">
      <para>Pointer to a floating-point value that receives the previous miter limit. If this parameter is <b>NULL</b>, the previous miter limit is not returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The miter length is defined as the distance from the intersection of the line walls on the inside of the join to the intersection of the line walls on the outside of the join. The miter limit is the maximum allowed ratio of the miter length to the line width.</para>
      <para>The default miter limit is 10.0.</para>
      <para>
        <b>Note</b>  Setting <i>eNewLimit</i> to a float value less than 1.0f will cause the function to fail.</para>
    </remarks>
    <seealso cref="ExtCreatePen" />
    <seealso cref="GetMiterLimit" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
  </member>
  <member name="Windows.SetPaletteEntries">
    <summary>
      <para>The <b>SetPaletteEntries</b> function sets RGB (red, green, blue) color values and flags in a range of entries in a logical palette.</para>
    </summary>
    <param name="hpal">
      <para>A handle to the logical palette.</para>
    </param>
    <param name="iStart">
      <para>The first logical-palette entry to be set.</para>
    </param>
    <param name="cEntries">
      <para>The number of logical-palette entries to be set.</para>
    </param>
    <param name="pPalEntries">
      <para>A pointer to the first member of an array of <a href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</a> structures containing the RGB values and flags.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of entries that were set in the logical palette.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>Even if a logical palette has been selected and realized, changes to the palette do not affect the physical palette in the surface. <see cref="RealizePalette" /> must be called again to set the new logical palette into the surface.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetPaletteEntries" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162769(v=vs.85)">PALETTEENTRY</seealso>
    <seealso cref="RealizePalette" />
  </member>
  <member name="Windows.SetPixel">
    <summary>
      <para>The <b>SetPixel</b> function sets the pixel at the specified coordinates to the specified color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the point to be set.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the point to be set.</para>
    </param>
    <param name="color">
      <para>The color to be used to paint the point. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the RGB value that the function sets the pixel to. This value may differ from the color specified by <i>crColor</i>; that occurs when an exact match for the specified color cannot be found.</para>
      <para>If the function fails, the return value is -1.</para>
      <para>This can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The function fails if the pixel coordinates lie outside of the current clipping region.</para>
      <para>Not all devices support the <b>SetPixel</b> function. For more information, see <see cref="GetDeviceCaps" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetPixel" />
    <seealso cref="RGB" />
    <seealso cref="SetPixelV" />
  </member>
  <member name="Windows.SetPixelFormat">
    <summary>
      <para>The <b>SetPixelFormat</b> function sets the pixel format of the specified device context to the format specified by the <i>iPixelFormat</i> index.</para>
    </summary>
    <param name="hdc">
      <para>Specifies the device context whose pixel format the function attempts to set.</para>
    </param>
    <param name="format">
      <para>Index that identifies the pixel format to set. The various pixel formats supported by a device context are identified by one-based indexes.</para>
    </param>
    <param name="ppfd">
      <para>Pointer to a <see cref="PIXELFORMATDESCRIPTOR" /> structure that contains the logical pixel format specification. The system's metafile component uses this structure to record the logical pixel format specification. The structure has no other effect upon the behavior of the <b>SetPixelFormat</b> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <i>hdc</i> references a window, calling the <b>SetPixelFormat</b> function also changes the pixel format of the window. Setting the pixel format of a window more than once can lead to significant complications for the Window Manager and for multithread applications, so it is not allowed. An application can only set the pixel format of a window one time. Once a window's pixel format is set, it cannot be changed.</para>
      <para>You should select a pixel format in the device context before calling the <see cref="wglCreateContext" /> function. The <b>wglCreateContext</b> function creates a rendering context for drawing on the device in the selected pixel format of the device context.</para>
      <para>An OpenGL window has its own pixel format. Because of this, only device contexts retrieved for the client area of an OpenGL window are allowed to draw into the window. As a result, an OpenGL window should be created with the WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. Additionally, the window class attribute should not include the CS_PARENTDC style.</para>
      <h4>Examples</h4>
      <para>The following code example shows <b>SetPixelFormat</b> usage.</para>
      <code>PIXELFORMATDESCRIPTOR pfd = {
    sizeof(PIXELFORMATDESCRIPTOR),   // size of this pfd
    1,                     // version number
    PFD_DRAW_TO_WINDOW |   // support window
    PFD_SUPPORT_OPENGL |   // support OpenGL
    PFD_DOUBLEBUFFER,      // double buffered
    PFD_TYPE_RGBA,         // RGBA type
    24,                    // 24-bit color depth
    0, 0, 0, 0, 0, 0,      // color bits ignored
    0,                     // no alpha buffer
    0,                     // shift bit ignored
    0,                     // no accumulation buffer
    0, 0, 0, 0,            // accum bits ignored
    32,                    // 32-bit z-buffer
    0,                     // no stencil buffer
    0,                     // no auxiliary buffer
    PFD_MAIN_PLANE,        // main layer
    0,                     // reserved
    0, 0, 0                // layer masks ignored
};
HDC  hdc;
int  iPixelFormat;

// get the best available match of pixel format for the device context
iPixelFormat = ChoosePixelFormat(hdc, &amp;amp;amp;amp;amp;amp;pfd);

// make that the pixel format of the device context
SetPixelFormat(hdc, iPixelFormat, &amp;amp;amp;amp;amp;amp;pfd);
</code>
    </remarks>
    <seealso cref="ChoosePixelFormat" />
    <seealso cref="DescribePixelFormat" />
    <seealso cref="GetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.SetPixelV">
    <summary>
      <para>The <b>SetPixelV</b> function sets the pixel at the specified coordinates to the closest approximation of the specified color. The point must be in the clipping region and the visible part of the device surface.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the point to be set.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the point to be set.</para>
    </param>
    <param name="color">
      <para>The color to be used to paint the point. To create a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> color value, use the <see cref="RGB" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Not all devices support the <b>SetPixelV</b> function. For more information, see the description of the RC_BITBLT capability in the <see cref="GetDeviceCaps" /> function.</para>
      <para>
        <b>SetPixelV</b> is faster than <see cref="SetPixel" /> because it does not need to return the color value of the point actually painted.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="RGB" />
    <seealso cref="SetPixel" />
  </member>
  <member name="Windows.SetPolyFillMode">
    <summary>
      <para>The <b>SetPolyFillMode</b> function sets the polygon fill mode for functions that fill polygons.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="mode">
      <para>The new fill mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ALTERNATE</b>
          </description>
          <description>
            <para>Selects alternate mode (fills the area between odd-numbered and even-numbered polygon sides on each scan line).</para>
          </description>
        </item>
        <item>
          <description>
            <b>WINDING</b>
          </description>
          <description>
            <para>Selects winding mode (fills any region with a nonzero winding value).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>The return value specifies the previous filling mode. If an error occurs, the return value is zero.</para>
    </returns>
    <remarks>
      <para>In general, the modes differ only in cases where a complex, overlapping polygon must be filled (for example, a five-sided polygon that forms a five-pointed star with a pentagon in the center). In such cases, ALTERNATE mode fills every other enclosed region within the polygon (that is, the points of the star), but WINDING mode fills all regions (that is, the points and the pentagon).</para>
      <para>When the fill mode is ALTERNATE, GDI fills the area between odd-numbered and even-numbered polygon sides on each scan line. That is, GDI fills the area between the first and second side, between the third and fourth side, and so on.</para>
      <para>When the fill mode is WINDING, GDI fills any region that has a nonzero winding value. This value is defined as the number of times a pen used to draw the polygon would go around the region. The direction of each edge of the polygon is important.</para>
    </remarks>
    <seealso cref="GetPolyFillMode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.SetRectRgn">
    <summary>
      <para>The <b>SetRectRgn</b> function converts a region into a rectangular region with the specified coordinates.</para>
    </summary>
    <param name="hrgn">
      <para>Handle to the region.</para>
    </param>
    <param name="left">
      <para>Specifies the x-coordinate of the upper-left corner of the rectangular region in logical units.</para>
    </param>
    <param name="top">
      <para>Specifies the y-coordinate of the upper-left corner of the rectangular region in logical units.</para>
    </param>
    <param name="right">
      <para>Specifies the x-coordinate of the lower-right corner of the rectangular region in logical units.</para>
    </param>
    <param name="bottom">
      <para>Specifies the y-coordinate of the lower-right corner of the rectangular region in logical units.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The region does not include the lower and right boundaries of the rectangle.</para>
    </remarks>
    <seealso cref="CreateRectRgn" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/region-functions">Region Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/regions">Regions Overview</seealso>
  </member>
  <member name="Windows.SetROP2">
    <summary>
      <para>The <b>SetROP2</b> function sets the current foreground mix mode. GDI uses the foreground mix mode to combine pens and interiors of filled objects with the colors already on the screen. The foreground mix mode defines how colors from the brush or pen and the colors in the existing image are to be combined.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="rop2">
      <para>The mix mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Mix mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>R2_BLACK</b>
          </description>
          <description>
            <para>Pixel is always 0.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_COPYPEN</b>
          </description>
          <description>
            <para>Pixel is the pen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MASKNOTPEN</b>
          </description>
          <description>
            <para>Pixel is a combination of the colors common to both the screen and the inverse of the pen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MASKPEN</b>
          </description>
          <description>
            <para>Pixel is a combination of the colors common to both the pen and the screen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MASKPENNOT</b>
          </description>
          <description>
            <para>Pixel is a combination of the colors common to both the pen and the inverse of the screen.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MERGENOTPEN</b>
          </description>
          <description>
            <para>Pixel is a combination of the screen color and the inverse of the pen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MERGEPEN</b>
          </description>
          <description>
            <para>Pixel is a combination of the pen color and the screen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_MERGEPENNOT</b>
          </description>
          <description>
            <para>Pixel is a combination of the pen color and the inverse of the screen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOP</b>
          </description>
          <description>
            <para>Pixel remains unchanged.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOT</b>
          </description>
          <description>
            <para>Pixel is the inverse of the screen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOTCOPYPEN</b>
          </description>
          <description>
            <para>Pixel is the inverse of the pen color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOTMASKPEN</b>
          </description>
          <description>
            <para>Pixel is the inverse of the R2_MASKPEN color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOTMERGEPEN</b>
          </description>
          <description>
            <para>Pixel is the inverse of the R2_MERGEPEN color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_NOTXORPEN</b>
          </description>
          <description>
            <para>Pixel is the inverse of the R2_XORPEN color.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_WHITE</b>
          </description>
          <description>
            <para>Pixel is always 1.</para>
          </description>
        </item>
        <item>
          <description>
            <b>R2_XORPEN</b>
          </description>
          <description>
            <para>Pixel is a combination of the colors in the pen and in the screen, but not in both.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the previous mix mode.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Mix modes define how GDI combines source and destination colors when drawing with the current pen. The mix modes are binary raster operation codes, representing all possible Boolean functions of two variables, using the binary operations AND, OR, and XOR (exclusive OR), and the unary operation NOT. The mix mode is for raster devices only; it is not available for vector devices.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-rectangles">Using Rectangles</a>.</para>
    </remarks>
    <seealso cref="GetROP2" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing-functions">Painting and Drawing Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/painting-and-drawing">Painting and Drawing Overview</seealso>
  </member>
  <member name="Windows.SetStretchBltMode">
    <summary>
      <para>The <b>SetStretchBltMode</b> function sets the bitmap stretching mode in the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="mode">
      <para>The stretching mode. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>BLACKONWHITE</b>
          </description>
          <description>
            <para>Performs a Boolean AND operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves black pixels at the expense of white pixels.</para>
          </description>
        </item>
        <item>
          <description>
            <b>COLORONCOLOR</b>
          </description>
          <description>
            <para>Deletes the pixels. This mode deletes all eliminated lines of pixels without trying to preserve their information.</para>
          </description>
        </item>
        <item>
          <description>
            <b>HALFTONE</b>
          </description>
          <description>
            <para>Maps pixels from the source rectangle into blocks of pixels in the destination rectangle. The average color over the destination block of pixels approximates the color of the source pixels.</para>
            <para>After setting the HALFTONE stretching mode, an application must call the <see cref="SetBrushOrgEx" /> function to set the brush origin. If it fails to do so, brush misalignment occurs.</para>
          </description>
        </item>
        <item>
          <description>
            <b>STRETCH_ANDSCANS</b>
          </description>
          <description>
            <para>Same as BLACKONWHITE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>STRETCH_DELETESCANS</b>
          </description>
          <description>
            <para>Same as COLORONCOLOR.</para>
          </description>
        </item>
        <item>
          <description>
            <b>STRETCH_HALFTONE</b>
          </description>
          <description>
            <para>Same as HALFTONE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>STRETCH_ORSCANS</b>
          </description>
          <description>
            <para>Same as WHITEONBLACK.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WHITEONBLACK</b>
          </description>
          <description>
            <para>Performs a Boolean OR operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves white pixels at the expense of black pixels.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous stretching mode.</para>
      <para>If the function fails, the return value is zero.</para>
      <para>This function can return the following value.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One or more of the input parameters is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The stretching mode defines how the system combines rows or columns of a bitmap with existing pixels on a display device when an application calls the <see cref="StretchBlt" /> function.</para>
      <para>The BLACKONWHITE (STRETCH_ANDSCANS) and WHITEONBLACK (STRETCH_ORSCANS) modes are typically used to preserve foreground pixels in monochrome bitmaps. The COLORONCOLOR (STRETCH_DELETESCANS) mode is typically used to preserve color in color bitmaps.</para>
      <para>The HALFTONE mode is slower and requires more processing of the source image than the other three modes; but produces higher quality images. Also note that <see cref="SetBrushOrgEx" /> must be called after setting the HALFTONE mode to avoid brush misalignment.</para>
      <para>Additional stretching modes might also be available depending on the capabilities of the device driver.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetStretchBltMode" />
    <seealso cref="SetBrushOrgEx" />
    <seealso cref="StretchBlt" />
  </member>
  <member name="Windows.SetSystemPaletteUse">
    <summary>
      <para>The <b>SetSystemPaletteUse</b> function allows an application to specify whether the system palette contains 2 or 20 static colors. The default system palette contains 20 static colors. (Static colors cannot be changed when an application realizes a logical palette.)</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context. This device context must refer to a device that supports color palettes.</para>
    </param>
    <param name="use">
      <para>The new use of the system palette. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>SYSPAL_NOSTATIC</b>
          </description>
          <description>
            <para>The system palette contains two static colors (black and white).</para>
          </description>
        </item>
        <item>
          <description>
            <b>SYSPAL_NOSTATIC256</b>
          </description>
          <description>
            <para>The system palette contains no static colors.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SYSPAL_STATIC</b>
          </description>
          <description>
            <para>The system palette contains static colors that will not change when an application realizes its logical palette.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous system palette. It can be either SYSPAL_NOSTATIC, SYSPAL_NOSTATIC256, or SYSPAL_STATIC.</para>
      <para>If the function fails, the return value is SYSPAL_ERROR.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>When an application window moves to the foreground and the SYSPAL_NOSTATIC value is set, the application must call the <see cref="GetSysColor" /> function to save the current system colors setting. It must also call <see cref="SetSysColors" /> to set reasonable values using only black and white. When the application returns to the background or terminates, the previous system colors must be restored.</para>
      <para>If the function returns SYSPAL_ERROR, the specified device context is invalid or does not support color palettes.</para>
      <para>An application must call this function only when its window is maximized and has the input focus.</para>
      <para>If an application calls <b>SetSystemPaletteUse</b> with <i>uUsage</i> set to SYSPAL_NOSTATIC, the system continues to set aside two entries in the system palette for pure white and pure black, respectively.</para>
      <para>After calling this function with <i>uUsage</i> set to SYSPAL_NOSTATIC, an application must take the following steps:</para>
      <list type="number">
        <item>
          <description>Realize the logical palette.</description>
        </item>
        <item>
          <description>Call the <see cref="GetSysColor" /> function to save the current system-color settings.</description>
        </item>
        <item>
          <description>Call the <see cref="SetSysColors" /> function to set the system colors to reasonable values using black and white. For example, adjacent or overlapping items (such as window frames and borders) should be set to black and white, respectively.</description>
        </item>
        <item>
          <description>Send the <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-syscolorchange">WM_SYSCOLORCHANGE</a> message to other top-level windows to allow them to be redrawn with the new system colors.</description>
        </item>
      </list>
      <para>When the application's window loses focus or closes, the application must perform the following steps:</para>
      <list type="number">
        <item>
          <description>Call <b>SetSystemPaletteUse</b> with the <i>uUsage</i> parameter set to SYSPAL_STATIC.</description>
        </item>
        <item>
          <description>Realize the logical palette.</description>
        </item>
        <item>
          <description>Restore the system colors to their previous values.</description>
        </item>
        <item>
          <description>Send the <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-syscolorchange">WM_SYSCOLORCHANGE</a> message.</description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="GetSysColor" />
    <seealso cref="GetSystemPaletteUse" />
    <seealso cref="SetSysColors" />
  </member>
  <member name="Windows.SetTextAlign">
    <summary>
      <para>The <b>SetTextAlign</b> function sets the text-alignment flags for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="align">
      <para>The text alignment by using a mask of the values in the following list. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TA_BASELINE</b>
          </description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_BOTTOM</b>
          </description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_TOP</b>
          </description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_CENTER</b>
          </description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_LEFT</b>
          </description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_RIGHT</b>
          </description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_NOUPDATECP</b>
          </description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TA_RTLREADING</b>
          </description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>
            <b>TA_UPDATECP</b>
          </description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>When the current font has a vertical default base line, as with Kanji, the following values must be used instead of TA_BASELINE and TA_CENTER.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>VTA_BASELINE</b>
          </description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>
            <b>VTA_CENTER</b>
          </description>
          <description>
            <para>The reference point will be aligned vertically with the center of the bounding rectangle.</para>
          </description>
        </item>
      </list>
      <para>The default values are TA_LEFT, TA_TOP, and TA_NOUPDATECP.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous text-alignment setting.</para>
      <para>If the function fails, the return value is GDI_ERROR.</para>
    </returns>
    <remarks>
      <para>The <see cref="TextOut" /> and <see cref="ExtTextOut" /> functions use the text-alignment flags to position a string of text on a display or other device. The flags specify the relationship between a reference point and a rectangle that bounds the text. The reference point is either the current position or a point passed to a text output function.</para>
      <para>The rectangle that bounds the text is formed by the character cells in the text string.</para>
      <para>The best way to get left-aligned text is to use either</para>
      <code>
SetTextAlign (hdc, GetTextAlign(hdc) &amp;amp;amp;amp;amp;amp; (~TA_CENTER))

</code>
      <para>or</para>
      <code>
SetTextAlign (hdc,TA_LEFT | &lt;other flags&gt;)

</code>
      <para>You can also use <b>SetTextAlign</b> (hdc, TA_LEFT) for this purpose, but this loses any vertical or right-to-left settings.</para>
      <para>
        <b>Note</b>  You should not use <b>SetTextAlign</b> with TA_UPDATECP when you are using <see cref="ScriptStringOut" />, because selected text is not rendered correctly. If you must use this flag, you can unset and reset it as necessary to avoid the problem.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/setting-the-text-alignment">Setting the Text Alignment</a>.</para>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="ScriptStringOut" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.SetTextCharacterExtra">
    <summary>
      <para>The <b>SetTextCharacterExtra</b> function sets the intercharacter spacing. Intercharacter spacing is added to each character, including break characters, when the system writes a line of text.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="extra">
      <para>The amount of extra space, in logical units, to be added to each character. If the current mapping mode is not MM_TEXT, the <i>nCharExtra</i> parameter is transformed and rounded to the nearest pixel.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous intercharacter spacing.</para>
      <para>If the function fails, the return value is 0x80000000.</para>
    </returns>
    <remarks>
      <para>This function is supported mainly for compatibility with existing applications. New applications should generally avoid calling this function, because it is incompatible with complex scripts (scripts that require text shaping; Arabic script is an example of this).</para>
      <para>The recommended approach is that instead of calling this function and then <see cref="TextOut" />, applications should call <see cref="ExtTextOut" /> and use its <i>lpDx</i> parameter to supply widths.</para>
    </remarks>
    <seealso cref="DrawText" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextCharacterExtra" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.SetTextColor">
    <summary>
      <para>The <b>SetTextColor</b> function sets the text color for the specified device context to the specified color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="color">
      <para>The color of the text.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a color reference for the previous text color as a <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a> value.</para>
      <para>If the function fails, the return value is CLR_INVALID.</para>
    </returns>
    <remarks>
      <para>The text color is used to draw the face of each character written by the <see cref="TextOut" /> and <see cref="ExtTextOut" /> functions. The text color is also used in converting bitmaps from color to monochrome and vice versa.</para>
      <h4>Examples</h4>
      <para>For an example, see "Setting Fonts for Menu-Item Text Strings" in <a href="https://docs.microsoft.com//windows/desktop/menurc/using-menus">Using Menus</a>.</para>
    </remarks>
    <seealso cref="BitBlt" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextColor" />
    <seealso cref="RGB" />
    <seealso cref="SetBkColor" />
    <seealso cref="StretchBlt" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.SetTextJustification">
    <summary>
      <para>The <b>SetTextJustification</b> function specifies the amount of space the system should add to the break characters in a string of text. The space is added when an application calls the <see cref="TextOut" /> or <see cref="ExtTextOut" /> functions.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="extra">
      <para>The total extra space, in logical units, to be added to the line of text. If the current mapping mode is not MM_TEXT, the value identified by the <i>nBreakExtra</i> parameter is transformed and rounded to the nearest pixel.</para>
    </param>
    <param name="count">
      <para>The number of break characters in the line.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The break character is usually the space character (ASCII 32), but it may be defined by a font as some other character. The <see cref="GetTextMetrics" /> function can be used to retrieve a font's break character.</para>
      <para>The <see cref="TextOut" /> function distributes the specified extra space evenly among the break characters in the line.</para>
      <para>The <see cref="GetTextExtentPoint32" /> function is always used with the <b>SetTextJustification</b> function. Sometimes the <b>GetTextExtentPoint32</b> function takes justification into account when computing the width of a specified line before justification, and sometimes it does not. For more details on this, see <b>GetTextExtentPoint32</b>. This width must be known before an appropriate <i>nBreakExtra</i> value can be computed.</para>
      <para>
        <b>SetTextJustification</b> can be used to justify a line that contains multiple strings in different fonts. In this case, each string must be justified separately.</para>
      <para>Because rounding errors can occur during justification, the system keeps a running error term that defines the current error value. When justifying a line that contains multiple runs, <see cref="GetTextExtentPoint" /> automatically uses this error term when it computes the extent of the next run, allowing <see cref="TextOut" /> to blend the error into the new run. After each line has been justified, this error term must be cleared to prevent it from being incorporated into the next line. The term can be cleared by calling <b>SetTextJustification</b> with <i>nBreakExtra</i> set to zero.</para>
    </remarks>
    <seealso cref="ExtTextOut" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextExtentPoint32" />
    <seealso cref="GetTextMetrics" />
    <seealso cref="TextOut" />
  </member>
  <member name="Windows.SetViewportExtEx">
    <summary>
      <para>The <b>SetViewportExtEx</b> function sets the horizontal and vertical extents of the viewport for a device context by using the specified values.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The horizontal extent, in device units, of the viewport.</para>
    </param>
    <param name="y">
      <para>The vertical extent, in device units, of the viewport.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the previous viewport extents, in device units. If <i>lpSize</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <i>viewport</i> refers to the device coordinate system of the device space. The <i>extent</i> is the maximum value of an axis. This function sets the maximum values for the horizontal and vertical axes of the viewport in device coordinates (or pixels). When mapping between page space and device space, <see cref="SetWindowExtEx" /> and <b>SetViewportExtEx</b> determine the scaling factor between the window and the viewport. For more information, see <a href="https://docs.microsoft.com//windows/desktop/gdi/transformation-of-coordinate-spaces">Transformation of Coordinate Spaces</a>.</para>
      <para>When the following mapping modes are set, calls to the <see cref="SetWindowExtEx" /> and <b>SetViewportExtEx</b> functions are ignored.</para>
      <list type="bullet">
        <item>
          <description>MM_HIENGLISH</description>
        </item>
        <item>
          <description>MM_HIMETRIC</description>
        </item>
        <item>
          <description>MM_LOENGLISH</description>
        </item>
        <item>
          <description>MM_LOMETRIC</description>
        </item>
        <item>
          <description>MM_TEXT</description>
        </item>
        <item>
          <description>MM_TWIPS</description>
        </item>
      </list>
      <para>When MM_ISOTROPIC mode is set, an application must call the <see cref="SetWindowExtEx" /> function before it calls <b>SetViewportExtEx</b>. Note that for the MM_ISOTROPIC mode certain portions of a nonsquare screen may not be available for display because the logical units on both axes represent equal physical distances.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/invalidating-the-client-area">Invalidating the Client Area</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportExtEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetWindowExtEx" />
  </member>
  <member name="Windows.SetViewportOrgEx">
    <summary>
      <para>The <b>SetViewportOrgEx</b> function specifies which device point maps to the window origin (0,0).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in device units, of the new viewport origin.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in device units, of the new viewport origin.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the previous viewport origin, in device coordinates. If <i>lpPoint</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This function (along with <see cref="SetViewportExtEx" /> and <see cref="SetWindowExtEx" />) helps define the mapping from the logical coordinate space (also known as a <i>window</i>) to the device coordinate space (the <i>viewport</i>). <b>SetViewportOrgEx</b> specifies which device point maps to the logical point (0,0). It has the effect of shifting the axes so that the logical point (0,0) no longer refers to the upper-left corner.</para>
      <code>
//map the logical point (0,0) to the device point (xViewOrg, yViewOrg)
SetViewportOrgEx ( hdc, xViewOrg, yViewOrg, NULL)

</code>
      <para>This is related to the <see cref="SetWindowOrgEx" /> function. Generally, you will use one function or the other, but not both. Regardless of your use of <b>SetWindowOrgEx</b> and <b>SetViewportOrgEx</b>, the device point (0,0) is always the upper-left corner.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/redrawing-in-the-update-region">Redrawing in the Update Region</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportOrgEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="SetWindowOrgEx" />
  </member>
  <member name="Windows.SetWindowExtEx">
    <summary>
      <para>The <b>SetWindowExtEx</b> function sets the horizontal and vertical extents of the window for a device context by using the specified values.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The window's horizontal extent in logical units.</para>
    </param>
    <param name="y">
      <para>The window's vertical extent in logical units.</para>
    </param>
    <param name="lpsz">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</a> structure that receives the previous window extents, in logical units. If <i>lpSize</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <i>window</i> refers to the logical coordinate system of the page space. The <i>extent</i> is the maximum value of an axis. This function sets the maximum values for the horizontal and vertical axes of the window (in logical coordinates). When mapping between page space and device space, <see cref="SetViewportExtEx" /> and <b>SetWindowExtEx</b> determine the scaling factor between the window and the viewport. For more information, see <a href="https://docs.microsoft.com//windows/desktop/gdi/transformation-of-coordinate-spaces">Transformation of Coordinate Spaces</a>.</para>
      <para>When the following mapping modes are set, calls to the <b>SetWindowExtEx</b> and <see cref="SetViewportExtEx" /> functions are ignored:</para>
      <list type="bullet">
        <item>
          <description>MM_HIENGLISH</description>
        </item>
        <item>
          <description>MM_HIMETRIC</description>
        </item>
        <item>
          <description>MM_LOENGLISH</description>
        </item>
        <item>
          <description>MM_LOMETRIC</description>
        </item>
        <item>
          <description>MM_TEXT</description>
        </item>
        <item>
          <description>MM_TWIPS</description>
        </item>
      </list>
      <para>When MM_ISOTROPIC mode is set, an application must call the <b>SetWindowExtEx</b> function before calling <see cref="SetViewportExtEx" />. Note that for the MM_ISOTROPIC mode, certain portions of a nonsquare screen may not be available for display because the logical units on both axes represent equal physical distances.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/invalidating-the-client-area">Invalidating the Client Area</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWindowExtEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd145106(v=vs.85)">SIZE</seealso>
    <seealso cref="SetViewportExtEx" />
  </member>
  <member name="Windows.SetWindowOrgEx">
    <summary>
      <para>The <b>SetWindowOrgEx</b> function specifies which window point maps to the viewport origin (0,0).</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical units, of the new window origin.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical units, of the new window origin.</para>
    </param>
    <param name="lppt">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</a> structure that receives the previous origin of the window, in logical units. If <i>lpPoint</i> is <b>NULL</b>, this parameter is not used.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>This helps define the mapping from the logical coordinate space (also known as a <i>window</i>) to the device coordinate space (the <i>viewport</i>). <b>SetWindowOrgEx</b> specifies which logical point maps to the device point (0,0). It has the effect of shifting the axes so that the logical point (0,0) no longer refers to the upper-left corner.</para>
      <code>
//map the logical point (xWinOrg, yWinOrg) to the device point (0,0)
SetWindowOrgEx (hdc, xWinOrg, yWinOrg, NULL)

</code>
      <para>This is related to the <see cref="SetViewportOrgEx" /> function. Generally, you will use one function or the other, but not both. Regardless of your use of <b>SetWindowOrgEx</b> and <b>SetViewportOrgEx</b>, the device point (0,0) is always the upper-left corner.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetViewportOrgEx" />
    <seealso cref="GetWindowOrgEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/dd162805(v=vs.85)">POINT</seealso>
    <seealso cref="SetViewportOrgEx" />
  </member>
  <member name="Windows.SetWinMetaFileBits">
    <summary>
      <para>The <b>SetWinMetaFileBits</b> function converts a metafile from the older Windows format to the new enhanced format and stores the new metafile in memory.</para>
    </summary>
    <param name="nSize">
      <para>The size, in bytes, of the buffer that contains the Windows-format metafile.</para>
    </param>
    <param name="lpMeta16Data">
      <para>A pointer to a buffer that contains the Windows-format metafile data. (It is assumed that the data was obtained by using the <see cref="GetMetaFileBitsEx" /> or <see cref="GetWinMetaFileBits" /> function.)</para>
    </param>
    <param name="hdcRef">
      <para>A handle to a reference device context.</para>
    </param>
    <param name="lpMFP">
      <para>A pointer to a <see cref="METAFILEPICT" /> structure that contains the suggested size of the metafile picture and the mapping mode that was used when the picture was created.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a memory-based enhanced metafile.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>Windows uses the reference device context's resolution data and the data in the <see cref="METAFILEPICT" /> structure to scale a picture. If the <i>hdcRef</i> parameter is <b>NULL</b>, the system uses resolution data for the current output device. If the <i>lpmfp</i> parameter is <b>NULL</b>, the system uses the MM_ANISOTROPIC mapping mode to scale the picture so that it fits the entire device surface. The <b>hMF</b> member of the <b>METAFILEPICT</b> structure is not used.</para>
      <para>When the application no longer needs the enhanced metafile handle, it should delete it by calling the <see cref="DeleteEnhMetaFile" /> function.</para>
      <para>The handle returned by this function can be used with other enhanced-metafile functions.</para>
      <para>If the reference device context is not identical to the device in which the metafile was originally created, some GDI functions that use device units may not draw the picture correctly.</para>
    </remarks>
    <seealso cref="DeleteEnhMetaFile" />
    <seealso cref="GetMetaFileBitsEx" />
    <seealso cref="GetWinMetaFileBits" />
    <seealso cref="METAFILEPICT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafile-functions">Metafile Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/metafiles">Metafiles Overview</seealso>
    <seealso cref="PlayEnhMetaFile" />
  </member>
  <member name="Windows.SetWorldTransform">
    <summary>
      <para>The <b>SetWorldTransform</b> function sets a two-dimensional linear transformation between world space and page space for the specified device context. This transformation can be used to scale, rotate, shear, or translate graphics output.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="lpxf">
      <para>A pointer to an <see cref="XFORM" /> structure that contains the transformation data.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>Below is the transformation matrix (note that the digits in the element notation are 1-based column number followed by 1-based row number, rather than the reverse).</para>
      <code>| eM11 eM21 eDx |
| eM12 eM22 eDy |
| 0    0    1   |

</code>
      <para>So for any coordinates (x, y) in world space, the transformed coordinates in page space (x', y') can be determined in the way shown below.</para>
      <code>| x' |   | eM11 eM21 eDx |   | x |
| y' | = | eM12 eM22 eDy | . | y |
| 1  |   | 0    0    1   |   | 1 |

x' = x * eM11 + y * eM21 + eDx
y' = x * eM12 + y * eM22 + eDy

</code>
      <para>This function uses logical units.</para>
      <para>The world transformation is usually used to scale or rotate logical images in a device-independent way.</para>
      <para>The default world transformation is the identity matrix with zero offset.</para>
      <para>The <b>SetWorldTransform</b> function will fail unless the graphics mode for the given device context has been set to GM_ADVANCED by previously calling the <see cref="SetGraphicsMode" /> function. Likewise, it will not be possible to reset the graphics mode for the device context to the default GM_COMPATIBLE mode, unless the world transformation has first been reset to the default identity transformation by calling <b>SetWorldTransform</b> or <see cref="ModifyWorldTransform" />.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/using-coordinate-spaces-and-transformations">Using Coordinate Spaces and Transformations</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-space-and-transformation-functions">Coordinate Space and Transformation Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/coordinate-spaces-and-transformations">Coordinate Spaces and Transformations Overview</seealso>
    <seealso cref="GetWorldTransform" />
    <seealso cref="ModifyWorldTransform" />
    <seealso cref="SetGraphicsMode" />
    <seealso cref="SetMapMode" />
    <seealso cref="SetViewportExtEx" />
    <seealso cref="SetViewportOrgEx" />
    <seealso cref="SetWindowExtEx" />
    <seealso cref="SetWindowOrgEx" />
    <seealso cref="XFORM" />
  </member>
  <member name="Windows.StartDoc">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartDocA">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartDocW">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartDoc">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartDocA">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartDocW">
    <summary>
      <para>The <b>StartDoc</b> function starts a print job.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <param name="lpdi">
      <para>A pointer to a <see cref="DOCINFO" /> structure containing the name of the document file and the name of the output file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero. This value is the print job identifier for the document.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>Applications should call the <b>StartDoc</b> function immediately before beginning a print job. Using this function ensures that multipage documents are not interspersed with other print jobs.</para>
      <para>Applications can use the value returned by <b>StartDoc</b> to retrieve or set the priority of a print job. Call the <a href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</a> or <a href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</a> function and supply this value as one of the required arguments.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines StartDoc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DOCINFO" />
    <seealso cref="EndDoc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/getjob">GetJob</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/setjob">SetJob</seealso>
  </member>
  <member name="Windows.StartPage">
    <summary>
      <para>The <b>StartPage</b> function prepares the printer driver to accept data.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context for the print job.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than zero.</para>
      <para>If the function fails, the return value is less than or equal to zero.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.</para>
      <para>The system disables the <see cref="ResetDC" /> function between calls to the <b>StartPage</b> and <see cref="EndPage" /> functions. This means that you cannot change the device mode except at page boundaries. After calling <b>EndPage</b>, you can call <b>ResetDC</b> to change the device mode, if necessary. Note that a call to <b>ResetDC</b> resets all device context attributes back to default values.</para>
      <para>Neither <see cref="EndPage" /> nor <b>StartPage</b> resets the device context attributes. Device context attributes remain constant across subsequent pages. You do not need to re-select objects and set up the mapping mode again before printing the next page; however, doing so will produce the same results and reduce code differences between versions of Windows.</para>
      <h4>Examples</h4>
      <para>For a sample program that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/printdocs/how-to--print-using-the-gdi-print-api">How To: Print Using the GDI Print API</a>.</para>
    </remarks>
    <seealso cref="EndPage" />
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printing-and-print-spooler-functions">Print Spooler API Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/printdocs/printdocs-printing">Printing</seealso>
    <seealso cref="ResetDC" />
  </member>
  <member name="Windows.StretchBlt">
    <summary>
      <para>The <b>StretchBlt</b> function copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary. The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="wDest">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hDest">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xSrc">
      <para>The x-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="ySrc">
      <para>The y-coordinate, in logical units, of the upper-left corner of the source rectangle.</para>
    </param>
    <param name="wSrc">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="hSrc">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="rop">
      <para>The raster operation to be performed. Raster operation codes define how the system combines colors in output operations that involve a brush, a source bitmap, and a destination bitmap.</para>
      <para>See <see cref="BitBlt" /> for a list of common raster operation codes (ROPs). Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>
        <b>StretchBlt</b> stretches or compresses the source bitmap in memory and then copies the result to the destination rectangle. This bitmap can be either a compatible bitmap (DDB) or the output from <see cref="CreateDIBSection" />. The color data for pattern or destination pixels is merged after the stretching or compression occurs.</para>
      <para>When an enhanced metafile is being recorded, an error occurs (and the function returns <b>FALSE</b>) if the source device context identifies an enhanced-metafile device context.</para>
      <para>If the specified raster operation requires a brush, the system uses the brush currently selected into the destination device context.</para>
      <para>The destination coordinates are transformed by using the transformation currently specified for the destination device context; the source coordinates are transformed by using the transformation currently specified for the source device context.</para>
      <para>If the source transformation has a rotation or shear, an error occurs.</para>
      <para>If destination, source, and pattern bitmaps do not have the same color format, <b>StretchBlt</b> converts the source and pattern bitmaps to match the destination bitmap.</para>
      <para>If <b>StretchBlt</b> must convert a monochrome bitmap to a color bitmap, it sets white bits (1) to the background color and black bits (0) to the foreground color. To convert a color bitmap to a monochrome bitmap, it sets pixels that match the background color to white (1) and sets all other pixels to black (0). The foreground and background colors of the device context with color are used.</para>
      <para>
        <b>StretchBlt</b> creates a mirror image of a bitmap if the signs of the <i>nWidthSrc</i> and <i>nWidthDest</i> parameters or if the <i>nHeightSrc</i> and <i>nHeightDest</i> parameters differ. If <i>nWidthSrc</i> and <i>nWidthDest</i> have different signs, the function creates a mirror image of the bitmap along the x-axis. If <i>nHeightSrc</i> and <i>nHeightDest</i> have different signs, the function creates a mirror image of the bitmap along the y-axis.</para>
      <para>Not all devices support the <b>StretchBlt</b> function. For more information, see the <see cref="GetDeviceCaps" />.</para>
      <para>
        <b>ICM:</b> No color management is performed when a blit operation occurs.</para>
      <para>When used in a multiple monitor system, both <i>hdcSrc</i> and <i>hdcDest</i> must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/scaling-an-image">Scaling an Image</a>.</para>
    </remarks>
    <seealso cref="BitBlt" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="CreateDIBSection" />
    <seealso cref="GetDIBits" />
    <seealso cref="GetDeviceCaps" />
    <seealso cref="MaskBlt" />
    <seealso cref="PlgBlt" />
    <seealso cref="SetDIBits" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.StretchDIBits">
    <summary>
      <para>The <b>StretchDIBits</b> function copies the color data for a rectangle of pixels in a DIB, JPEG, or PNG image to the specified destination rectangle. If the destination rectangle is larger than the source rectangle, this function stretches the rows and columns of color data to fit the destination rectangle. If the destination rectangle is smaller than the source rectangle, this function compresses the rows and columns by using the specified raster operation.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="DestWidth">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="DestHeight">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="xSrc">
      <para>The x-coordinate, in pixels, of the source rectangle in the image.</para>
    </param>
    <param name="ySrc">
      <para>The y-coordinate, in pixels, of the source rectangle in the image.</para>
    </param>
    <param name="SrcWidth">
      <para>The width, in pixels, of the source rectangle in the image.</para>
    </param>
    <param name="SrcHeight">
      <para>The height, in pixels, of the source rectangle in the image.</para>
    </param>
    <param name="lpBits">
      <para>A pointer to the image bits, which are stored as an array of bytes. For more information, see the Remarks section.</para>
    </param>
    <param name="lpbmi">
      <para>A pointer to a <see cref="BITMAPINFO" /> structure that contains information about the DIB.</para>
    </param>
    <param name="iUsage">
      <para>Specifies whether the <b>bmiColors</b> member of the <see cref="BITMAPINFO" /> structure was provided and, if so, whether <b>bmiColors</b> contains explicit red, green, blue (RGB) values or indexes. The <i>iUsage</i> parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>DIB_PAL_COLORS</b>
          </description>
          <description>
            <para>The array contains 16-bit indexes into the logical palette of the source device context.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DIB_RGB_COLORS</b>
          </description>
          <description>
            <para>The color table contains literal RGB values.</para>
          </description>
        </item>
      </list>
      <para>For more information, see the Remarks section.</para>
    </param>
    <param name="rop">
      <para>A raster-operation code that specifies how the source pixels, the destination device context's current brush, and the destination pixels are to be combined to form the new image. For a list of some common raster operation codes, see <see cref="BitBlt" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of scan lines copied. Note that this value can be negative for mirrored content.</para>
      <para>If the function fails, or no scan lines are copied, the return value is 0.</para>
      <para>If the driver cannot support the JPEG or PNG file image passed to <b>StretchDIBits</b>, the function will fail and return GDI_ERROR. If failure does occur, the application must fall back on its own JPEG or PNG support to decompress the image into a bitmap, and then pass the bitmap to <b>StretchDIBits</b>.</para>
    </returns>
    <remarks>
      <para>The origin of a bottom-up DIB is the lower-left corner; the origin of a top-down DIB is the upper-left corner.</para>
      <para>
        <b>StretchDIBits</b> creates a mirror image of a bitmap if the signs of the <i>nSrcWidth</i> and <i>nDestWidth</i> parameters, or if the <i>nSrcHeight</i> and <i>nDestHeight</i> parameters differ. If <i>nSrcWidth</i> and <i>nDestWidth</i> have different signs, the function creates a mirror image of the bitmap along the x-axis. If <i>nSrcHeight</i> and <i>nDestHeight</i> have different signs, the function creates a mirror image of the bitmap along the y-axis.</para>
      <para>
        <b>StretchDIBits</b> creates a top-down image if the sign of the <b>biHeight</b> member of the <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> structure for the DIB is negative. For a code example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/sizing-a-jpeg-or-png-image">Sizing a JPEG or PNG Image</a>.</para>
      <para>This function allows a JPEG or PNG image to be passed as the source image. How each parameter is used remains the same, except:</para>
      <list type="bullet">
        <item>
          <description>If the <b>biCompression</b> member of <a href="https://docs.microsoft.com//previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a> is BI_JPEG or BI_PNG, <i>lpBits</i> points to a buffer containing a JPEG or PNG image, respectively. The <b>biSizeImage</b> member of the <b>BITMAPINFOHEADER</b> structure specifies the size of the buffer. The <i>iUsage</i> parameter must be set to DIB_RGB_COLORS. The <i>dwRop</i> parameter must be set to SRCCOPY.</description>
        </item>
        <item>
          <description>To ensure proper metafile spooling while printing, applications must call the CHECKJPEGFORMAT or CHECKPNGFORMAT escape to verify that the printer recognizes the JPEG or PNG image, respectively, before calling <b>StretchDIBits</b>.</description>
        </item>
      </list>
      <b>ICM:</b> Color management is performed if color management has been enabled with a call to <see cref="SetICMMode" /> with the <i>iEnableICM</i> parameter set to ICM_ON. If the bitmap specified by <i>lpBitsInfo</i> has a <see cref="BITMAPV4HEADER" /> that specifies the gamma and endpoints members, or a <see cref="BITMAPV5HEADER" /> that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space.
<h4>Examples</h4><para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/sizing-a-jpeg-or-png-image">Sizing a JPEG or PNG Image</a>.</para></remarks>
    <seealso cref="BITMAPINFO " />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="SetMapMode " />
    <seealso cref="SetStretchBltMode " />
  </member>
  <member name="Windows.StrokeAndFillPath">
    <summary>
      <para>The <b>StrokeAndFillPath</b> function closes any open figures in a path, strokes the outline of the path by using the current pen, and fills its interior by using the current brush.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The device context identified by the <i>hdc</i> parameter must contain a closed path.</para>
      <para>The <b>StrokeAndFillPath</b> function has the same effect as closing all the open figures in the path, and stroking and filling the path separately, except that the filled region will not overlap the stroked region even if the pen is wide.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/drawing-a-pie-chart">Drawing a Pie Chart</a>.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="FillPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="SetPolyFillMode" />
    <seealso cref="StrokePath" />
  </member>
  <member name="Windows.StrokePath">
    <summary>
      <para>The <b>StrokePath</b> function renders the specified path by using the current pen.</para>
    </summary>
    <param name="hdc">
      <para>Handle to a device context that contains the completed path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The path, if it is to be drawn by <b>StrokePath</b>, must have been completed through a call to <see cref="EndPath" />. Calling this function on a path for which <b>EndPath</b> has not been called will cause this function to fail and return zero.  Unlike other path drawing functions such as <see cref="StrokeAndFillPath" />, <b>StrokePath</b> will not attempt to close the path by drawing a straight line from the first point on the path to the last point on the path.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="EndPath" />
    <seealso cref="ExtCreatePen" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
  </member>
  <member name="Windows.SwapBuffers">
    <summary>
      <para>The <b>SwapBuffers</b> function exchanges the front and back buffers if the current pixel format for the window referenced by the specified device context includes a back buffer.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies a device context. If the current pixel format for the window referenced by this device context includes a back buffer, the function exchanges the front and back buffers.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current pixel format for the window referenced by the device context does not include a back buffer, this call has no effect and the content of the back buffer is undefined when the function returns.</para>
      <para>With multithread applications, flush the drawing commands in any other threads drawing to the same window before calling <b>SwapBuffers</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/win32-functions">Windows Functions</seealso>
  </member>
  <member name="Windows.TextOut">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TextOutA">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TextOutW">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TextOut">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TextOutA">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TextOutW">
    <summary>
      <para>The <b>TextOut</b> function writes a character string at the specified location, using the currently selected font, background color, and text color.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <param name="x">
      <para>The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="y">
      <para>The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.</para>
    </param>
    <param name="lpString">
      <para>A pointer to the string to be drawn. The string does not need to be zero-terminated, because <i>cchString</i> specifies the length of the string.</para>
    </param>
    <param name="c">
      <para>The <a href="https://docs.microsoft.com//windows/desktop/gdi/specifying-length-of-text-output-string">length of the string</a> pointed to by <i>lpString</i>, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The interpretation of the reference point depends on the current text-alignment mode. An application can retrieve this mode by calling the <see cref="GetTextAlign" /> function; an application can alter this mode by calling the <see cref="SetTextAlign" /> function. You can use the following values for text alignment. Only one flag can be chosen from those that affect horizontal and vertical alignment. In addition, only one of the two flags that alter the current position can be chosen.</para>
      <list type="table">
        <listheader>
          <description>Term</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>TA_BASELINE
</description>
          <description>
            <para>The reference point will be on the base line of the text.</para>
          </description>
        </item>
        <item>
          <description>TA_BOTTOM
</description>
          <description>
            <para>The reference point will be on the bottom edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_TOP
</description>
          <description>
            <para>The reference point will be on the top edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_CENTER
</description>
          <description>
            <para>The reference point will be aligned horizontally with the center of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_LEFT
</description>
          <description>
            <para>The reference point will be on the left edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_RIGHT
</description>
          <description>
            <para>The reference point will be on the right edge of the bounding rectangle.</para>
          </description>
        </item>
        <item>
          <description>TA_NOUPDATECP
</description>
          <description>
            <para>The current position is not updated after each text output call. The reference point is passed to the text output function.</para>
          </description>
        </item>
        <item>
          <description>TA_RTLREADING
</description>
          <description>
            <b>Middle East language edition of Windows:</b> The text is laid out in right to left reading order, as opposed to the default left to right order. This applies only when the font selected into the device context is either Hebrew or Arabic.
</description>
        </item>
        <item>
          <description>TA_UPDATECP
</description>
          <description>
            <para>The current position is updated after each text output call. The current position is used as the reference point.</para>
          </description>
        </item>
      </list>
      <para>By default, the current position is not used or updated by this function. However, an application can call the <see cref="SetTextAlign" /> function with the <i>fMode</i> parameter set to TA_UPDATECP to permit the system to use and update the current position each time the application calls <b>TextOut</b> for a specified device context. When this flag is set, the system ignores the <i>nXStart</i> and <i>nYStart</i> parameters on subsequent <b>TextOut</b> calls.</para>
      <para>When the <b>TextOut</b> function is placed inside a path bracket, the system generates a path for the TrueType text that includes each character plus its character box. The region generated is the character box minus the text, rather than the text itself. You can obtain the region enclosed by the outline of the TrueType text by setting the background mode to transparent before placing the <b>TextOut</b> function in the path bracket. Following is sample code that demonstrates this procedure.</para>
      <code>
// Obtain the window's client rectangle
GetClientRect(hwnd, &amp;amp;amp;amp;amp;amp;r);

// THE FIX: by setting the background mode
// to transparent, the region is the text itself
// SetBkMode(hdc, TRANSPARENT);

// Bracket begin a path
BeginPath(hdc);

// Send some text out into the world
TCHAR text[ ] = "Defenestration can be hazardous";
TextOut(hdc,r.left,r.top,text, ARRAYSIZE(text));

// Bracket end a path
EndPath(hdc);

// Derive a region from that path
SelectClipPath(hdc, RGN_AND);

// This generates the same result as SelectClipPath()
// SelectClipRgn(hdc, PathToRegion(hdc));

// Fill the region with grayness
FillRect(hdc, &amp;amp;amp;amp;amp;amp;r, GetStockObject(GRAY_BRUSH));

</code>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/gdi/enumerating-the-installed-fonts">Enumerating the Installed Fonts</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines TextOut as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/font-and-text-functions">Font and Text Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/fonts-and-text">Fonts and Text Overview</seealso>
    <seealso cref="GetTextAlign" />
    <seealso cref="SelectObject" />
    <seealso cref="SetBkColor" />
    <seealso cref="SetTextAlign" />
    <seealso cref="SetTextColor" />
    <seealso cref="TabbedTextOut" />
  </member>
  <member name="Windows.TranslateCharsetInfo">
    <summary>
      <para>Translates character set information and sets all members of a destination structure to appropriate values.</para>
    </summary>
    <param name="lpSrc">
      <para>Pointer to the <b>fsCsb</b> member of a <see cref="FONTSIGNATURE" /> structure if <i>dwFlags</i> is set to TCI_SRCFONTSIG. Otherwise, this parameter is set to a DWORD value indicating the source.</para>
    </param>
    <param name="lpCs">
      <para>Pointer to a <see cref="CHARSETINFO" /> structure that receives the translated character set information.</para>
    </param>
    <param name="dwFlags">
      <para>Flags specifying how to perform the translation. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TCI_SRCCHARSET</b>
          </description>
          <description>
            <para>Source contains the character set value in the low word, and 0 in the high word.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TCI_SRCCODEPAGE</b>
          </description>
          <description>
            <para>Source is a code page identifier in the low word and 0 in the high word.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TCI_SRCFONTSIG</b>
          </description>
          <description>
            <para>Source is the code page bitfield portion of a <see cref="FONTSIGNATURE" /> structure. On input this should have only one Windows code-page bit set, either for an ANSI code page value or for a common ANSI and OEM value (for OEM values, bits 32-63 must be clear). On output, this has only one bit set.</para>
            <para>If the TCI_SRCFONTSIG value is given, the <i>lpSrc</i> parameter must be the address of the code-page bitfield. If any other TCI_ value is given, the <i>lpSrc</i> parameter must be a value not an address.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TCI_SRCLOCALE</b>
          </description>
          <description>
            <b>Windows 2000:</b> Source is the locale identifier (LCID) or language identifier of the keyboard layout. If it is a language identifier, the value is in the low word.
</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="CHARSETINFO" />
    <seealso cref="FONTSIGNATURE" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-set-functions">Unicode and Character Set Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-sets">Unicode and Character Sets</seealso>
  </member>
  <member name="Windows.TransparentBlt">
    <summary>
      <para>The <b>TransparentBlt</b> function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.</para>
    </summary>
    <param name="hdcDest">
      <para>A handle to the destination device context.</para>
    </param>
    <param name="xoriginDest">
      <para>The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="yoriginDest">
      <para>The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.</para>
    </param>
    <param name="wDest">
      <para>The width, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hDest">
      <para>The height, in logical units, of the destination rectangle.</para>
    </param>
    <param name="hdcSrc">
      <para>A handle to the source device context.</para>
    </param>
    <param name="xoriginSrc">
      <para>The x-coordinate, in logical units, of the source rectangle.</para>
    </param>
    <param name="yoriginSrc">
      <para>The y-coordinate, in logical units, of the source rectangle.</para>
    </param>
    <param name="wSrc">
      <para>The width, in logical units, of the source rectangle.</para>
    </param>
    <param name="hSrc">
      <para>The height, in logical units, of the source rectangle.</para>
    </param>
    <param name="crTransparent">
      <para>The RGB color in the source bitmap to treat as transparent.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The <b>TransparentBlt</b> function works with compatible bitmaps (DDBs).</para>
      <para>The <b>TransparentBlt</b> function supports all formats of source bitmaps. However, for 32 bpp bitmaps, it just copies the alpha value over. Use <see cref="AlphaBlend" /> to specify 32 bits-per-pixel bitmaps with transparency.</para>
      <para>If the source and destination rectangles are not the same size, the source bitmap is stretched to match the destination rectangle. When the <see cref="SetStretchBltMode" /> function is used, the <i>iStretchMode</i> modes of BLACKONWHITE and WHITEONBLACK are converted to COLORONCOLOR for the <b>TransparentBlt</b> function.</para>
      <para>The destination device context specifies the transformation type for the destination coordinates. The source device context specifies the transformation type for the source coordinates.</para>
      <para>
        <b>TransparentBlt</b> does not mirror a bitmap if either the width or height, of either the source or destination, is negative.</para>
      <para>When used in a multiple monitor system, both <i>hdcSrc</i> and <i>hdcDest</i> must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling <see cref="GetDIBits" />. To display the DIB to the second device, call <see cref="SetDIBits" /> or <see cref="StretchDIBits" />.</para>
    </remarks>
    <seealso cref="AlphaBlend" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmap-functions">Bitmap Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/bitmaps">Bitmaps Overview</seealso>
    <seealso cref="GetDIBits" />
    <seealso cref="SetDIBits" />
    <seealso cref="SetStretchBltMode" />
    <seealso cref="StretchDIBits" />
  </member>
  <member name="Windows.UnrealizeObject">
    <summary>
      <para>The <b>UnrealizeObject</b> function resets the origin of a brush or resets a logical palette. If the <i>hgdiobj</i> parameter is a handle to a brush, <b>UnrealizeObject</b> directs the system to reset the origin of the brush the next time it is selected. If the <i>hgdiobj</i> parameter is a handle to a logical palette, <b>UnrealizeObject</b> directs the system to realize the palette as though it had not previously been realized. The next time the application calls the <see cref="RealizePalette" /> function for the specified palette, the system completely remaps the logical palette to the system palette.</para>
    </summary>
    <param name="h">
      <para>A handle to the logical palette to be reset.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>UnrealizeObject</b> function should not be used with stock objects. For example, the default palette, obtained by calling <see cref="GetStockObject" /> (DEFAULT_PALETTE), is a stock object.</para>
      <para>A palette identified by <i>hgdiobj</i> can be the currently selected palette of a device context.</para>
      <para>If <i>hgdiobj</i> is a brush, <b>UnrealizeObject</b> does nothing, and the function returns <b>TRUE</b>. Use <see cref="SetBrushOrgEx" /> to set the origin of a brush.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetStockObject" />
    <seealso cref="RealizePalette" />
    <seealso cref="SetBrushOrgEx" />
  </member>
  <member name="Windows.UpdateColors">
    <summary>
      <para>The <b>UpdateColors</b> function updates the client area of the specified device context by remapping the current colors in the client area to the currently realized logical palette.</para>
    </summary>
    <param name="hdc">
      <para>A handle to the device context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can determine whether a device supports palette operations by calling the <see cref="GetDeviceCaps" /> function and specifying the RASTERCAPS constant.</para>
      <para>An inactive window with a realized logical palette may call <b>UpdateColors</b> as an alternative to redrawing its client area when the system palette changes.</para>
      <para>The <b>UpdateColors</b> function typically updates a client area faster than redrawing the area. However, because <b>UpdateColors</b> performs the color translation based on the color of each pixel before the system palette changed, each call to this function results in the loss of some color accuracy.</para>
      <para>This function must be called soon after a <a href="https://docs.microsoft.com//windows/desktop/gdi/wm-palettechanged">WM_PALETTECHANGED</a> message is received.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/color-functions">Color Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colors">Colors Overview</seealso>
    <seealso cref="GetDeviceCaps" />
    <seealso cref="RealizePalette" />
  </member>
  <member name="Windows.UpdateICMRegKey">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.UpdateICMRegKeyA">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.UpdateICMRegKeyW">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.UpdateICMRegKey">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.UpdateICMRegKeyA">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.UpdateICMRegKeyW">
    <summary>
      <para>
        <i>(Obsolete; retained for backward compatibility)</i>
      </para>
      <para>The <b>UpdateICMRegKey</b> function manages color profiles and Color Management Modules in the system.</para>
    </summary>
    <param name="reserved">
      <para>Reserved, must be set to zero.</para>
    </param>
    <param name="lpszCMID">
      <para>Points to a string that specifies the ICC profile identifier for the color management DLL to use with the profile.</para>
    </param>
    <param name="lpszFileName">
      <para>Points to a fully qualified ICC color profile file name or to a <b>DEVMODE</b> structure.</para>
    </param>
    <param name="command">
      <para>Specifies a function to execute. It can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ICM_ADDPROFILE</b>
          </description>
          <description>
            <para>Installs the ICC profile in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_DELETEPROFILE</b>
          </description>
          <description>
            <para>Uninstalls the ICC profile from the system, but does not delete the file.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYPROFILE</b>
          </description>
          <description>
            <para>Determines whether the profile is already installed in the system.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_SETDEFAULTPROFILE</b>
          </description>
          <description>
            <para>Makes the profile first among equals.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_REGISTERICMATCHER</b>
          </description>
          <description>
            <para>Registers a CMM in the system. The <i>pszFileName</i> parameter points to a fully qualified path for the CMM DLL. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_UNREGISTERICMATCHER</b>
          </description>
          <description>
            <para>Unregisters the CMM from the system. The <i>lpszCMID</i> parameter points to a <b>DWORD</b> identifying the CMM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ICM_QUERYMATCH</b>
          </description>
          <description>
            <para>Determines whether a profile exists based on the <b>DEVMODE</b> structure pointed to by the <i>pszFileName</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If this function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If this function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Not all parameters are used by all functions. The <i>nCommand</i> parameter specifies the function to execute.</para>
      <para>This function is retained for backward compatibility and may be removed in future versions of ICM.</para>
      <para>
        <b>Windows 95/98/Me: </b>
        <b>UpdateICMRegKeyW</b> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in <a href="https://msdn.microsoft.com/library?url=/library/mslu/winprog/microsoft_layer_for_unicode_on_windows_95_98_me_systems.asp">Microsoft Layer for Unicode on Windows 95/98/Me Systems</a>.</para>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines UpdateICMRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/basic-color-management-concepts">Basic color management concepts</seealso>
    <seealso href="https://docs.microsoft.com//windows/win32/wcs/obsolete-wcs-functions">Obsolete WCS functions</seealso>
  </member>
  <member name="Windows.wglCopyContext">
    <summary>
      <para>The <b>wglCopyContext</b> function copies selected groups of rendering states from one OpenGL rendering context to another.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the source OpenGL rendering context whose state information is to be copied.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the destination OpenGL rendering context to which state information is to be copied.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies which groups of the <i>hglrcSrc</i> rendering state are to be copied to <i>hglrcDst</i>. It contains the bitwise-OR of the same symbolic names that are passed to the <b>glPushAttrib</b> function. You can use GL_ALL_ATTRIB_BITS to copy all the rendering state information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Using the <b>wglCopyContext</b> function, you can synchronize the rendering state of two rendering contexts. You can only copy the rendering state between two rendering contexts within the same process. The rendering contexts must be from the same OpenGL implementation. For example, you can always copy a rendering state between two rendering contexts with identical pixel format in the same process.</para>
      <para>You can copy the same state information available only with the <b>glPushAttrib</b> function. You cannot copy some state information, such as pixel pack/unpack state, render mode state, select state, and feedback state. When you call <b>wglCopyContext</b>, make sure that the destination rendering context, <i>hglrcDst</i>, is not current to any thread.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glpushattrib">glPushAttrib</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglCreateLayerContext" />
    <seealso cref="wglShareLists" />
  </member>
  <member name="Windows.wglCreateContext">
    <summary>
      <para>The <b>wglCreateContext</b> function creates a new OpenGL rendering context, which is suitable for drawing on the device referenced by <i>hdc</i>. The rendering context has the same pixel format as the device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Handle to a device context for which the function creates a suitable OpenGL rendering context.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a valid handle to an OpenGL rendering context.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A rendering context is not the same as a device context. Set the pixel format of the device context before creating a rendering context. For more information on setting the device context's pixel format, see the <see cref="SetPixelFormat" /> function.</para>
      <para>To use OpenGL, you create a rendering context, select it as a thread's current rendering context, and then call OpenGL functions. When you are finished with the rendering context, you dispose of it by calling the <see cref="wglDeleteContext" /> function.</para>
      <para>The following code example shows <b>wglCreateContext</b> usage.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// call OpenGL APIs as desired ...

// when the rendering context is no longer needed ...

// make the rendering context not current
wglMakeCurrent (NULL, NULL) ;

// delete the rendering context
wglDeleteContext (hglrc);
</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="SetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglDeleteContext" />
    <seealso cref="wglGetCurrentContext" />
    <seealso cref="wglGetCurrentDC" />
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglCreateLayerContext">
    <summary>
      <para>The <b>wglCreateLayerContext</b> function creates a new OpenGL rendering context for drawing to a specified layer plane on a device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context for a new rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the layer plane to which you want to bind a rendering context. The value 0 identifies the main plane. Positive values of <i>iLayerPlane</i> identify overlay planes, where 1 is the first overlay plane over the main plane, 2 is the second overlay plane over the first overlay plane, and so on. Negative values identify underlay planes, where 1 is the first underlay plane under the main plane, 2 is the second underlay plane under the first underlay plane, and so on. The number of overlay and underlay planes is given in the <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to an OpenGL rendering context.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A rendering context is a port through which all OpenGL commands pass. Every thread that makes OpenGL calls must have one current, active rendering context. A rendering context is not the same as a device context; a rendering context contains information specific to OpenGL, while a device context contains information specific to GDI.</para>
      <para>Before you create a rendering context, set the pixel format of the device context with the <see cref="SetPixelFormat" /> function. You can use a rendering context in a specified layer plane of a window with identical pixel formats only.</para>
      <para>With OpenGL applications that use multiple threads, you create a rendering context, select it as the current rendering context of a thread, and make OpenGL calls for the specified thread. When you are finished with the rendering context of the thread, call the <see cref="wglDeleteContext" /> function.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglCreateLayerContext</b>.</para>
      <code>// The following code fragment shows how to render to overlay 1
// This example assumes that the pixel format of hdc includes
// overlay plane 1

HDC hdc;
HGLRC;

// create a rendering context for overlay plane 1
hglrc = wglCreateLayerContext(hdc, 1);

// make it the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// call OpenGL functions here. . .

// when the rendering context is no longer needed. . .

// make the rendering context not current
wglMakeCurrent(NULL, NULL);

// delete the rendering context
wglDeleteContext(hglrc);
</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso cref="SetPixelFormat" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglDeleteContext" />
    <seealso cref="wglGetCurrentContext" />
    <seealso cref="wglGetCurrentDC" />
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglDeleteContext">
    <summary>
      <para>The <b>wglDeleteContext</b> function deletes a specified OpenGL rendering context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Handle to an OpenGL rendering context that the function will delete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is an error to delete an OpenGL rendering context that is the current context of another thread. However, if a rendering context is the calling thread's current context, the <b>wglDeleteContext</b> function changes the rendering context to being not current before deleting it.</para>
      <para>The <b>wglDeleteContext</b> function does not delete the device context associated with the OpenGL rendering context when you call the <b>wglMakeCurrent</b> function. After calling <b>wglDeleteContext</b>, you must call <see cref="DeleteDC" /> to delete the associated device context.</para>
    </remarks>
    <seealso cref="DeleteDC" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglGetCurrentContext" />
    <seealso cref="wglGetCurrentDC" />
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglDescribeLayerPlane">
    <summary>
      <para>The <b>wglDescribeLayerPlane</b> function obtains information about the layer planes of a given pixel format.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context of a window whose layer planes are to be described.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies which layer planes of a pixel format are being described.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the overlay or underlay plane. Positive values of <i>iLayerPlane</i> identify overlay planes, where 1 is the first overlay plane over the main plane, 2 is the second overlay plane over the first overlay plane, and so on. Negative values identify underlay planes, where 1 is the first underlay plane under the main plane, 2 is the second underlay plane under the first underlay plane, and so on. The number of overlay and underlay planes is given in the <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies the size, in bytes, of the structure pointed to by <i>plpd</i>. The <b>wglDescribeLayerPlane</b> function stores layer plane data in a <see cref="LAYERPLANEDESCRIPTOR" /> structure, and stores no more than <i>nBytes</i> of data. Set the value of <i>nBytes</i> to the size of <b>LAYERPLANEDESCRIPTOR</b>.</para>
    </param>
    <param name="unnamedParam5">
      <para>Points to a <b>LAYERPLANEDESCRIPTOR</b> structure. The <b>wglDescribeLayerPlane</b> function sets the value of the structure's data members. The function stores the number of bytes of data copied to the structure in the <b>nSize</b> member.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. In addition, the <b>wglDescribeLayerPlane</b> function sets the members of the <b>LAYERPLANEDESCRIPTOR</b> structure pointed to by <i>plpd</i> according to the specified layer plane (<i>iLayerPlane</i> ) of the specified pixel format (<i>iPixelFormat</i> ).</para>
      <para>If the function fails, the return value is <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The numbering of planes (<i>iLayerPlane</i> ) determines their order. Higher-numbered planes overlay lower-numbered planes.</para>
    </remarks>
    <seealso cref="DescribePixelFormat" />
    <seealso cref="LAYERPLANEDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateLayerContext" />
  </member>
  <member name="Windows.wglGetCurrentContext">
    <summary>
      <para>The <b>wglGetCurrentContext</b> function obtains a handle to the current OpenGL rendering context of the calling thread.</para>
    </summary>
    <returns>
      <para>If the calling thread has a current OpenGL rendering context, <b>wglGetCurrentContext</b> returns a handle to that rendering context. Otherwise, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The current OpenGL rendering context of a thread is associated with a device context by means of the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentDC</b> function to obtain a handle to the device context associated with the current OpenGL rendering context.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglDeleteContext" />
    <seealso cref="wglGetCurrentDC" />
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglGetCurrentDC">
    <summary>
      <para>The <b>wglGetCurrentDC</b> function obtains a handle to the device context that is associated with the current OpenGL rendering context of the calling thread.</para>
    </summary>
    <returns>
      <para>If the calling thread has a current OpenGL rendering context, the function returns a handle to the device context associated with that rendering context by means of the <b>wglMakeCurrent</b> function. Otherwise, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>You associate a device context with an OpenGL rendering context when it calls the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentContext</b> function to obtain a handle to the calling thread's current OpenGL rendering context.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglDeleteContext" />
    <seealso cref="wglGetCurrentContext" />
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglGetLayerPaletteEntries">
    <summary>
      <para>Retrieves the palette entries from a given color-index layer plane for a specified device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Type: <b>HDC</b></para>
      <para>The device context of a window whose layer planes are to be described.</para>
    </param>
    <param name="unnamedParam2">
      <para>Type: <b>int</b></para>
      <para>The overlay or underlay plane. Positive values of <i>iLayerPlane</i> identify overlay planes, where 1 is the first overlay plane over the main plane, 2 is the second overlay plane over the first overlay plane, and so on. Negative values identify underlay planes, where 1 is the first underlay plane under the main plane, 2 is the second underlay plane under the first underlay plane, and so on. The number of overlay and underlay planes is given in the <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure.</para>
    </param>
    <param name="unnamedParam3">
      <para>Type: <b>int</b></para>
      <para>The first palette entry to be retrieved.</para>
    </param>
    <param name="unnamedParam4">
      <para>Type: <b>int</b></para>
      <para>The number of palette entries to be retrieved.</para>
    </param>
    <param name="unnamedParam5">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a>*</b></para>
      <para>An array of structures that contain palette RGB color values. The array must contain at least as many structures as specified by <i>cEntries</i>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the function succeeds, the return value is the number of entries that were set in the palette in the specified layer plane of the window.</para>
      <para>If the function fails or when no pixel format is selected, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each color-index layer plane in a window has a palette with a size 2^<i>n</i>, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette.</para>
      <para>Use the <see cref="wglRealizeLayerPalette" /> function to realize the layer palette. Initially the layer palette contains only entries for white.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</seealso>
    <seealso cref="LAYERPLANEDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglDescribeLayerPlane" />
    <seealso cref="wglRealizeLayerPalette" />
    <seealso cref="wglSetLayerPaletteEntries" />
  </member>
  <member name="Windows.wglGetProcAddress">
    <summary>
      <para>The <b>wglGetProcAddress</b> function returns the address of an OpenGL extension function for use with the current OpenGL rendering context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Points to a <b>null</b>-terminated string that is the name of the extension function. The name of the extension function must be identical to a corresponding function implemented by OpenGL.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is the address of the extension function.</para>
      <para>When no current rendering context exists or the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The OpenGL library supports multiple implementations of its functions. Extension functions supported in one rendering context are not necessarily available in a separate rendering context. Thus, for a given rendering context in an application, use the function addresses returned by the <b>wglGetProcAddress</b> function only.</para>
      <para>The spelling and the case of the extension function pointed to by <i>lpszProc</i> must be identical to that of a function supported and implemented by OpenGL. Because extension functions are not exported by OpenGL, you must use <b>wglGetProcAddress</b> to get the addresses of vendor-specific extension functions.</para>
      <para>The extension function addresses are unique for each pixel format. All rendering contexts of a given pixel format share the same extension function addresses.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glgetstring">glGetString</seealso>
    <seealso cref="wglMakeCurrent" />
  </member>
  <member name="Windows.wglMakeCurrent">
    <summary>
      <para>The <b>wglMakeCurrent</b> function makes a specified OpenGL rendering context the calling thread's current rendering context. All subsequent OpenGL calls made by the thread are drawn on the device identified by <i>hdc</i>. You can also use <b>wglMakeCurrent</b> to change the calling thread's current rendering context so it's no longer current.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Handle to a device context. Subsequent OpenGL calls made by the calling thread are drawn on the device identified by <i>hdc</i>.</para>
    </param>
    <param name="unnamedParam2">
      <para>Handle to an OpenGL rendering context that the function sets as the calling thread's rendering context.</para>
      <para>If <i>hglrc</i> is <b>NULL</b>, the function makes the calling thread's current rendering context no longer current, and releases the device context that is used by the rendering context. In this case, <i>hdc</i> is ignored.</para>
    </param>
    <returns>
      <para>When the <b>wglMakeCurrent</b> function succeeds, the return value is <b>TRUE</b>; otherwise the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <i>hdc</i> parameter must refer to a drawing surface supported by OpenGL. It need not be the same <i>hdc</i> that was passed to <see cref="wglCreateContext" /> when <i>hglrc</i> was created, but it must be on the same device and have the same pixel format. GDI transformation and clipping in <i>hdc</i> are not supported by the rendering context. The current rendering context uses the <i>hdc</i> device context until the rendering context is no longer current.</para>
      <para>Before switching to the new rendering context, OpenGL flushes any previous rendering context that was current to the calling thread.</para>
      <para>A thread can have one current rendering context. A process can have multiple rendering contexts by means of multithreading. A thread must set a current rendering context before calling any OpenGL functions. Otherwise, all OpenGL calls are ignored.</para>
      <para>A rendering context can be current to only one thread at a time. You cannot make a rendering context current to multiple threads.</para>
      <para>An application can perform multithread drawing by making different rendering contexts current to different threads, supplying each thread with its own rendering context and device context.</para>
      <para>If an error occurs, the <b>wglMakeCurrent</b> function makes the thread's current rendering context not current before returning.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglCreateContext" />
    <seealso cref="wglDeleteContext" />
    <seealso cref="wglGetCurrentContext" />
    <seealso cref="wglGetCurrentDC" />
  </member>
  <member name="Windows.wglRealizeLayerPalette">
    <summary>
      <para>The <b>wglRealizeLayerPalette</b> function maps palette entries from a given color-index layer plane into the physical palette or initializes the palette of an RGBA layer plane.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context of a window whose layer plane palette is to be realized into the physical palette.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the overlay or underlay plane. Positive values of <i>iLayerPlane</i> identify overlay planes, where 1 is the first overlay plane over the main plane, 2 is the second overlay plane over the first overlay plane, and so on. Negative values identify underlay planes, where 1 is the first underlay plane under the main plane, 2 is the second underlay plane under the first underlay plane, and so on. The number of overlay and underlay planes is given in the <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure.</para>
    </param>
    <param name="unnamedParam3">
      <para>Indicates whether the palette is to be realized into the physical palette. When <i>bRealize</i> is <b>TRUE</b>, the palette entries are mapped into the physical palette where available. When <i>bRealize</i> is <b>FALSE</b>, the palette entries for the layer plane of the window are no longer needed and might be released for use by another foreground window.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>, even if <i>bRealize</i> is <b>TRUE</b> and the physical palette is not available. If the function fails or when no pixel format is selected, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The physical palette for a layer plane is a shared resource among windows with layer planes. When more than one window attempts to realize a palette for a given physical layer plane, only one palette at a time is realized. When you call the <b>wglRealizeLayerPalette</b> function, the layer palette of a foreground window is always realized first.</para>
      <para>When a window's layer palette is realized, its palette entries are always mapped one-to-one into the physical palette. Unlike GDI logical palettes, with <b>wglRealizeLayerPalette</b> there is no mapping of other windows' layer palettes to the current physical palette.</para>
      <para>Whenever a window becomes the foreground window, call <b>wglRealizeLayerPalette</b> to realize its layer palettes again, even if the pixel type of the layer plane is RGBA.</para>
      <para>Because <b>wglRealizeLayerPalette</b> doesn't realize the palette of the main plane, use GDI palette functions to realize the main plane palette.</para>
    </remarks>
    <seealso cref="LAYERPLANEDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglDescribeLayerPlane" />
    <seealso cref="wglGetLayerPaletteEntries" />
    <seealso cref="wglRealizeLayerPalette" />
    <seealso cref="wglSetLayerPaletteEntries" />
  </member>
  <member name="Windows.wglSetLayerPaletteEntries">
    <summary>
      <para>Sets the palette entries in a given color-index layer plane for a specified device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Type: <b>HDC</b></para>
      <para>The device context of a window whose layer palette is to be set.</para>
    </param>
    <param name="unnamedParam2">
      <para>Type: <b>int</b></para>
      <para>An overlay or underlay plane. Positive values of <i>iLayerPlane</i> identify overlay planes, where 1 is the first overlay plane over the main plane, 2 is the second overlay plane over the first overlay plane, and so on. Negative values identify underlay planes, where 1 is the first underlay plane under the main plane, 2 is the second underlay plane under the first underlay plane, and so on. The number of overlay and underlay planes is given in the <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure.</para>
    </param>
    <param name="unnamedParam3">
      <para>Type: <b>int</b></para>
      <para>The first palette entry to be set.</para>
    </param>
    <param name="unnamedParam4">
      <para>Type: <b>int</b></para>
      <para>The number of palette entries to be set.</para>
    </param>
    <param name="unnamedParam5">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a>*</b></para>
      <para>A pointer to the first member of an array of <i>cEntries</i> structures that contain RGB color information.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the function succeeds, the return value is the number of entries that were set in the palette in the specified layer plane of the window. If the function fails or no pixel format is selected, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each color-index plane in a window has a palette with a size 2^n, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette.</para>
      <para>Use the <b>wglRealizeLayerPalette</b> function to realize the layer palette. Initially the layer palette contains only entries for white.</para>
      <para>The <b>wglSetLayerPaletteEntries</b> function doesn't set the palette entries of the main plane palette. To update the main plane palette, use GDI palette functions.</para>
    </remarks>
    <seealso cref="LAYERPLANEDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso cref="wglDescribeLayerPlane" />
    <seealso cref="wglGetLayerPaletteEntries" />
    <seealso cref="wglRealizeLayerPalette" />
  </member>
  <member name="Windows.wglShareLists">
    <summary>
      <para>The <b>wglShareLists</b> function enables multiple OpenGL rendering contexts to share a single display-list space.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the OpenGL rendering context with which to share display lists.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the OpenGL rendering context to share display lists with <i>hglrc1</i>. The <i>hglrc2</i> parameter should not contain any existing display lists when <b>wglShareLists</b> is called.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and the display lists are not shared. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When you create an OpenGL rendering context, it has its own display-list space. The <b>wglShareLists</b> function enables a rendering context to share the display-list space of another rendering context; any number of rendering contexts can share a single display-list space. Once a rendering context shares a display-list space, the rendering context always uses the display-list space until the rendering context is deleted. When the last rendering context of a shared display-list space is deleted, the shared display-list space is deleted. All the indexes and definitions of display lists in a shared display-list space are shared.</para>
      <para>You can only share display lists with rendering contexts within the same process. However, not all rendering contexts in a process can share display lists. Rendering contexts can share display lists only if they use the same implementation of OpenGL functions. All client rendering contexts of a given pixel format can always share display lists.</para>
      <para>All rendering contexts of a shared display list must use an identical pixel format. Otherwise the results depend on the implementation of OpenGL used.</para>
      <para>
        <b>Note</b>  The <b>wglShareLists</b> function is only available with OpenGL version 1.01 or later. To determine the version number of the implementation of OpenGL, call <b>glGetString</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glgetstring">glGetString</seealso>
  </member>
  <member name="Windows.wglSwapLayerBuffers">
    <summary>
      <para>The <b>wglSwapLayerBuffers</b> function swaps the front and back buffers in the overlay, underlay, and main planes of the window referenced by a specified device context.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context of a window whose layer plane palette is to be realized into the physical palette.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the overlay, underlay, and main planes whose front and back buffers are to be swapped. The <b>bReserved</b> member of the <see cref="PIXELFORMATDESCRIPTOR" /> structure specifies the number of overlay and underlay planes. The <i>fuPlanes</i> parameter is a bitwise combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>WGL_SWAP_MAIN_PLANE</b>
          </description>
          <description>
            <para>Swaps the front and back buffers of the main plane.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WGL_SWAP_OVERLAYi</b>
          </description>
          <description>
            <para>Swaps the front and back buffers of the overlay plane <i>i</i>, where <i>i</i> is an integer between 1 and 15. WGL_SWAP_OVERLAY1 identifies the first overlay plane over the main plane, WGL_SWAP_OVERLAY2 identifies the second overlay plane over the first overlay plane, and so on.</para>
          </description>
        </item>
        <item>
          <description>
            <b>WGL_SWAP_UNDERLAYi</b>
          </description>
          <description>
            <para>Swaps the front and back buffers of the underlay plane <i>i</i>, where <i>i</i> is an integer between 1 and 15. WGL_SWAP_UNDERLAY1 identifies the first underlay plane under the main plane, WGL_SWAP_UNDERLAY2 identifies the second underlay plane under the first underlay plane, and so on.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a layer plane doesn't include a back buffer, calling the <b>wglSwapLayerBuffers</b> function has no effect on that layer plane. After you call <b>wglSwapLayerBuffers</b>, the state of the back buffer content is given in the corresponding <b>LAYERPLANEDESCRIPTOR</b> structure of the layer plane or in the <b>PIXELFORMATDESCRIPTOR</b> structure of the main plane. The <b>wglSwapLayerBuffers</b> function swaps the front and back buffers in the specified layer planes simultaneously.</para>
      <para>Some devices don't support swapping layer planes individually; they swap all layer planes as a group. When the PFD_SWAP_LAYER_BUFFERS flag of the <b>PIXELFORMATDESCRIPTOR</b> structure is set, it indicates that a device can swap individual layer planes and that you can call <b>wglSwapLayerBuffers</b>.</para>
      <para>With applications that use multiple threads, before calling <b>wglSwapLayerBuffers</b>, clear all drawing commands in all threads drawing to the same window.</para>
    </remarks>
    <seealso cref="LAYERPLANEDESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso cref="PIXELFORMATDESCRIPTOR" />
    <seealso cref="SwapBuffers" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
  </member>
  <member name="Windows.wglUseFontBitmaps">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontBitmapsA">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontBitmapsW">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontBitmaps">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontBitmapsA">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontBitmapsW">
    <summary>
      <para>The <b>wglUseFontBitmaps</b> function creates a set of bitmap display lists for use in the current OpenGL rendering context. The set of bitmap display lists is based on the glyphs in the currently selected font in the device context. You can then use bitmaps to draw characters in an OpenGL image.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates <i>count</i> display lists, one for each of a run of <i>count</i> glyphs that begins with the first glyph in the <i>hdc</i> parameter's selected fonts.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context whose currently selected font will be used to form the glyph bitmap display lists in the current OpenGL rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first glyph in the run of glyphs that will be used to form glyph bitmap display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the run of glyphs that will be used to form glyph bitmap display lists. The function creates <i>count</i> display lists, one for each glyph in the run.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.</para>
      <para>The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.</para>
      <para>In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.</para>
      <para>The function determines the parameters of each call to <b>glBitmap</b> as follows.</para>
      <list type="table">
        <listheader>
          <description>glBitmap Parameter</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>width</i>
          </description>
          <description>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <see cref="GLYPHMETRICS" /> structure.</description>
        </item>
        <item>
          <description>
            <i>height</i>
          </description>
          <description>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xorig</i>
          </description>
          <description>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>yorig</i>
          </description>
          <description>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>xmove</i>
          </description>
          <description>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>ymove</i>
          </description>
          <description>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</description>
        </item>
        <item>
          <description>
            <i>bitmap</i>
          </description>
          <description>The bitmap for the glyph, as returned by <see cref="GetGlyphOutline" /> with <i>uFormat</i> equal to 1.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following code example shows how to use <b>wglUseFontBitmaps</b> to draw some text.</para>
      <code>HDC    hdc;
HGLRC  hglrc;

// create a rendering context
hglrc = wglCreateContext (hdc);

// make it the calling thread's current rendering context
wglMakeCurrent (hdc, hglrc);

// now we can call OpenGL API

// make the system font the device context's selected font
SelectObject (hdc, GetStockObject (SYSTEM_FONT));

// create the bitmap display lists
// we're making images of glyphs 0 thru 254
// the display list numbering starts at 1000, an arbitrary choice
wglUseFontBitmaps (hdc, 0, 255, 1000);

// display a string:
// indicate start of glyph display lists
glListBase (1000);
// now draw the characters in a string
glCallLists (24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontBitmaps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICS" />
    <seealso cref="GetGlyphOutline" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glbitmap">glBitmap</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso cref="wglUseFontOutlines" />
  </member>
  <member name="Windows.wglUseFontOutlines">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.wglUseFontOutlinesA">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.wglUseFontOutlinesW">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.wglUseFontOutlines">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.wglUseFontOutlinesA">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.wglUseFontOutlinesW">
    <summary>
      <para>The <b>wglUseFontOutlines</b> function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. The display lists are used to draw 3-D characters of TrueType fonts. Each display list describes a glyph outline in floating-point coordinates.</para>
      <para>The run of glyphs begins with thefirstglyph of the font of the specified device context. The em square size of the font, the notional grid size of the original font outline from which the font is fitted, is mapped to 1.0 in the x- and y-coordinates in the display lists. The extrusion parameter sets how much depth the font has in the z direction.</para>
      <para>Thelpgmfparameter returns a <see cref="GLYPHMETRICSFLOAT" /> structure that contains information about the placement and orientation of each glyph in a character cell.</para>
    </summary>
    <param name="unnamedParam1">
      <para>Specifies the device context with the desired outline font. The outline font of <i>hdc</i> is used to create the display lists in the current rendering context.</para>
    </param>
    <param name="unnamedParam2">
      <para>Specifies the first of the set of glyphs that form the font outline display lists.</para>
    </param>
    <param name="unnamedParam3">
      <para>Specifies the number of glyphs in the set of glyphs used to form the font outline display lists. The <b>wglUseFontOutlines</b> function creates <i>count</i> display lists, one display list for each glyph in a set of glyphs.</para>
    </param>
    <param name="unnamedParam4">
      <para>Specifies a starting display list.</para>
    </param>
    <param name="unnamedParam5">
      <para>Specifies the maximum chordal deviation from the original outlines. When deviation is zero, the chordal deviation is equivalent to one design unit of the original font. The value of <i>deviation</i> must be equal to or greater than 0.</para>
    </param>
    <param name="unnamedParam6">
      <para>Specifies how much a font is extruded in the negative <i>z</i> direction. The value must be equal to or greater than 0. When <i>extrusion</i> is 0, the display lists are not extruded.</para>
    </param>
    <param name="unnamedParam7">
      <para>Specifies the format, either WGL_FONT_LINES or WGL_FONT_POLYGONS, to use in the display lists. When <i>format</i> is WGL_FONT_LINES, the <b>wglUseFontOutlines</b> function creates fonts with line segments. When <i>format</i> is WGL_FONT_POLYGONS, <b>wglUseFontOutlines</b> creates fonts with polygons.</para>
    </param>
    <param name="unnamedParam8">
      <para>Points to an array of <i>count</i><see cref="GLYPHMETRICSFLOAT" /> structures that is to receive the metrics of the glyphs. When <i>lpgmf</i> is <b>NULL</b>, no glyph metrics are returned.</para>
    </param>
    <returns>
      <para>When the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.</para>
      <para>Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.</para>
      <para>The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:</para>
      <code>glCullFace(GL_BACK);
glEnable(GL_CULL_FACE);
</code>
      <para>A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</a>.</para>
      <para>
        <b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <see cref="wglUseFontBitmaps" />, when using double-buffered device contexts.</para>
      <h4>Examples</h4>
      <para>The following code example shows how to draw text using <b>wglUseFontOutlines</b>.</para>
      <code>HDC    hdc;  // A TrueType font has already been selected
HGLRC  hglrc;
GLYPHMETRICSFLOAT agmf[256];

// Make hglrc the calling thread's current rendering context
wglMakeCurrent(hdc, hglrc);

// create display lists for glyphs 0 through 255 with 0.1 extrusion
// and default deviation. The display list numbering starts at 1000
// (it could be any number)
wglUseFontOutlines(hdc, 0, 255, 1000, 0.0f, 0.1f,
            WGL_FONT_POLYGONS, &amp;amp;amp;amp;amp;amp;agmf);

// Set up transformation to draw the string
glLoadIdentity();
glTranslate(0.0f, 0.0f, -5.0f)
glScalef(2.0f, 2.0f, 2.0f);

// Display a string
glListBase(1000); // Indicates the start of display lists for the glyphs
// Draw the characters in a string
glCallLists(24, GL_UNSIGNED_BYTE, "Hello Windows OpenGL World.");
</code>
      <blockquote>
        <para>[!NOTE]
The wingdi.h header defines wglUseFontOutlines as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GLYPHMETRICSFLOAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/opengl-on-windows-nt--windows-2000--and-windows-95-98">OpenGL on Windows</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/wgl-functions">WGL Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/glcalllists">glCallLists</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gllistbase">glListBase</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/OpenGL/gltexgen-functions">glTexGen</seealso>
    <seealso cref="wglUseFontBitmaps" />
  </member>
  <member name="Windows.WidenPath">
    <summary>
      <para>The <b>WidenPath</b> function redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the given device context.</para>
    </summary>
    <param name="hdc">
      <para>A handle to a device context that contains a closed path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>WidenPath</b> function is successful only if the current pen is a geometric pen created by the <see cref="ExtCreatePen" /> function, or if the pen is created with the <see cref="CreatePen" /> function and has a width, in device units, of more than one.</para>
      <para>The device context identified by the <i>hdc</i> parameter must contain a closed path.</para>
      <para>Any Bézier curves in the path are converted to sequences of straight lines approximating the widened curves. As such, no Bézier curves remain in the path after <b>WidenPath</b> is called.</para>
    </remarks>
    <seealso cref="BeginPath" />
    <seealso cref="CreatePen" />
    <seealso cref="EndPath" />
    <seealso cref="ExtCreatePen" />
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/path-functions">Path Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/gdi/paths">Paths Overview</seealso>
    <seealso cref="SetMiterLimit" />
  </member>
</doc>