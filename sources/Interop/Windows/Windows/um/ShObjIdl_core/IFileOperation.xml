<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="IFileOperation.Advise">
    <summary>
      <para>Enables a handler to provide status and error information for all operations.</para>
    </summary>
    <param name="pfops">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for progress status and error notifications.</para>
    </param>
    <param name="pdwCookie">
      <para>Type: <b>DWORD*</b></para>
      <para>When this method returns, this parameter points to a returned token that uniquely identifies this connection. The calling application uses this token later to delete the connection by passing it to <see cref="IFileOperation.Unadvise" />. If the call to <b>Advise</b> fails, this value is meaningless.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Several individual methods have the ability to declare their own progress sinks, which are redundant to the one set here. They are used when you only want to be given progress and error information for a specific operation.</para>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.Unadvise" />
  </member>
  <member name="IFileOperation.ApplyPropertiesToItem">
    <summary>
      <para>Declares a single item whose property values are to be set.</para>
    </summary>
    <param name="psiItem">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to the item to receive the new property values.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not apply the properties to the item, it merely declares the item. To set property values on an item, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <see cref="IFileOperation.SetProperties" /> to declare the specific properties to be set and their new values.</description>
        </item>
        <item>
          <description>Call <b>IFileOperation.ApplyPropertiesToItem</b> to declare the item whose properties are to be set.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to apply the properties to the item.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.ApplyPropertiesToItems" />
  </member>
  <member name="IFileOperation.ApplyPropertiesToItems">
    <summary>
      <para>Declares a set of items for which to apply a common set of property values.</para>
    </summary>
    <param name="punkItems">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>Pointer to the <see cref="IUnknown" /> of the <see cref="IShellItemArray" />, <see cref="IDataObject" />, or <see cref="IEnumShellItems" /> object which represents the group of items.  You can also point to an <see cref="IPersistIDList" /> object to represent a single item, effectively accomplishing the same function as <see cref="IFileOperation.ApplyPropertiesToItem" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not apply the properties to the items, it merely declares the items. To set property values on a group of items, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <see cref="IFileOperation.SetProperties" /> to declare the specific properties to be set and their new values.</description>
        </item>
        <item>
          <description>Call <b>IFileOperation.ApplyPropertiesToItems</b> to declare the items whose property values are to be set.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to apply the properties to the items.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.ApplyPropertiesToItem" />
  </member>
  <member name="IFileOperation.CopyItem">
    <summary>
      <para>Declares a single item that is to be copied to a specified destination.</para>
    </summary>
    <param name="psiItem">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the source item.</para>
    </param>
    <param name="psiDestinationFolder">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the destination folder to contain the copy of the item.</para>
    </param>
    <param name="pszCopyName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to a new name for the item after it has been copied. This is a null-terminated Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the source.</para>
    </param>
    <param name="pfopsItem">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for progress status and error notifications for this specific copy operation. If you call <see cref="IFileOperation.Advise" /> for the overall operation, progress status and error notifications for the copy operation are included there, so set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not copy the item, it merely declares the item to be copied. To copy an object, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.CopyItem</b> to declare the source item, destination folder, and destination name.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the copy operation.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The following example code shows a sample implementation of this method.</para>
      <code>HRESULT CopyItem(__in PCWSTR pszSrcItem, __in PCWSTR pszDest, PCWSTR pszNewName)
{
    //
    // Initialize COM as STA.
    //
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (SUCCEEDED(hr))
    {
        IFileOperation *pfo;

        //
        // Create the IFileOperation interface
        //
        hr = CoCreateInstance(CLSID_FileOperation,
                              NULL,
                              CLSCTX_ALL,
                              IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;pfo));
        if (SUCCEEDED(hr))
        {
            //
            // Set the operation flags. Turn off all UI from being shown to the
            // user during the operation. This includes error, confirmation,
            // and progress dialogs.
            //
            hr = pfo-&gt;SetOperationFlags(FOF_NO_UI);
            if (SUCCEEDED(hr))
            {
                //
                // Create an IShellItem from the supplied source path.
                //
                IShellItem *psiFrom = NULL;
                hr = SHCreateItemFromParsingName(pszSrcItem,
                                                 NULL,
                                                 IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;psiFrom));
                if (SUCCEEDED(hr))
                {
                    IShellItem *psiTo = NULL;

                    if (NULL != pszDest)
                    {
                        //
                        // Create an IShellItem from the supplied
                        // destination path.
                        //
                        hr = SHCreateItemFromParsingName(pszDest,
                                                         NULL,
                                                         IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;psiTo));
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add the operation
                        //
                        hr = pfo-&gt;CopyItem(psiFrom, psiTo, pszNewName, NULL);

                        if (NULL != psiTo)
                        {
                            psiTo-&gt;Release();
                        }
                    }

                    psiFrom-&gt;Release();
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Perform the operation to copy the file.
                    //
                    hr = pfo-&gt;PerformOperations();
                }
            }

            //
            // Release the IFileOperation interface.
            //
            pfo-&gt;Release();
        }

        CoUninitialize();
    }
    return hr;
}
</code>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.CopyItems" />
    <seealso cref="PostCopyItem" />
    <seealso cref="PreCopyItem" />
  </member>
  <member name="IFileOperation.CopyItems">
    <summary>
      <para>Declares a set of items that are to be copied to a specified destination.</para>
    </summary>
    <param name="punkItems">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>Pointer to the <see cref="IUnknown" /> of the <see cref="IShellItemArray" />, <see cref="IDataObject" />, or <see cref="IEnumShellItems" /> object which represents the group of items to be copied. You can also point to an <see cref="IPersistIDList" /> object to represent a single item, effectively accomplishing the same function as <see cref="IFileOperation.CopyItem" />.</para>
    </param>
    <param name="psiDestinationFolder">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the destination folder to contain the copy of the items.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not copy the items, it merely declares the items to be copied. To copy a group of items, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.CopyItems</b> to declare the source items and the destination folder.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the copy operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.CopyItem" />
  </member>
  <member name="IFileOperation.DeleteItem">
    <summary>
      <para>Declares a single item that is to be deleted.</para>
    </summary>
    <param name="psiItem">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the item to be deleted.</para>
    </param>
    <param name="pfopsItem">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for progress status and error notifications for this specific delete operation. If you call <see cref="IFileOperation.Advise" /> for the overall operation, progress status and error notifications for the delete operation are included there, so set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not delete the item, it merely declares the item to be deleted. To delete an item, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.DeleteItem</b> to declare the file or folder to be deleted.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the delete operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.DeleteItems" />
    <seealso cref="PostDeleteItem" />
    <seealso cref="PreDeleteItem" />
  </member>
  <member name="IFileOperation.DeleteItems">
    <summary>
      <para>Declares a set of items that are to be deleted.</para>
    </summary>
    <param name="punkItems">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>Pointer to the <see cref="IUnknown" /> of the <see cref="IShellItemArray" />, <see cref="IDataObject" />, or <see cref="IEnumShellItems" /> object which represents the group of items to be deleted. You can also point to an <see cref="IPersistIDList" /> object to represent a single item, effectively accomplishing the same function as <see cref="IFileOperation.DeleteItem" />.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not delete the items, it merely declares the items to be deleted. To delete a group of items, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.DeleteItems</b> to declare the files or folders to be deleted.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the delete operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.DeleteItem" />
  </member>
  <member name="IFileOperation.GetAnyOperationsAborted">
    <summary>
      <para>Gets a value that states whether any file operations initiated by a call to <see cref="IFileOperation.PerformOperations" /> were stopped before they were complete. The operations could be stopped either by user action or silently by the system.</para>
    </summary>
    <param name="pfAnyOperationsAborted">
      <para>Type: <b>BOOL*</b></para>
      <para>When this method returns, points to <b>TRUE</b> if any file operations were aborted before they were complete; otherwise, <b>FALSE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Call this method after <see cref="IFileOperation.PerformOperations" /> returns.</para>
      <para>You should call <b>IFileOperation.GetAnyOperationsAborted</b> regardless of whether <see cref="IFileOperation.PerformOperations" /> returned a success or failure code. A success code can be returned even if the operation was stopped by the user or the system.</para>
      <para>This method provides the same functionality as the <b>fAnyOperationsAborted</b> member of the <see cref="SHFILEOPSTRUCT" /> structure used by the legacy function <see cref="SHFileOperation" />.</para>
    </remarks>
  </member>
  <member name="IFileOperation.MoveItem">
    <summary>
      <para>Declares a single item that is to be moved to a specified destination.</para>
    </summary>
    <param name="psiItem">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the source item.</para>
    </param>
    <param name="psiDestinationFolder">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the destination folder to contain the moved item.</para>
    </param>
    <param name="pszNewName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to a new name for the item in its new location. This is a null-terminated Unicode string and can be <b>NULL</b>. If <b>NULL</b>, the name of the destination item is the same as the source.</para>
    </param>
    <param name="pfopsItem">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for progress status and error notifications for this specific move operation. If you call <see cref="IFileOperation.Advise" /> for the overall operation, progress status and error notifications for the move operation are included there, so set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not move the item, it merely declares the item to be moved. To move an object, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.MoveItem</b> to declare the source item, destination folder, and destination name.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the move operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.MoveItems" />
    <seealso cref="PostMoveItem" />
    <seealso cref="PreMoveItem" />
  </member>
  <member name="IFileOperation.MoveItems">
    <summary>
      <para>Declares a set of items that are to be moved to a specified destination.</para>
    </summary>
    <param name="punkItems">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>Pointer to the <see cref="IUnknown" /> of the <see cref="IShellItemArray" />, <see cref="IDataObject" />, or <see cref="IEnumShellItems" /> object which represents the group of items to be moved. You can also point to an <see cref="IPersistIDList" /> object to represent a single item, effectively accomplishing the same function as <see cref="IFileOperation.MoveItem" />.</para>
    </param>
    <param name="psiDestinationFolder">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the destination folder to contain the moved items.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not move the items, it merely declares the items to be moved. To move a group of items, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.MoveItems</b> to declare the source files or folders and the destination folder.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the move operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.MoveItem" />
  </member>
  <member name="IFileOperation.NewItem">
    <summary>
      <para>Declares a new item that is to be created in a specified location.</para>
    </summary>
    <param name="psiDestinationFolder">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the destination folder that will contain the new item.</para>
    </param>
    <param name="dwFileAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>A bitwise value that specifies the file system attributes for the file or folder. See <see cref="GetFileAttributes" /> for possible values.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the file name of the new item, for instance <b>Newfile.txt</b>. This is a null-terminated, Unicode string.</para>
    </param>
    <param name="pszTemplateName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the name of the template file (for example <b>Excel9.xls</b>) that the new item is based on, stored in one of the following locations:</para>
      <list type="bullet">
        <item>
          <description>CSIDL_COMMON_TEMPLATES. The default path for this folder is %ALLUSERSPROFILE%\Templates.</description>
        </item>
        <item>
          <description>CSIDL_TEMPLATES. The default path for this folder is %USERPROFILE%\Templates.</description>
        </item>
        <item>
          <description>%SystemRoot%\shellnew</description>
        </item>
      </list>
      <para>This is a null-terminated, Unicode string used to specify an existing file of the same type as the new file, containing the minimal content that an application wants to include in any new file.</para>
      <para>This parameter is normally <b>NULL</b> to specify a new, blank file.</para>
    </param>
    <param name="pfopsItem">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for status and failure notifications. If you call <see cref="IFileOperation.Advise" /> for the overall operation, progress status and error notifications for the creation operation are included there, so set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not create the new item, it merely declares the item to be created. To create a new item, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.NewItem</b> to declare the specifics of the new file or folder.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to create the new item.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="PostNewItem" />
    <seealso cref="PreNewItem" />
  </member>
  <member name="IFileOperation.PerformOperations">
    <summary>
      <para>Executes all selected operations.</para>
    </summary>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or an error value otherwise. Note that if the operation was canceled by the user, this method can still return a success code. Use the <see cref="GetAnyOperationsAborted" /> method to determine if this was the case.</para>
    </returns>
    <remarks>
      <para>This method is called last to execute those actions that have been specified earlier by calling their individual methods. For instance, <see cref="RenameItem" /> does not rename the item, it simply sets the parameters. The actual renaming is done when you call <b>PerformOperations</b>.</para>
    </remarks>
    <seealso cref="FinishOperations" />
    <seealso cref="IFileOperation" />
    <seealso cref="StartOperations" />
  </member>
  <member name="IFileOperation.RenameItem">
    <summary>
      <para>Declares a single item that is to be given a new display name.</para>
    </summary>
    <param name="psiItem">
      <para>Type: <b><see cref="IShellItem" />*</b></para>
      <para>Pointer to an <see cref="IShellItem" /> that specifies the source item.</para>
    </param>
    <param name="pszNewName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the new <see cref="display name" /> of the item. This is a null-terminated, Unicode string.</para>
    </param>
    <param name="pfopsItem">
      <para>Type: <b><see cref="IFileOperationProgressSink" />*</b></para>
      <para>Pointer to an <see cref="IFileOperationProgressSink" /> object to be used for status and failure notifications. If you call <see cref="IFileOperation.Advise" /> for the overall operation, progress status and error notifications for the rename operation are included there, so set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not rename the item, it merely declares the item to be renamed. To rename an object, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.RenameItem</b> to declare the new name.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the rename operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.RenameItems" />
    <seealso cref="PostRenameItem" />
    <seealso cref="PreRenameItem" />
  </member>
  <member name="IFileOperation.RenameItems">
    <summary>
      <para>Declares a set of items that are to be given a new display name. All items are given the same name.</para>
    </summary>
    <param name="pUnkItems">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>Pointer to the <see cref="IUnknown" /> of the <see cref="IShellItemArray" />, <see cref="IDataObject" />, or <see cref="IEnumShellItems" /> object which represents the group of items to be renamed. You can also point to an <see cref="IPersistIDList" /> object to represent a single item, effectively accomplishing the same function as <see cref="IFileOperation.RenameItem" />.</para>
    </param>
    <param name="pszNewName">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the new display name of the items. This is a null-terminated, Unicode string.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If more than one of the items in the collection at <i>pUnkItems</i> is in the same folder, the renamed files are appended with a number in parentheses to differentiate them, for instance newfile(1).txt, newfile(2).txt, and newfile(3).txt.</para>
      <para>This method does not rename the items, it merely declares the items to be renamed. To rename a group of objects, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.RenameItems</b> to declare the source files or folders and the new name.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to begin the rename operation.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.RenameItem" />
  </member>
  <member name="IFileOperation.SetOperationFlags">
    <summary>
      <para>Sets parameters for the current operation.</para>
    </summary>
    <param name="dwOperationFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control the file operation. This member can be a combination of the following flags. FOF flags are defined in Shellapi.h and FOFX flags are defined in Shobjidl.h.</para>
      <para>
        <b>Note</b>  If this method is not called, the default value used by the operation is FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR.</para>
      <h4>FOF_ALLOWUNDO (0x0040)</h4>
      <para>Preserve undo information, if possible.</para>
      <para>Prior to Windows Vista, operations could be undone only from the same process that performed the original operation.</para>
      <para>In Windows Vista and later systems, the scope of the undo is a user session. Any process running in the user session can undo another operation. The undo state is held in the Explorer.exe process, and as long as that process is running, it can coordinate the undo functions.</para>
      <para>If the source file parameter does not contain fully qualified path and file names, this flag is ignored.</para>
      <h4>FOF_FILESONLY (0x0080)</h4>
      <para>Perform the operation only on files (not on folders) if a wildcard file name (<i>.</i>) is specified.</para>
      <h4>FOF_NOCONFIRMATION (0x0010)</h4>
      <para>Respond with <b>Yes to All</b> for any dialog box that is displayed.</para>
      <h4>FOF_NOCONFIRMMKDIR (0x0200)</h4>
      <para>Do not confirm the creation of a new folder if the operation requires one to be created.</para>
      <h4>FOF_NO_CONNECTED_ELEMENTS (0x2000)</h4>
      <para>Do not move connected items as a group. Only move the specified files.</para>
      <h4>FOF_NOCOPYSECURITYATTRIBS (0x0800)</h4>
      <para>Do not copy the security attributes of the item.</para>
      <h4>FOF_NOERRORUI (0x0400)</h4>
      <para>Do not display a message to the user if an error occurs. If this flag is set without FOFX_EARLYFAILURE, any error is treated as if the user had chosen <b>Ignore</b> or <b>Continue</b> in a dialog box. It halts the current action, sets a flag to indicate that an action was aborted, and proceeds with the rest of the operation.</para>
      <h4>FOF_NORECURSION (0x1000)</h4>
      <para>Only operate in the local folder. Do not operate recursively into subdirectories.</para>
      <h4>FOF_RENAMEONCOLLISION (0x0008)</h4>
      <para>Give the item being operated on a new name in a move, copy, or rename operation if an item with the target name already exists.</para>
      <h4>FOF_SILENT (0x0004)</h4>
      <para>Do not display a progress dialog box.</para>
      <h4>FOF_WANTNUKEWARNING (0x4000)</h4>
      <para>Send a warning if a file or folder is being destroyed during a delete operation rather than recycled. This flag partially overrides <b>FOF_NOCONFIRMATION</b>.</para>
      <h4>FOFX_ADDUNDORECORD (0x20000000)</h4>
      <para>
        <b>Introduced in Windows 8</b>. The file operation was user-invoked and should be placed on the undo stack. This flag is preferred to FOF_ALLOWUNDO.</para>
      <h4>FOFX_NOSKIPJUNCTIONS (0x00010000)</h4>
      <para>Walk into Shell namespace junctions. By default, junctions are not entered. For more information on junctions, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/cc144096(v=vs.85)">Specifying a Namespace Extension's Location</a>.</para>
      <h4>FOFX_PREFERHARDLINK (0x00020000)</h4>
      <para>If possible, create a hard link rather than a new instance of the file in the destination.</para>
      <h4>FOFX_SHOWELEVATIONPROMPT (0x00040000)</h4>
      <para>If an operation requires elevated rights and the FOF_NOERRORUI flag is set to disable error UI, display a UAC UI prompt nonetheless.</para>
      <h4>FOFX_EARLYFAILURE (0x00100000)</h4>
      <para>If FOFX_EARLYFAILURE is set together with FOF_NOERRORUI, the entire set of operations is stopped upon encountering any error in any operation. This flag is valid only when FOF_NOERRORUI is set.</para>
      <h4>FOFX_PRESERVEFILEEXTENSIONS (0x00200000)</h4>
      <para>Rename collisions in such a way as to preserve file name extensions. This flag is valid only when FOF_RENAMEONCOLLISION is also set.</para>
      <h4>FOFX_KEEPNEWERFILE (0x00400000)</h4>
      <para>Keep the newer file or folder, based on the Date Modified property, if a collision occurs. This is done automatically with no prompt UI presented to the user.</para>
      <h4>FOFX_NOCOPYHOOKS (0x00800000)</h4>
      <para>Do not use copy hooks.</para>
      <h4>FOFX_NOMINIMIZEBOX (0x01000000)</h4>
      <para>Do not allow the progress dialog to be minimized.</para>
      <h4>FOFX_MOVEACLSACROSSVOLUMES (0x02000000)</h4>
      <para>Copy the security attributes of the source item to the destination item when performing a cross-volume move operation. Without this flag, the destination item receives the security attributes of its new folder.</para>
      <h4>FOFX_DONTDISPLAYSOURCEPATH (0x04000000)</h4>
      <para>Do not display the path of the source item in the progress dialog.</para>
      <h4>FOFX_DONTDISPLAYDESTPATH (0x08000000)</h4>
      <para>Do not display the path of the destination item in the progress dialog.</para>
      <h4>FOFX_RECYCLEONDELETE (0x00080000)</h4>
      <para>
        <b>Introduced in Windows 8</b>. When a file is deleted, send it to the Recycle Bin rather than permanently deleting it.</para>
      <h4>FOFX_REQUIREELEVATION (0x10000000)</h4>
      <para>
        <b>Introduced in Windows Vista SP1</b>. The user expects a requirement for rights elevation, so do not display a dialog box asking for a confirmation of the elevation.</para>
      <h4>FOFX_COPYASDOWNLOAD (0x40000000)</h4>
      <para>
        <b>Introduced in Windows 7</b>. Display a <b>Downloading</b> instead of <b>Copying</b> message in the progress dialog.</para>
      <h4>FOFX_DONTDISPLAYLOCATIONS (0x80000000)</h4>
      <para>
        <b>Introduced in Windows 7</b>. Do not display the location line in the progress dialog.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Set these flags before you call <see cref="IFileOperation.PerformOperations" /> to define the parameters for whatever operations are being performed, such as copy, delete, or rename.</para>
    </remarks>
  </member>
  <member name="IFileOperation.SetOwnerWindow">
    <summary>
      <para>Sets the parent or owner window for progress and dialog windows.</para>
    </summary>
    <param name="hwndOwner">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the owner window of the operation. This window will receive error messages.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="IFileOperation.SetProgressDialog">
    <summary>
      <para>Specifies a dialog box used to display the progress of the operation.</para>
    </summary>
    <param name="popd">
      <para>Type: <b><see cref="IOperationsProgressDialog" />*</b></para>
      <para>Pointer to an <see cref="IOperationsProgressDialog" /> object that represents the dialog box.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="IFileOperation.SetProgressMessage">
    <summary>
      <para>Not implemented.</para>
    </summary>
    <param name="pszMessage">
      <para>Type: <b>LPCWSTR</b></para>
      <para>Pointer to the window title. This is a null-terminated, Unicode string.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="IFileOperation.SetProperties">
    <summary>
      <para>Declares a set of properties and values to be set on an item or items.</para>
    </summary>
    <param name="pproparray">
      <para>Type: <b><see cref="IPropertyChangeArray" />*</b></para>
      <para>Pointer to an <see cref="IPropertyChangeArray" />, which accesses a collection of <see cref="IPropertyChange" /> objects that specify the properties to be set and their new values.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This method does not set the new property values, it merely declares them. To set property values on an item or a group of items, you must make at least the sequence of calls detailed here:</para>
      <list type="number">
        <item>
          <description>Call <b>IFileOperation.SetProperties</b> to declare the specific properties to be set and their new values.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.ApplyPropertiesToItem" /> or <see cref="IFileOperation.ApplyPropertiesToItems" /> to declare the item or items whose properties are to be set.</description>
        </item>
        <item>
          <description>Call <see cref="IFileOperation.PerformOperations" /> to apply the properties to the item or items.</description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="IFileOperation.Unadvise">
    <summary>
      <para>Terminates an advisory connection previously established through <see cref="IFileOperation.Advise" />.</para>
    </summary>
    <param name="dwCookie">
      <para>Type: <b>DWORD</b></para>
      <para>The connection token that identifies the connection to delete. This value was originally retrieved by <see cref="Advise" /> when the connection was made.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Any value other than those listed here indicate a failure.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The connection was terminated successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>CONNECT_E_NOCONNECTION</b>
            </para>
          </description>
          <description>
            <para>The value in <i>dwCookie</i> does not represent a valid connection.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="IFileOperation" />
    <seealso cref="IFileOperation.Advise" />
  </member>
  <member name="IFileOperation">
    <summary>
      <para>Exposes methods to copy, move, rename, create, and delete Shell items as well as methods to provide progress and error dialogs. This interface replaces the <see cref="SHFileOperation" /> function.</para>
    </summary>
    <remarks>
      <para>A Shell item can be any object in the namespace, including file system objects such as files and folders, but also virtual objects. In the <b>IFileOperation</b> method topics, the term "item" is used to refer generically to any namespace object.</para>
      <para>
        <b>IFileOperation</b> offers many advantages over the older <see cref="SHFileOperation" /> function.</para>
      <list type="bullet">
        <item>
          <description>Use of <see cref="IShellItem" /> to identify items rather than string paths. <see cref="SHFileOperation" /> required path and destination strings to terminate in two null characters rather than the standard single null character, which itself was used to delimit multiple paths in the string. Identifying an item through <b>IShellItem</b> is more robust and less prone to programming errors. It also allows you to access non-file system items such as virtual folders. Multiple items in one operation can be passed as an <see cref="IShellItemArray" />, <see cref="IDataObject" />, or a collection accessed through <see cref="IEnumShellItems" /> rather than as a string.
</description>
        </item>
        <item>
          <description>More accurate error reporting through HRESULT values in conjunction with an API such as <see cref="FormatMessage" />. Return codes from <see cref="SHFileOperation" /> could be misleading or inaccurate.</description>
        </item>
        <item>
          <description>Extensibility. As a Component Object Model (COM) interface, <b>IFileOperation</b> can have its capabilities extended by a third-party to meet their specific needs, although this should be a very rare case. Windows provides a default implementation of <b>IFileOperation</b> that should meet the needs of most users.</description>
        </item>
        <item>
          <description>Better progress feedback. Detailed operation progress, including notifications when specific operations begin and end on individual items as well as the overall progress, can be received during the operation. While <see cref="SHFileOperation" /> did provide progress UI, it was not as detailed.</description>
        </item>
        <item>
          <description>More functionality. In addition to the copy, delete, move, and rename functionality provided by <see cref="SHFileOperation" />, <b>IFileOperation</b> allows you to apply property values and create new items.</description>
        </item>
        <item>
          <description>More control over the operation. In addition to the operation flags recognized by <see cref="SHFileOperation" />, new flags are recognized in <see cref="IFileOperation.SetOperationFlags" /> that specify extended operation options.</description>
        </item>
        <item>
          <description>Different operations can be performed in one call. For instance, you can move a set of files, copy others, rename a folder, and apply properties to yet another item all in one operation. <see cref="SHFileOperation" /> could only do one operation—copy, move, rename, or delete—at a time.</description>
        </item>
      </list>
      <para>To accomplish a file operation using this interface, a sequence of calls must be made.</para>
      <list type="number">
        <item>
          <description>Optional. Set up the event sink for progress status and error notifications through <see cref="Advise" /> and <see cref="Unadvise" />.</description>
        </item>
        <item>
          <description>Set the operation state using the following as needed:
<list type="bullet"><item><description><see cref="SetOperationFlags" /></description></item><item><description><see cref="SetOwnerWindow" /></description></item><item><description><see cref="SetProgressDialog" /></description></item><item><description><see cref="SetProgressMessage" /></description></item><item><description><see cref="SetProperties" /></description></item></list></description>
        </item>
        <item>
          <description>Specify which operations to perform on which items using the following as needed.
<list type="bullet"><item><description><see cref="ApplyPropertiesToItem" /></description></item><item><description><see cref="ApplyPropertiesToItems" /></description></item><item><description><see cref="CopyItem" /></description></item><item><description><see cref="CopyItems" /></description></item><item><description><see cref="DeleteItem" /></description></item><item><description><see cref="DeleteItems" /></description></item><item><description><see cref="MoveItem" /></description></item><item><description><see cref="MoveItems" /></description></item><item><description><see cref="NewItem" /></description></item><item><description><see cref="RenameItem" /></description></item><item><description><see cref="RenameItems" /></description></item></list></description>
        </item>
        <item>
          <description>Execute the operations by calling <see cref="PerformOperations" /></description>
        </item>
      </list>
      <b>IFileOperation</b> can only be applied in a single-threaded apartment (STA) situation. It cannot be used for a multithreaded apartment (MTA) situation. For MTA, you still must use <see cref="SHFileOperation" />.
<para>A full sample that demonstrates the extension of <b>IFileOperation</b> is included in the Windows Software Development Kit (SDK). In a default installation, it can be found at %ProgramFiles%\Microsoft SDKs\Windows\v6.0\Samples\WinUI\Shell\AppPlatform\FileOperations.</para></remarks>
  </member>
</doc>