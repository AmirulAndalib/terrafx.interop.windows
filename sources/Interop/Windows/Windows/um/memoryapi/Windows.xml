<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AllocateUserPhysicalPages">
    <summary>
      <para>Allocates physical memory pages to be mapped and unmapped within any<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region of a specified process.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,<b>AllocateUserPhysicalPages</b> is not supported for 32-bit applications.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to a process.</para>
      <para>The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to allocate, in pages.</para>
      <para>To determine the page size of the computer, use the<see cref="GetSystemInfo" /> function. On output, this parameter receives the number of pages that are actually allocated, which might be less than the number requested.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array to store the page frame numbers of the allocated memory.</para>
      <para>The size of the array that is allocated should be at least the <i>NumberOfPages</i> times the size of the<b>ULONG_PTR</b> data type.</para>
      <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>Fewer pages than requested can be allocated. The caller must check the value of the <i>NumberOfPages</i> parameter on return to see how many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>UserPfnArray</i> parameter.</para>
      <para>If the function fails, the return value is <b>FALSE</b>, and no frames are allocated. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AllocateUserPhysicalPagesNuma">
    <summary>Allocates physical memory pages to be mapped and unmapped within any<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region of a specified process and specifies the NUMA node for the physical memory.</summary>
    <param name="hProcess">
      <para>A handle to a process.</para>
      <para>The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to allocate, in pages.</para>
      <para>To determine the page size of the computer, use the<see cref="GetSystemInfo" /> function. On output, this parameter receives the number of pages that are actually allocated, which might be less than the number requested.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array to store the page frame numbers of the allocated memory.</para>
      <para>The size of the array that is allocated should be at least the <i>NumberOfPages</i> times the size of the <b>ULONG_PTR</b> data type.</para>
      <div>
        <b>Caution</b>  Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.</div>
    </param>
    <param name="nndPreferred">The NUMA node where the physical memory should reside.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>Fewer pages than requested can be allocated. The caller must check the value of the<i>NumberOfPages</i> parameter on return to see how many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>PageArray</i>parameter.</para>
      <para>If the function fails, the return value is <b>FALSE</b> and no frames are allocated. To get extended error information, call the <see cref="GetLastError" />function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMapping2">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file. You can specify a preferred NUMA node for the physical memory as an extended parameter; see the <i>ExtendedParameters</i> parameter.</summary>
    <param name="File">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="SecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether a returned handle can be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/win32/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="DesiredAccess">The desired access mask for the returned file mapping handle. For a list of access rights, see <a href="https://docs.microsoft.com//windows/win32/memory/file-mapping-security-and-access-rights">File-mapping security and access rights</a>.</param>
    <param name="PageProtection">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list>
    </param>
    <param name="AllocationAttributes">
      <para>You can specify one or more of the following attributes for the file mapping object. Also see the <i>PageProtection</i> parameter.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8000000</term>
              </listheader>
            </list>
          </description>
          <description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_IMAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x11000000</term>
              </listheader>
            </list>
          </description>
          <description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_LARGE_PAGES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80000000</term>
              </listheader>
            </list>
          </description>
          <description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/win32/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_NOCACHE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x4000000</term>
              </listheader>
            </list>
          </description>
          <description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SEC_WRITECOMBINE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40000000</term>
              </listheader>
            </list>
          </description>
          <description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description>
        </listheader>
      </list>
    </param>
    <param name="MaximumSize">
      <para>The maximum size of the file mapping object.</para>
      <para>If this parameter is 0 (zero), then the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. You should test for files with a length of 0 (zero), and reject those files.</para>
    </param>
    <param name="Name">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, then the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, then the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the <a href="https://docs.microsoft.com//windows/win32/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege. For more information, see <a href="https://docs.microsoft.com//windows/win32/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <param name="ExtendedParameters">An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</param>
    <param name="ParameterCount">
      <para>
        <i>In</i> ULONG ParameterCount</para>
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingFromApp">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file from a Windows Store app.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingFromApp</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="SecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>SecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="PageProtection">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMappingFromApp</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMappingFromApp</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="MaximumSize">
      <para>The maximum size of the file mapping object.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="Name">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" />returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNuma">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNumaA">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNumaW">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMapping">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed. However, <b>SEC_COMMIT</b> must be explicitly specified when combining it with another <b>SEC_</b> attribute that requires it.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed. However, <b>SEC_COMMIT</b> must be explicitly specified when combining it with another <b>SEC_</b> attribute that requires it.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed. However, <b>SEC_COMMIT</b> must be explicitly specified when combining it with another <b>SEC_</b> attribute that requires it.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMemoryResourceNotification">
    <summary>Creates a memory resource notification object.</summary>
    <param name="NotificationType">
      <para>The memory condition under which the object is to be signaled. This parameter can be one of the following values from the <b>MEMORY_RESOURCE_NOTIFICATION_TYPE</b> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LowMemoryResourceNotification</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Available physical memory is running low.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>HighMemoryResourceNotification</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Available physical memory is high.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a memory resource notification object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DiscardVirtualMemory">
    <summary>Discards the memory contents of a range of memory pages, without decommitting the memory. The contents of discarded memory is undefined and must be rewritten by the application.</summary>
    <param name="VirtualAddress">Page-aligned starting address of the memory to discard.</param>
    <param name="Size">Size, in bytes, of the memory region to discard. <i>Size</i> must be an integer multiple of the system page size.</param>
    <returns>ERROR_SUCCESS if successful; a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</returns>
  </member>
  <member name="Windows.FlushViewOfFile">
    <summary>Writes to the disk a byte range within a mapped view of a file.</summary>
    <param name="lpBaseAddress">A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.</param>
    <param name="dwNumberOfBytesToFlush">The number of bytes to be flushed. If <i>dwNumberOfBytesToFlush</i> is zero, the file is flushed from the base address to the end of the mapping.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FreeUserPhysicalPages">
    <summary>
      <para>Frees physical memory pages that are allocated previously by using<see cref="AllocateUserPhysicalPages" /> or <see cref="AllocateUserPhysicalPagesNuma" />. If any of these pages are currently mapped in the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region, they are automatically unmapped by this call. This does not affect the virtual address space that is occupied by a specified Address Windowing Extensions (AWE) region.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,<b>FreeUserPhysicalPages</b> is not supported for 32-bit applications.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to a process.</para>
      <para>The function frees memory within the virtual address space of this process.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to free, in pages.</para>
      <para>On return, if the function fails, this parameter indicates the number of pages that are freed.</para>
    </param>
    <param name="PageArray">A pointer to an array of page frame numbers of the allocated memory to be freed.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. In this case, the <i>NumberOfPages</i>parameter reflect how many pages have actually been released. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetLargePageMinimum">
    <summary>Retrieves the minimum size of a large page.</summary>
    <returns>
      <para>If the processor supports large pages, the return value is the minimum size of a large page.</para>
      <para>If the processor does not support large pages, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetMemoryErrorHandlingCapabilities">
    <summary>Gets the memory error handling capabilities of the system.</summary>
    <param name="Capabilities">
      <para>A <b>PULONG</b> that receives one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEHC_PATROL_SCRUBBER_PRESENT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The hardware can detect and report failed memory.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessWorkingSetSize">
    <summary>Retrieves the minimum and maximum working set sizes of the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpMinimumWorkingSetSize">A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</param>
    <param name="lpMaximumWorkingSetSize">A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessWorkingSetSizeEx">
    <summary>Retrieves the minimum and maximum working set sizes of the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpMinimumWorkingSetSize">A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</param>
    <param name="lpMaximumWorkingSetSize">A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</param>
    <param name="Flags">
      <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The working set may fall below the minimum working set limit if memory demands are high.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The working set will not fall below the minimum working set limit.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>The working set may exceed the maximum working set limit if there is abundant memory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The working set will not exceed the maximum working set limit.</description>
        </listheader>
      </list>
    </param>
  </member>
  <member name="Windows.GetSystemFileCacheSize">
    <summary>Retrieves the current size limits for the working set of the system cache.</summary>
    <param name="lpMinimumFileCacheSize">A pointer to a variable that receives the minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache, if there is a previous call to the <see cref="SetSystemFileCacheSize" /> function with the <b>FILE_CACHE_MIN_HARD_ENABLE</b> flag.</param>
    <param name="lpMaximumFileCacheSize">A pointer to a variable that receives the maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if there is a previous call to <see cref="SetSystemFileCacheSize" /> with the <b>FILE_CACHE_MAX_HARD_ENABLE</b> flag.</param>
    <param name="lpFlags">
      <para>The flags that indicate which of the file cache limits are enabled.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MAX_HARD_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The maximum size limit is enabled. If this flag is not present, this limit is disabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MIN_HARD_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x4</term>
              </listheader>
            </list>
          </description>
          <description>The minimum size limit is enabled. If this flag is not present, this limit is disabled.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetWriteWatch">
    <summary>
      <para>Retrieves the addresses of the pages that are written to in a region of virtual memory.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes, <b>GetWriteWatch</b>is not supported for 32-bit applications.</para>
    </summary>
    <param name="dwFlags">
      <para>Indicates whether the function resets the write-tracking state.</para>
      <para>To reset the write-tracking state, set this parameter to <b>WRITE_WATCH_FLAG_RESET</b>. If this parameter is 0 (zero),<b>GetWriteWatch</b> does not reset the write-tracking state. For more information, see the Remarks section of this topic.</para>
    </param>
    <param name="lpBaseAddress">
      <para>The base address of the memory region for which to retrieve write-tracking information.</para>
      <para>This address must be in a memory region that is allocated by the <see cref="VirtualAlloc" />function using <b>MEM_WRITE_WATCH</b>.</para>
    </param>
    <param name="dwRegionSize">The size of the memory region for which to retrieve write-tracking information, in bytes.</param>
    <param name="lpAddresses">
      <para>A pointer to a buffer that receives an array of page addresses in the memory region.</para>
      <para>The addresses indicate the pages that have been written to since the region has been allocated or the write-tracking state has been reset.</para>
    </param>
    <param name="lpdwCount">
      <para>On input, this variable indicates the size of the <i>lpAddresses</i> array, in array elements.</para>
      <para>On output, the variable receives the number of page addresses that are returned in the array.</para>
    </param>
    <param name="lpdwGranularity">A pointer to a variable that receives the page size, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is 0 (zero).</para>
      <para>If the function fails, the return value is a nonzero value.</para>
    </returns>
  </member>
  <member name="Windows.MapUserPhysicalPages">
    <summary>
      <para>Maps previously allocated physical memory pages at a specified address in an<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region.</para>
      <para>To perform batch mapping and unmapping of multiple regions, use the<see cref="MapUserPhysicalPagesScatter" /> function.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,<b>MapUserPhysicalPages</b> is not supported for 32-bit applications.</para>
    </summary>
    <param name="VirtualAddress">
      <para>A pointer to the starting address of the region of memory to remap.</para>
      <para>The value of<i>lpAddress</i> must be within the address range that the<see cref="VirtualAlloc" /> function returns when the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is allocated.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
      <para>The virtual address range is contiguous starting at <i>lpAddress</i>. The physical frames are specified by the <i>UserPfnArray</i>.</para>
      <para>The total number of pages cannot extend from the starting address beyond the end of the range that is specified in<see cref="AllocateUserPhysicalPages" />.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array of physical page frame numbers.</para>
      <para>These frames are mapped by the argument<i>lpAddress</i> on return from this function. The size of the memory that is allocated should be at least the <i>NumberOfPages</i> times the size of the data type<b>ULONG_PTR</b>.</para>
      <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.</para>
      <para>If this parameter is <b>NULL</b>, the specified address range is unmapped. Also, the specified physical pages are not freed, and you must call <see cref="FreeUserPhysicalPages" /> to free them.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b> and no mapping is done—partial or otherwise. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MapViewOfFile">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling process.</para>
      <para>To specify a suggested base address for the view, use the<see cref="MapViewOfFileEx" /> function. However, this practice is not recommended.</para>
    </summary>
    <param name="hFileMappingObject">A handle to a file mapping object. The<see cref="CreateFileMapping" /> and<see cref="OpenFileMapping" /> functions return this handle.</param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_ALL_ACCESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with the <b>MapViewOfFile</b> function,<b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_READ</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read-only view of the file is mapped. An attempt to write to the file view results in an access violation.<para>The file mapping object must have been created with <b>PAGE_READONLY</b>,<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or<b>PAGE_EXECUTE_READWRITE</b> protection.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_WRITE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with <b>MapViewOfFile</b>, (<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and<b>FILE_MAP_ALL_ACCESS</b> are equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
      </list> <para>Using bitwise OR, you can combine the values above with these values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_COPY</b></term></listheader></list></description><description>A copy-on-write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is private to the process. The new page is backed by the paging file. The protection of the new page changes from copy-on-write to read/write.</para><para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view because the calling process can potentially write to every page in the view, making all pages private. The contents of the new page are never written back to the original file and are lost when the view is unmapped.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_EXECUTE</b></term></listheader></list></description><description>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must have been created with <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.<para><b>Windows Server 2003 and Windows XP:  </b>This value is available starting with Windows XP with SP2 and Windows Server 2003 with SP1.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_LARGE_PAGES</b></term></listheader></list></description><description>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.<br /><br /><b>Note:</b>On OS versions before Windows 10, version 1703, the <b>FILE_MAP_LARGE_PAGES</b> flag has no effect. On these releases, the view is automatically mapped using large pages if the section was created with the <b>SEC_LARGE_PAGES</b> flag set.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_TARGETS_INVALID</b></term></listheader></list></description><description>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</description></listheader></list> <para>For file mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as<b>FILE_MAP_READ</b>.</para><para>For more information about access to file mapping objects, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para></param>
    <param name="dwFileOffsetHigh">A high-order <b>DWORD</b> of the file offset where the view begins.</param>
    <param name="dwFileOffsetLow">A low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function, which fills in the members of a <see cref="SYSTEM_INFO" /> structure.</param>
    <param name="dwNumberOfBytesToMap">The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by <see cref="CreateFileMapping" />. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MapViewOfFile2">
    <summary>Maps a view of a file or a pagefile-backed section into the address space of the specified process.</summary>
    <param name="FileMappingHandle">A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.</param>
    <param name="ProcessHandle">A <b>HANDLE</b> to a process into which the section will be mapped. The handle must have the <b>PROCESS_VM_OPERATION</b> access mask.</param>
    <param name="Offset">The offset from the beginning of the section. This must be 64k aligned.</param>
    <param name="BaseAddress">The desired base address of the view. The address is rounded down to the nearest 64k boundary. If this parameter is <b>NULL</b>, the system picks the base address.</param>
    <param name="ViewSize">The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped.</param>
    <param name="AllocationType">
      <para>The type of allocation. This parameter can be zero (0) or one of the following constant values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>MEM_RESERVE</b> - Maps a reserved view.</description>
        </item>
        <item>
          <description>
            <b>MEM_LARGE_PAGES</b> - Maps a large page view. This flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/win32/memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for the <i>BaseAddress</i> parameter, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as<b>PAGE_READONLY</b>.</para>
    </param>
    <returns>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available using <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.MapViewOfFile3">
    <summary>
      <para>Maps a view of a file or a pagefile-backed section into the address space of the specified process.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="FileMapping">A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.</param>
    <param name="Process">A <b>HANDLE</b> to a process into which the section will be mapped.</param>
    <param name="BaseAddress">
      <para>The desired base address of the view. The address is rounded down to the nearest 64k boundary.</para>
      <code> If this parameter is &lt;b&gt;NULL&lt;/b&gt;, the system picks the base address.</code>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, then any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> must consist of all zeroes.</para>
    </param>
    <param name="Offset">The offset from the beginning of the section. This must be 64k aligned.</param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped.</para>
      <para>The size must always be a multiple of the page size.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Maps a reserved view.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Replaces a placeholder with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder, and any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes.<para>After you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the <i>UnmapFlags</i> parameter of <see cref="UnmapViewOfFileEx" /> and <see cref="UnmapViewOfFile2" />.</para><para>A placeholder is a type of reserved memory region.</para><para>The 64k alignment requirements on <i>Offset</i> and <i>BaseAddress</i> do not apply when this flag is specified.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_LARGE_PAGES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20000000</term>
              </listheader>
            </list>
          </description>
          <description>Maps a large page view. This flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for the <i>BaseAddress</i> parameter, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description>
        </listheader>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="ExtendedParameters">An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</param>
    <param name="ParameterCount">The number of extended parameters pointed to by <i>ExtendedParameters</i>.</param>
    <returns>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available using <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.MapViewOfFile3FromApp">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling Windows Store app.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="FileMapping">A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.</param>
    <param name="Process">A <b>HANDLE</b> to a process into which the section will be mapped.</param>
    <param name="BaseAddress">
      <para>The desired base address of the view. The address is rounded down to the nearest 64k boundary.</para>
      <code> If this parameter is &lt;b&gt;NULL&lt;/b&gt;, the system picks the base address.</code>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, then any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes.</para>
    </param>
    <param name="Offset">The offset from the beginning of the section. This must be 64k aligned.</param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped.</para>
      <para>The size must always be a multiple of the page size.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Maps a reserved view.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Replaces a placeholder with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder, and any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes.<para>After you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the <i>UnmapFlags</i> parameter of <see cref="UnmapViewOfFileEx" /> and <see cref="UnmapViewOfFile2" />.</para><para>A placeholder is a type of reserved memory region.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_LARGE_PAGES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20000000</term>
              </listheader>
            </list>
          </description>
          <description>Maps a large page view. See <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</description>
        </listheader>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="ExtendedParameters">An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</param>
    <param name="ParameterCount">The number of extended parameters pointed to by <i>ExtendedParameters</i>.</param>
    <returns>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available using <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.MapViewOfFileEx">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling process. A caller can optionally specify a suggested base memory address for the view.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="MapViewOfFileExNuma" />.</para>
    </summary>
    <param name="hFileMappingObject">A handle to a file mapping object. The<see cref="CreateFileMapping" /> and<see cref="OpenFileMapping" /> functions return this handle.</param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_ALL_ACCESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with the <b>MapViewOfFileEx</b> function,<b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_READ</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read-only view of the file is mapped. An attempt to write to the file view results in an access violation.<para>The file mapping object must have been created with <b>PAGE_READONLY</b>,<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or<b>PAGE_EXECUTE_READWRITE</b> protection.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_WRITE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with <b>MapViewOfFileEx</b>, (<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and<b>FILE_MAP_ALL_ACCESS</b> are equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
      </list> <para>Using bitwise OR, you can combine the values above with these values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_COPY</b></term></listheader></list></description><description>A copy-on-write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is private to the process. The new page is backed by the paging file. The protection of the new page changes from copy-on-write to read/write.</para><para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view because the calling process can potentially write to every page in the view, making all pages private. The contents of the new page are never written back to the original file and are lost when the view is unmapped.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_LARGE_PAGES</b></term></listheader></list></description><description>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_EXECUTE</b></term></listheader></list></description><description>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must have been created with <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.<para><b>Windows Server 2003 and Windows XP:  </b>This value is available starting with Windows XP with SP2 and Windows Server 2003 with SP1.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_TARGETS_INVALID</b></term></listheader></list></description><description>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</description></listheader></list> <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as<b>FILE_MAP_READ</b>.</para><para>For more information about access to file mapping objects, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para></param>
    <param name="dwFileOffsetHigh">The high-order <b>DWORD</b> of the file offset where the view is to begin.</param>
    <param name="dwFileOffsetLow">The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function, which fills in the members of a <see cref="SYSTEM_INFO" /> structure.</param>
    <param name="dwNumberOfBytesToMap">The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by <see cref="CreateFileMapping" />. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</param>
    <param name="lpBaseAddress">
      <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function. If there is not enough address space at the specified address, the function fails.</para>
      <para>If <i>lpBaseAddress</i> is <b>NULL</b>, the operating system chooses the mapping address. In this scenario, the function is equivalent to the<see cref="MapViewOfFile" /> function.</para>
      <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no guarantee that the address will remain safe over time. Therefore, it is better to let the operating system choose the address. In this case, you would not store pointers in the memory mapped file, you would store offsets from the base of the file mapping so that the mapping can be used at any address.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MapViewOfFileFromApp">
    <summary>Maps a view of a file mapping into the address space of a calling Windows Store app.</summary>
    <param name="hFileMappingObject">A handle to a file mapping object. The<see cref="CreateFileMappingFromApp" /> function returns this handle.</param>
    <param name="DesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_ALL_ACCESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> protection.<para>When used with <b>MapViewOfFileFromApp</b>, <b>FILE_MAP_ALL_ACCESS</b> is equivalent to<b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_READ</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read-only view of the file is mapped. An attempt to write to the file view results in an access violation.<para>The file mapping object must have been created with <b>PAGE_READONLY</b>,<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or<b>PAGE_EXECUTE_READWRITE</b> protection.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_WRITE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> protection.<para>When used with <b>MapViewOfFileFromApp</b>,<code>(FILE_MAP_WRITE | FILE_MAP_READ)</code> is equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
      </list> <para>Using bitwise OR, you can combine the values above with these values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_COPY</b></term></listheader></list></description><description>A copy-on-write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, or <b>PAGE_READWRITE</b> protection.<para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is private to the process. The new page is backed by the paging file. The protection of the new page changes from copy-on-write to read/write.</para><para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view because the calling process can potentially write to every page in the view, making all pages private. The contents of the new page are never written back to the original file and are lost when the view is unmapped.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_LARGE_PAGES</b></term></listheader></list></description><description>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_TARGETS_INVALID</b></term></listheader></list></description><description>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</description></listheader></list> <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as<b>FILE_MAP_READ</b>.</para><para>For more information about access to file mapping objects, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para></param>
    <param name="FileOffset">The file offset where the view is to begin. The offset must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function, which fills in the members of a <see cref="SYSTEM_INFO" /> structure.</param>
    <param name="NumberOfBytesToMap">The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by <see cref="CreateFileMappingFromApp" />. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MapViewOfFileNuma2">
    <summary>Maps a view of a file or a pagefile-backed section into the address space of the specified process.</summary>
    <param name="FileMappingHandle">A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.</param>
    <param name="ProcessHandle">A <b>HANDLE</b> to a process into which the section will be mapped.</param>
    <param name="Offset">The offset from the beginning of the section. This must be 64k aligned.</param>
    <param name="BaseAddress">The desired base address of the view. The address is rounded down to the nearest 64k boundary. If this parameter is <b>NULL</b>, the system picks the base address.</param>
    <param name="ViewSize">The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped.</param>
    <param name="AllocationType">
      <para>The type of allocation. This parameter can be zero (0) or one of the following constant values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>MEM_RESERVE</b> - Maps a reserved view</description>
        </item>
        <item>
          <description>
            <b>MEM_LARGE_PAGES</b> - Maps a large page view</description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="PreferredNode">The preferred NUMA node for this memory.</param>
    <returns>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available using <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.OfferVirtualMemory">
    <summary>
      <para>Indicates that the data contained in a range of memory pages is no longer needed by the application and can be discarded by the system if necessary.</para>
      <para>The specified pages will be marked as inaccessible, removed from the process working set, and will not be written to the paging file.</para>
      <para>To later reclaim offered pages, call <see cref="ReclaimVirtualMemory" />.</para>
    </summary>
    <param name="VirtualAddress">Page-aligned starting address of the memory to offer.</param>
    <param name="Size">Size, in bytes, of the memory region to offer. <i>Size</i> must be an integer multiple of the system page size.</param>
    <param name="Priority">
      <para>
        <i>Priority</i> indicates how important the offered memory is to the application. A higher priority increases the probability that the offered memory can be reclaimed intact when calling <see cref="ReclaimVirtualMemory" />. The system typically discards lower priority memory before discarding higher priority memory.<i>Priority</i> must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>VMOfferPriorityVeryLow</term>
              </listheader> 0x00000001</list>
          </description>
          <description>The offered memory is very low priority, and should be the first discarded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>VMOfferPriorityLow</term>
              </listheader> 0x00000002</list>
          </description>
          <description>The offered memory is low priority.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>VMOfferPriorityBelowNormal</term>
              </listheader> 0x00000003</list>
          </description>
          <description>The offered memory is below normal priority.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>VMOfferPriorityNormal</term>
              </listheader> 0x00000004</list>
          </description>
          <description>The offered memory is of normal priority to the application, and should be the last discarded.</description>
        </listheader>
      </list>
    </param>
    <returns>ERROR_SUCCESS if successful; a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</returns>
  </member>
  <member name="Windows.OpenFileMappingFromApp">
    <summary>Opens a named file mapping object.</summary>
    <param name="DesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>. You can only open the file mapping object for <b>FILE_MAP_EXECUTE</b> access if your app has the <b>codeGeneration</b> capability.</param>
    <param name="InheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="Name">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>DesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMapping">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMappingA">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMappingW">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global" or "Local" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PrefetchVirtualMemory">
    <summary>Provides an efficient mechanism to bring into memory potentially discontiguous virtual address ranges in a process address space.</summary>
    <param name="hProcess">Handle to the process whose virtual address ranges are to be prefetched. Use the<see cref="GetCurrentProcess" /> function to use the current process.</param>
    <param name="NumberOfEntries">Number of entries in the array pointed to by the <i>VirtualAddresses</i>parameter.</param>
    <param name="VirtualAddresses">Pointer to an array of<see cref="WIN32_MEMORY_RANGE_ENTRY" /> structures which each specify a virtual address range to be prefetched. The virtual address ranges may cover any part of the process address space accessible by the target process.</param>
    <param name="Flags">Reserved. Must be 0.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryMemoryResourceNotification">
    <summary>Retrieves the state of the specified memory resource object.</summary>
    <param name="ResourceNotificationHandle">A handle to a memory resource notification object. The<see cref="CreateMemoryResourceNotification" /> function returns this handle.</param>
    <param name="ResourceState">The memory pointed to by this parameter receives the state of the memory resource notification object. The value of this parameter is set to <b>TRUE</b> if the specified memory condition exists, and <b>FALSE</b> if the specified memory condition does not exist.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. For more error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryVirtualMemoryInformation">
    <summary>The <b>QueryVirtualMemoryInformation</b> function returns information about a page or a set of pages within the virtual address space of the specified process.</summary>
    <param name="Process">A handle for the process in whose context the pages to be queried reside.</param>
    <param name="VirtualAddress">The address of the region of pages to be queried. This value is rounded down to the next host-page-address boundary.</param>
    <param name="MemoryInformationClass">The memory information class about which to retrieve information. The only supported value is <b>MemoryRegionInfo</b>.</param>
    <param name="MemoryInformation">
      <para>A pointer to a buffer that receives the specified information.</para>
      <para>If the <i>MemoryInformationClass</i> parameter has a value of <b>MemoryRegionInfo</b>, this parameter must point to a <see cref="WIN32_MEMORY_REGION_INFORMATION" /> structure.</para>
    </param>
    <param name="MemoryInformationSize">Specifies the length in bytes of the memory information buffer.</param>
    <param name="ReturnSize">An optional pointer which, if specified, receives the number of bytes placed in the memory information buffer.</param>
    <returns>Returns <b>TRUE</b> on success. Returns <b>FALSE</b> for failure. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.ReadProcessMemory">
    <param name="hProcess">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
    <param name="lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
    <param name="nSize">The number of bytes to be read from the specified process.</param>
    <param name="lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <i>lpNumberOfBytesRead</i> is <b>NULL</b>, the parameter is ignored.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function fails if the requested read operation crosses into an area of the process that is inaccessible.</para>
    </returns>
  </member>
  <member name="Windows.ReclaimVirtualMemory">
    <summary>
      <para>Reclaims a range of memory pages that were offered to the system with <see cref="OfferVirtualMemory" />.</para>
      <para>If the offered memory has been discarded, the contents of the memory region is undefined and must be rewritten by the application. If the offered memory has not been discarded, it is reclaimed intact.</para>
    </summary>
    <param name="VirtualAddress">Page-aligned starting address of the memory to reclaim.</param>
    <param name="Size">Size, in bytes, of the memory region to reclaim. <i>Size</i> must be an integer multiple of the system page size.</param>
    <returns>
      <para>Returns ERROR_SUCCESS if successful and the memory was reclaimed intact.</para>
      <para>Returns ERROR_BUSY if successful but the memory was discarded and must be rewritten by the application. In this case, the contents of the memory region is undefined.</para>
      <para>Returns a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</para>
    </returns>
  </member>
  <member name="Windows.RegisterBadMemoryNotification">
    <summary>Registers a bad memory notification that is called when one or more bad memory pages are detected and the system cannot remove at least one of them (for example if the pages contains modified data that has not yet been written to the pagefile.)</summary>
    <param name="Callback">A pointer to the application-defined<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh691011(v=vs.85)">BadMemoryCallbackRoutine</a> function to register.</param>
    <returns>Registration handle that represents the callback notification. Can be passed to the<see cref="UnregisterBadMemoryNotification" />function when no longer needed.</returns>
  </member>
  <member name="Windows.ResetWriteWatch">
    <summary>
      <para>Resets the write-tracking state for a region of virtual memory. Subsequent calls to the<see cref="GetWriteWatch" /> function only report pages that are written to since the reset operation.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes, <b>ResetWriteWatch</b>is not supported for 32-bit applications.</para>
    </summary>
    <param name="lpBaseAddress">
      <para>A pointer to the base address of the memory region for which to reset the write-tracking state.</para>
      <para>This address must be in a memory region that is allocated by the<see cref="VirtualAlloc" /> function with <b>MEM_WRITE_WATCH</b>.</para>
    </param>
    <param name="dwRegionSize">The size of the memory region for which to reset the write-tracking information, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is 0 (zero).</para>
      <para>If the function fails, the return value is a nonzero value.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessValidCallTargets">
    <summary>Provides Control Flow Guard (CFG) with a list of valid indirect call targets and specifies whether they should be marked valid or not. The valid call target information is provided as a list of offsets relative to a virtual memory range (start and size of the range). The call targets specified should be 16-byte aligned and in ascending order.</summary>
    <param name="hProcess">The handle to the target process.</param>
    <param name="VirtualAddress">The start of the virtual memory region whose call targets are being marked valid. The memory region must be allocated using one of the executable <a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</param>
    <param name="RegionSize">The size of the virtual memory region.</param>
    <param name="NumberOfOffsets">The number of offsets relative to the virtual memory ranges.</param>
    <param name="OffsetInformation">A list of offsets and flags relative to the virtual memory ranges.</param>
    <returns>
      <b>TRUE</b> if the operation was successful; otherwise, <b>FALSE</b>. To retrieve error values for this function, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.SetProcessWorkingSetSize">
    <summary>Sets the minimum and maximum working set sizes for the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes is to be set.</para>
      <para>The handle must have the <b>PROCESS_SET_QUOTA</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwMinimumWorkingSetSize">
      <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
      <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <param name="dwMaximumWorkingSetSize">
      <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
      <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. Call <see cref="GetLastError" /> to obtain extended error information.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessWorkingSetSizeEx">
    <summary>Sets the minimum and maximum working set sizes for the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes is to be set.</para>
      <para>The handle must have <b>PROCESS_SET_QUOTA</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwMinimumWorkingSetSize">
      <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
      <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <param name="dwMaximumWorkingSetSize">
      <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
      <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process. For details, see Remarks.</para>
    </param>
    <param name="Flags">
      <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The working set may fall below the minimum working set limit if memory demands are high.<para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The working set will not fall below the minimum working set limit.<para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>
            <i>The working set may exceed the maximum working set limit if there is abundant memory.</i>
            <para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>.</para>
          </description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The working set will not exceed the maximum working set limit.<para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function is succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the function fails, the return value is zero. To get extended error information, call<b>GetLastError</b>.</para>
    </returns>
  </member>
  <member name="Windows.SetSystemFileCacheSize">
    <summary>Limits the size of the working set for the file system cache.</summary>
    <param name="MinimumFileCacheSize">
      <para>The minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache.</para>
      <para>To flush the cache, specify <code>(SIZE_T) -1</code>.</para>
    </param>
    <param name="MaximumFileCacheSize">
      <para>The maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if this call or a previous call to <b>SetSystemFileCacheSize</b> specifies <b>FILE_CACHE_MAX_HARD_ENABLE</b>.</para>
      <para>To flush the cache, specify <code>(SIZE_T) -1</code>.</para>
    </param>
    <param name="Flags">
      <para>The flags that enable or disable the file cache limits. If this parameter is 0 (zero), the size limits retain the current setting, which is either disabled or enabled.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MAX_HARD_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Disable the maximum size limit.<para>The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MAX_HARD_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>Enable the maximum size limit.<para>The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MIN_HARD_DISABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x8</term>
              </listheader>
            </list>
          </description>
          <description>Disable the minimum size limit.<para>The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_CACHE_MIN_HARD_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x4</term>
              </listheader>
            </list>
          </description>
          <description>Enable the minimum size limit.<para>The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnmapViewOfFile">
    <summary>Unmaps a mapped view of a file from the calling process's address space.</summary>
    <param name="lpBaseAddress">A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to one of the functions in the<see cref="MapViewOfFile" /> family.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnmapViewOfFile2">
    <summary>Unmaps a previously mapped view of a file or a pagefile-backed section.</summary>
    <param name="Process">A <b>HANDLE</b> to the process from which the section will be unmapped.</param>
    <param name="BaseAddress">The base address of a previously mapped view that is to be unmapped. This value must be identical to the value returned by a previous call to one of the functions in the<see cref="MapViewOfFile" /> family.</param>
    <param name="UnmapFlags">
      <para>This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Specifies that the priority of the pages being unmapped should be temporarily boosted (with automatic short term decay) because the caller expects that these pages will be accessed again shortly from another thread. For more information about memory priorities, see the <see cref="SetThreadInformation(ThreadMemoryPriority)" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Unmaps a mapped view back to a placeholder (after you've replaced a placeholder with a mapped view using <see cref="MapViewOfFile3" /> or <b>MapViewOfFile3FromApp</b>).</description>
        </listheader>
      </list>
    </param>
    <returns>Returns <b>TRUE</b> if successful. Otherwise, returns <b>FALSE</b> and extended error status is available using <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UnmapViewOfFileEx">
    <summary>This is an extended version of <see cref="UnmapViewOfFile" /> that takes an additional flags parameter.</summary>
    <param name="BaseAddress">A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to one of the functions in the<see cref="MapViewOfFile" /> family.</param>
    <param name="UnmapFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Specifies that the priority of the pages being unmapped should be temporarily boosted (with automatic short term decay) because the caller expects that these pages will be accessed again shortly from another thread. For more information about memory priorities, see the <see cref="SetThreadInformation(ThreadMemoryPriority)" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Unmaps a mapped view back to a placeholder (after you've replaced a placeholder with a mapped view using <see cref="MapViewOfFile3" /> or <b>MapViewOfFile3FromApp</b>).</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnregisterBadMemoryNotification">
    <summary>Closes the specified bad memory notification handle.</summary>
    <param name="RegistrationHandle">Registration handle returned from the<see cref="RegisterBadMemoryNotification" />function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAlloc">
    <summary>
      <para>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.</para>
      <para>To allocate memory in the address space of another process, use the <see cref="VirtualAllocEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the <see cref="GetSystemInfo" /> function. If this parameter is <b>NULL</b>, the system determines where to allocate the region.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAlloc</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address is within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error. That is true for enclaves that do not support dynamic memory management (i.e. SGX1). SGX2 enclaves will permit allocation, and the page must be accepted by the enclave after it has been allocated.</para>
    </param>
    <param name="dwSize">The size of the region, in bytes. If the <i>lpAddress</i> parameter is <b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call <b>VirtualAlloc</b> with <code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para><para>If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be <b>MEM_COMMIT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You can commit reserved pages in subsequent calls to the <b>VirtualAlloc</b> function. To reserve and commit pages in one step, call <b>VirtualAlloc</b> with <b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para><para>Other memory allocation functions, such as <b>malloc</b> and <see cref="LocalAlloc" />, cannot use a reserved range of memory until it is released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you specify <b>MEM_RESET</b>, the <b>VirtualAlloc</b> function ignores the value of <i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>VirtualAlloc</b> returns an error if you use <b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the <b>VirtualAlloc</b> function ignores the value of <i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and Windows Server 2012.</para></description>
        </listheader>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_LARGE_PAGES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20000000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the <see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_PHYSICAL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00400000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_TOP_DOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00100000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_WRITE_WATCH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00200000</term>
              </listheader>
            </list>
          </description>
          <description>Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify <b>MEM_RESERVE</b>.<para>To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the <see cref="GetWriteWatch" /> function. To reset the write-tracking state, call <b>GetWriteWatch</b> or <see cref="ResetWriteWatch" />. The write-tracking feature remains enabled for the memory region until the region is freed.</para></description>
        </listheader>
      </list>
    </param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href="https://docs.microsoft.com//windows/win32/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flProtect</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
      <para>When allocating dynamic memory for an enclave, the <i>flProtect</i> parameter must be <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAlloc2">
    <summary>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process (allocated memory is initialized to zero).</summary>
    <param name="Process">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>If <i>Process</i> is <b>NULL</b>, the function allocates memory for the calling process.</para>
    </param>
    <param name="BaseAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If <i>BaseAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, then any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes, and the base address must be a multiple of the system allocation granularity. To determine the allocation granularity, use the<see cref="GetSystemInfo" /> function.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAlloc2</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error. That is true for enclaves that do not support dynamic memory management (i.e. SGX1). SGX2 enclaves will permit allocation, and the page must be accepted by the enclave after it has been allocated.</para>
    </param>
    <param name="Size">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>The size must always be a multiple of the page size.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>BaseAddress</i> to<i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call<b>VirtualAlloc2</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para><para>If <i>BaseAddress</i> specifies an address within an enclave, <i>AllocationType</i> must be <b>MEM_COMMIT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You commit reserved pages by calling<b>VirtualAlloc2</b> again with<b>MEM_COMMIT</b>. To reserve and commit pages in one step, call<b>VirtualAlloc2</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Other memory allocation functions, such as <b>malloc</b> and<see cref="LocalAlloc" />, cannot use reserved memory until it has been released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Replaces a placeholder with a normal private allocation. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i> must exactly match those of the placeholder, and any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes.<para>After you replace a placeholder with a private allocation, to free that allocation back to a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para><para>A placeholder is a type of reserved memory region.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00040000</term>
              </listheader>
            </list>
          </description>
          <description> To create a placeholder, call <b>VirtualAlloc2</b> with <code>MEM_RESERVE | MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To free/split/coalesce a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.<para>A placeholder is a type of reserved memory region.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you use <b>MEM_RESET</b>, the<b>VirtualAlloc2</b> function ignores the value of<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>VirtualAlloc2</b> returns an error if you use<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the<b>VirtualAlloc2</b> function ignores the value of<i>PageProtection</i>. However, you must still set <i>PageProtection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and Windows Server 2012.</para></description>
        </listheader>
      </list> <para>This parameter can also specify the following values as indicated.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_LARGE_PAGES</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the<see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_PHYSICAL</b></term></listheader><listheader><term>0x00400000</term></listheader></list></description><description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_TOP_DOWN</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</description></listheader></list></param>
    <param name="PageProtection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href="https://docs.microsoft.com//windows/win32/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>BaseAddress</i> specifies an address within an enclave, <i>PageProtection</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
      <para>When allocating dynamic memory for an enclave, the <i>PageProtection</i> parameter must be <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b>.</para>
    </param>
    <param name="ExtendedParameters">An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</param>
    <param name="ParameterCount">The number of extended parameters pointed to by <i>ExtendedParameters</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAlloc2FromApp">
    <summary>
      <para>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="Process">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="BaseAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If <i>BaseAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, then any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes, and the base address must be a multiple of the system allocation granularity. To determine the allocation granularity, use the<see cref="GetSystemInfo" /> function.</para>
    </param>
    <param name="Size">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>The size must always be a multiple of the page size.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>BaseAddress</i> to<i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call<b>Virtual2AllocFromApp</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You can commit reserved pages in subsequent calls to the<b>Virtual2AllocFromApp</b> function. To reserve and commit pages in one step, call <b>Virtual2AllocFromApp</b> with<b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para><para>Other memory allocation functions, such as <b>malloc</b> and<see cref="LocalAlloc" />, cannot use a reserved range of memory until it is released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description> Replaces a placeholder with a normal private allocation. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i> must exactly match those of the placeholder, and any provided <see cref="MEM_ADDRESS_REQUIREMENTS" /> structure must consist of all zeroes.<para>After you replace a placeholder with a private allocation, to free that allocation back to a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para><para>A placeholder is a type of reserved memory region.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00040000</term>
              </listheader>
            </list>
          </description>
          <description> To create a placeholder, call <see cref="VirtualAlloc2" /> with <code>MEM_RESERVE | MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To free/split/coalesce a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.<para>A placeholder is a type of reserved memory region.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you specify <b>MEM_RESET</b>, the<b>Virtual2AllocFromApp</b> function ignores the value of<i>Protection</i>. However, you must still set <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Virtual2AllocFromApp</b> returns an error if you use<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the<b>Virtual2AllocFromApp</b> function ignores the value of<i>Protection</i>. However, you must still set <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para></description>
        </listheader>
      </list> <para>This parameter can also specify the following values as indicated.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_LARGE_PAGES</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the<see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_PHYSICAL</b></term></listheader><listheader><term>0x00400000</term></listheader></list></description><description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_TOP_DOWN</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_WRITE_WATCH</b></term></listheader><listheader><term>0x00200000</term></listheader></list></description><description>Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify <b>MEM_RESERVE</b>.<para>To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the<see cref="GetWriteWatch" /> function. To reset the write-tracking state, call <b>GetWriteWatch</b> or<see cref="ResetWriteWatch" />. The write-tracking feature remains enabled for the memory region until the region is freed.</para></description></listheader></list></param>
    <param name="PageProtection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify one of the<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>. The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READ</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>
    </param>
    <param name="ExtendedParameters">An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</param>
    <param name="ParameterCount">The number of extended parameters pointed to by <i>ExtendedParameters</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAllocEx">
    <summary>
      <para>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="VirtualAllocExNuma" />.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.</para>
      <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use the<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAllocEx</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error. That is true for enclaves that do not support dynamic memory management (i.e. SGX1). SGX2 enclaves will permit allocation, and the page must be accepted by the enclave after it has been allocated.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds<i>dwSize</i> up to the next page boundary.</para>
      <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>lpAddress</i> to<i>lpAddress</i>+<i>dwSize</i>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call<b>VirtualAllocEx</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para><para>If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be <b>MEM_COMMIT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You commit reserved pages by calling<b>VirtualAllocEx</b> again with<b>MEM_COMMIT</b>. To reserve and commit pages in one step, call<b>VirtualAllocEx</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Other memory allocation functions, such as <b>malloc</b> and<see cref="LocalAlloc" />, cannot use reserved memory until it has been released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you use <b>MEM_RESET</b>, the<b>VirtualAllocEx</b> function ignores the value of<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>VirtualAllocEx</b> returns an error if you use<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the<b>VirtualAllocEx</b> function ignores the value of<i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and Windows Server 2012.</para></description>
        </listheader>
      </list> <para>This parameter can also specify the following values as indicated.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_LARGE_PAGES</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the<see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_PHYSICAL</b></term></listheader><listheader><term>0x00400000</term></listheader></list></description><description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_TOP_DOWN</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</description></listheader></list></param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <a href="https://docs.microsoft.com//windows/win32/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flProtect</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
      <para>When allocating dynamic memory for an enclave, the <i>flProtect</i> parameter must be <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAllocExNuma">
    <summary>Reserves, commits, or changes the state of a region of memory within the virtual address space of the specified process, and specifies the NUMA node for the physical memory.</summary>
    <param name="hProcess">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.</para>
      <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use the<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the region.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to be allocated, in bytes.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds<i>dwSize</i> up to the next page boundary.</para>
      <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the range from <i>lpAddress</i> to<code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call the function with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You commit reserved pages by calling the function again with <b>MEM_COMMIT</b>. To reserve and commit pages in one step, call the function with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Other memory allocation functions, such as <b>malloc</b> and<see cref="LocalAlloc" />, cannot use reserved memory until it has been released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you use <b>MEM_RESET</b>, the function ignores the value of<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para>The function returns an error if you use <b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the<b>VirtualAllocExNuma</b> function ignores the value of<i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and Windows Server 2012.</para></description>
        </listheader>
      </list> <para>This parameter can also specify the following values as indicated.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_LARGE_PAGES</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the<see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_PHYSICAL</b></term></listheader><listheader><term>0x00400000</term></listheader></list></description><description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_TOP_DOWN</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>Allocates memory at the highest possible address.</description></listheader></list></param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>Protection attributes specified when protecting a page cannot conflict with those specified when allocating a page.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <para>Used only when allocating a new VA region (either committed or reserved). Otherwise this parameter is ignored when the API is used to commit pages in a region that already exists</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualAllocFromApp">
    <summary>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.</summary>
    <param name="BaseAddress">The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the<see cref="GetSystemInfo" /> function. If this parameter is<b>NULL</b>, the system determines where to allocate the region.</param>
    <param name="Size">The size of the region, in bytes. If the <i>BaseAddress</i> parameter is<b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from <i>BaseAddress</i> to<i>BaseAddress</i>+<i>Size</i>. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.<para>To reserve and commit pages in one step, call<b>VirtualAllocFromApp</b> with<code>MEM_COMMIT | MEM_RESERVE</code>.</para><para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>.</para><para>An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESERVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.<para>You can commit reserved pages in subsequent calls to the<b>VirtualAllocFromApp</b> function. To reserve and commit pages in one step, call <b>VirtualAllocFromApp</b> with<b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para><para>Other memory allocation functions, such as <b>malloc</b> and<see cref="LocalAlloc" />, cannot use a reserved range of memory until it is released.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00080000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that data in the memory range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.<para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para><para>When you specify <b>MEM_RESET</b>, the<b>VirtualAllocFromApp</b> function ignores the value of<i>Protection</i>. However, you must still set <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>VirtualAllocFromApp</b> returns an error if you use<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RESET_UNDO</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes.<para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the<b>VirtualAllocFromApp</b> function ignores the value of<i>Protection</i>. However, you must still set <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>.</para></description>
        </listheader>
      </list> <para>This parameter can also specify the following values as indicated.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_LARGE_PAGES</b></term></listheader><listheader><term>0x20000000</term></listheader></list></description><description>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.<para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the<see cref="GetLargePageMinimum" /> function.</para><para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_PHYSICAL</b></term></listheader><listheader><term>0x00400000</term></listheader></list></description><description>Reserves an address range that can be used to map <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) pages.<para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_TOP_DOWN</b></term></listheader><listheader><term>0x00100000</term></listheader></list></description><description>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>MEM_WRITE_WATCH</b></term></listheader><listheader><term>0x00200000</term></listheader></list></description><description>Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify <b>MEM_RESERVE</b>.<para>To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the<see cref="GetWriteWatch" /> function. To reset the write-tracking state, call <b>GetWriteWatch</b> or<see cref="ResetWriteWatch" />. The write-tracking feature remains enabled for the memory region until the region is freed.</para></description></listheader></list></param>
    <param name="Protection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify one of the<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>. The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READ</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualFree">
    <summary>
      <para>Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.</para>
      <para>To free memory allocated in another process by the <see cref="VirtualAllocEx" /> function, use the <see cref="VirtualFreeEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be freed.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be the base address returned by the <see cref="VirtualAlloc" /> function when the region of pages is reserved.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to be freed, in bytes.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to <see cref="VirtualAlloc" />.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by <see cref="VirtualAlloc" /> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by <b>VirtualAlloc</b>. After that, the entire region is in the reserved state.</para>
    </param>
    <param name="dwFreeType">
      <para>The type of free operation. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_DECOMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description>Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.<para>The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state.</para><para>The <b>MEM_DECOMMIT</b> value is not supported when the <i>lpAddress</i> parameter provides the base address for an enclave. This is true for enclaves that do not support dynamic memory management (i.e. SGX1). SGX2 enclaves permit <b>MEM_DECOMMIT</b> anywhere in the enclave.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RELEASE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After this operation, the pages are in the free state. <para>If you specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned by the <see cref="VirtualAlloc" /> function when the region is reserved. The function fails if either of these conditions is not met.</para><para>If any pages in the region are committed currently, the function first decommits, and then releases them.</para><para>The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state.</para></description>
        </listheader>
      </list>
      <para>When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COALESCE_PLACEHOLDERS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>To coalesce two adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match the overall range of the placeholders to be merged.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using <see cref="VirtualAlloc2" /> or <a href="https://msdn.microsoft.com/en-us/library/mt832850(v=vs.85).aspx">Virtual2AllocFromApp</a>).<para>To split a placeholder into two placeholders, specify <code>MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER</code>.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualFreeEx">
    <summary>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.</summary>
    <param name="hProcess">
      <para>A handle to a process. The function frees memory within the virtual address space of the process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>A pointer to the starting address of the region of memory to be freed.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>lpAddress</i> must be the base address returned by the<see cref="VirtualAllocEx" /> function when the region is reserved.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to free, in bytes.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>dwSize</i> must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to<see cref="VirtualAllocEx" />.</para>
      <para>If <i>dwFreeType</i> is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by<see cref="VirtualAllocEx" /> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by<b>VirtualAllocEx</b>. After that, the entire region is in the reserved state.</para>
    </param>
    <param name="dwFreeType">
      <para>The type of free operation. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_DECOMMIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description>Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.<para>The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state.</para><para>The <b>MEM_DECOMMIT</b> value is not supported when the <i>lpAddress</i> parameter provides the base address for an enclave. This is true for enclaves that do not support dynamic memory management (i.e. SGX1). SGX2 enclaves permit MEM_DECOMMIT anywhere in the enclave.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_RELEASE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After this operation, the pages are in the free state. <para>If you specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned by the<see cref="VirtualAlloc" /> function when the region is reserved. The function fails if either of these conditions is not met.</para><para>If any pages in the region are committed currently, the function first decommits, and then releases them.</para><para>The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state.</para></description>
        </listheader>
      </list>
      <para>When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_COALESCE_PLACEHOLDERS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>To coalesce two adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match the overall range of the placeholders to be merged.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using <see cref="VirtualAlloc2" /> or <a href="https://msdn.microsoft.com/en-us/library/mt832850(v=vs.85).aspx">Virtual2AllocFromApp</a>).<para>To split a placeholder into two placeholders, specify <code>MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER</code>.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualLock">
    <summary>Locks the specified region of the process's virtual address space into physical memory, ensuring that subsequent access to the region will not incur a page fault.</summary>
    <param name="lpAddress">A pointer to the base address of the region of pages to be locked.</param>
    <param name="dwSize">The size of the region to be locked, in bytes. The region of affected pages includes all pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes both pages to be locked.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualProtect">
    <summary>
      <para>Changes the protection on a region of committed pages in the virtual address space of the calling process.</para>
      <para>To change the access protection of any process, use the <see cref="VirtualProtectEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>The address of the starting page of the region of pages whose access protection attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the <see cref="VirtualAlloc" /> or <see cref="VirtualAllocEx" /> function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.</para>
    </param>
    <param name="dwSize">The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i><b>lpAddress</b></i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
    <param name="flNewProtect">
      <para>The memory protection option. This parameter can be one of the <a href="https://docs.microsoft.com//windows/win32/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <see cref="MapViewOfFile" />, <see cref="MapViewOfFileEx" />, and <see cref="MapViewOfFileExNuma" />).</para>
    </param>
    <param name="lpflOldProtect">A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualProtectEx">
    <summary>Changes the protection on a region of committed pages in the virtual address space of a specified process.</summary>
    <param name="hProcess">A handle to the process whose memory protection is to be changed. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages whose access protection attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the <see cref="VirtualAlloc" /> or <see cref="VirtualAllocEx" /> function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.</para>
    </param>
    <param name="dwSize">The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
    <param name="flNewProtect">
      <para>The memory protection option. This parameter can be one of the <a href="https://docs.microsoft.com//windows/win32/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <see cref="MapViewOfFile" />, <see cref="MapViewOfFileEx" />, and <see cref="MapViewOfFileExNuma" />).</para>
    </param>
    <param name="lpflOldProtect">A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualProtectFromApp">
    <summary>Changes the protection on a region of committed pages in the virtual address space of the calling process.</summary>
    <param name="Address">
      <para>A pointer an address that describes the starting page of the region of pages whose access protection attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the<see cref="VirtualAlloc" />, <see cref="VirtualAllocFromApp" />, or<see cref="VirtualAllocEx" /> function using<b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b>, <b>VirtualAllocFromApp</b>, or<b>VirtualAllocEx</b> using<b>MEM_RESERVE</b>.</para>
    </param>
    <param name="Size">The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the<i>Address</i> parameter to<code>(Address+Size)</code>. This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
    <param name="NewProtection">
      <para>The memory protection option. This parameter can be one of the<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was mapped (see <see cref="MapViewOfFile" />,<see cref="MapViewOfFileEx" />, and<see cref="MapViewOfFileExNuma" />).</para>
      <para>The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>The following constants are allowed only for apps that have the <b>codeGeneration</b> capability:<list type="bullet"><item><description><b>PAGE_EXECUTE</b></description></item><item><description><b>PAGE_EXECUTE_READ</b></description></item></list></param>
    <param name="OldProtection">A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.VirtualQuery">
    <summary>
      <para>Retrieves information about a range of pages in the virtual address space of the calling process.</para>
      <para>To retrieve information about a range of pages in the address space of another process, use the<see cref="VirtualQueryEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">A pointer to a<see cref="MEMORY_BASIC_INFORMATION" /> structure in which information about the specified page range is returned.</param>
    <param name="dwLength">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</param>
    <returns>
      <para>The return value is the actual number of bytes returned in the information buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
  </member>
  <member name="Windows.VirtualQueryEx">
    <summary>Retrieves information about a range of pages within the virtual address space of a specified process.</summary>
    <param name="hProcess">A handle to the process whose memory information is queried. The handle must have been opened with the <b>PROCESS_QUERY_INFORMATION</b> access right, which enables using the handle to read information from the process object. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">A pointer to a<see cref="MEMORY_BASIC_INFORMATION" /> structure in which information about the specified page range is returned.</param>
    <param name="dwLength">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</param>
    <returns>
      <para>The return value is the actual number of bytes returned in the information buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
  </member>
  <member name="Windows.VirtualUnlock">
    <summary>Unlocks a specified range of pages in the virtual address space of a process, enabling the system to swap the pages out to the paging file if necessary.</summary>
    <param name="lpAddress">A pointer to the base address of the region of pages to be unlocked.</param>
    <param name="dwSize">The size of the region being unlocked, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes both pages to be unlocked.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProcessMemory">
    <summary>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.</summary>
    <param name="hProcess">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
    <param name="lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
    <param name="lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
    <param name="nSize">The number of bytes to be written to the specified process.</param>
    <param name="lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <i>lpNumberOfBytesWritten</i> is <b>NULL</b>, the parameter is ignored.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />. The function fails if the requested write operation crosses into an area of the process that is inaccessible.</para>
    </returns>
  </member>
</doc>