<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AllocateUserPhysicalPages">
    <summary>
      <para>Allocates physical memory pages to be mapped and unmapped within any
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region of
a specified process.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,
<b>AllocateUserPhysicalPages</b> is not supported
for 32-bit applications.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to a process.</para>
      <para>The function allocates memory that can later be mapped within the virtual address space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to allocate, in pages.</para>
      <para>To determine the page size of the computer, use the
<see cref="GetSystemInfo" /> function. On output, this parameter
receives the number of pages that are actually allocated, which might be less than the number requested.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array to store the page frame numbers of the allocated memory.</para>
      <para>The size of the array
that is allocated should be at least the <i>NumberOfPages</i> times the size of the
<b>ULONG_PTR</b> data type.</para>
      <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be
catastrophic. The information in the buffer is not useful to an application.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>Fewer pages than requested can be allocated.
The caller must check the value of the <i>NumberOfPages</i> parameter on return to see how
many pages are allocated. All allocated page frame numbers are sequentially placed in the memory pointed to by
the <i>UserPfnArray</i> parameter.</para>
      <para>If the function fails, the return value is <b>FALSE</b>, and no frames are allocated. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AllocateUserPhysicalPages</b> function
is used to allocate physical memory that can later be mapped within the virtual address space of the process. The <b>SeLockMemoryPrivilege</b> privilege  must be enabled in the caller's token or the function will fail with <b>ERROR_PRIVILEGE_NOT_HELD</b>. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <para>Memory allocated by this function must be physically present in the system.
After the memory is allocated, it is locked down and unavailable to the rest of the virtual memory
management system.</para>
      <para>Physical pages cannot be simultaneously mapped at more than one virtual address.</para>
      <para>Physical pages can reside at any physical address. You should make no assumptions about the contiguity of the
physical pages.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/awe-example">AWE Example</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</seealso>
    <seealso cref="AllocateUserPhysicalPagesNuma" />
    <seealso cref="FreeUserPhysicalPages" />
    <seealso cref="MapUserPhysicalPages" />
    <seealso cref="MapUserPhysicalPagesScatter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.AllocateUserPhysicalPagesNuma">
    <summary>
      <para>Allocates physical memory pages to be mapped and unmapped within any
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region of a
specified process  and specifies the NUMA node for the physical memory.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to a process.</para>
      <para>The function allocates memory that can later be mapped within the virtual address
space of this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to allocate, in pages.</para>
      <para>To determine the page size of the computer, use the
<see cref="GetSystemInfo" /> function. On output, this parameter
receives the number of pages that are actually allocated, which might be less than the number requested.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array to store the page frame numbers of the allocated memory.</para>
      <para>The size of the array that is allocated should be at least the <i>NumberOfPages</i> times
the size of the <b>ULONG_PTR</b> data type.</para>
      <para>
        <b>Caution</b>  Do not attempt to modify this buffer. It contains operating system data, and corruption
could be catastrophic. The information in the buffer is not useful to an application.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>Fewer pages than requested can be allocated. The caller must check the value of the
<i>NumberOfPages</i> parameter on return to see how many pages are allocated. All allocated
page frame numbers are sequentially placed in the memory pointed to by the <i>PageArray</i></para>
      <para>parameter.</para>
      <para>If the function fails, the return value is <b>FALSE</b> and no frames are allocated. To get
extended error information, call the <see cref="GetLastError" /></para>
      <para>function.</para>
    </returns>
    <remarks>
      <para>The <b>AllocateUserPhysicalPagesNuma</b></para>
      <para>function is used to allocate physical memory within a NUMA node that can later be mapped within the virtual
address space of the process. The <b>SeLockMemoryPrivilege</b> privilege must be enabled in the
caller's token or the function will fail with <b>ERROR_PRIVILEGE_NOT_HELD</b>. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <para>Memory allocated by this function must be physically present in the system. After the memory is allocated, it
is locked down and unavailable to the rest of the virtual memory management system.</para>
      <para>Physical pages cannot be simultaneously mapped at more than one virtual address.</para>
      <para>Physical pages can reside at any physical address. You should make no assumptions about the contiguity of the
physical pages.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600
or later.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</seealso>
    <seealso cref="AllocateUserPhysicalPages" />
    <seealso cref="FreeUserPhysicalPages" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
  </member>
  <member name="Windows.CreateFileMapping2">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file. You can specify a preferred NUMA node for the physical memory as an extended parameter; see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="File">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">HANDLE</a></b></para>
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see <a href="https://docs.microsoft.com//windows/win32/FileIO/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMapping</b> creates a file mapping object of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="SecurityAttributes">
      <para>Type: _In_opt_ <b><a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b></para>
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that determines whether a returned handle can be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see <a href="https://docs.microsoft.com//windows/win32/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="DesiredAccess">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONG</a></b></para>
      <para>The desired access mask for the returned file mapping handle. For a list of access rights, see <a href="https://docs.microsoft.com//windows/win32/memory/file-mapping-security-and-access-rights">File-mapping security and access rights</a>.</para>
    </param>
    <param name="PageProtection">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONG</a></b></para>
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="AllocationAttributes">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONG</a></b></para>
      <para>You can specify one or more of the following attributes for the file mapping object. Also see the <i>PageProtection</i> parameter.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/win32/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="MaximumSize">
      <para>Type: _In_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">ULONG64</a></b></para>
      <para>The maximum size of the file mapping object.</para>
      <para>If this parameter is 0 (zero), then the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. You should test for files with a length of 0 (zero), and reject those files.</para>
    </param>
    <param name="Name">
      <para>Type: _In_opt_ <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">PCWSTR</a></b></para>
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, then the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, then the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the <a href="https://docs.microsoft.com//windows/win32/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege. For more information, see <a href="https://docs.microsoft.com//windows/win32/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <param name="ExtendedParameters">
      <para>Type: _Inout_updates_opt_(ParameterCount) <b><see cref="MEM_EXTENDED_PARAMETER" />*</b></para>
      <para>An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</para>
    </param>
    <param name="ParameterCount">
      <para>
        <i>In</i> ULONG ParameterCount</para>
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>See the <b>Remarks</b> for <see cref="CreateFileMapping" />.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/win32/Memory/creating-a-file-mapping-object">Creating a file mapping object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/win32/Memory/memory-management-functions">Memory management functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingFromApp">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file from a
Windows Store app.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingFromApp</b> creates a file
mapping object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="SecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>SecurityAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="PageProtection">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMappingFromApp</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMappingFromApp</b> fails.
When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base
address and view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="MaximumSize">
      <para>The maximum size of the file mapping object.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="Name">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer,
or job object, the function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session
namespace. The remainder of the name can contain any character except the backslash character (\). Creating a
file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /></para>
      <para>returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b>), then the file
on disk is increased to match the specified size of the file mapping object. If the file is extended, the contents
of the file between the old end of the file and the new end of the file are not guaranteed to be zero; the
behavior is defined by the file system. If the file on disk cannot be increased,
<b>CreateFileMappingFromApp</b> fails and
<see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMappingFromApp</b></para>
      <para>returns has full access to a new file mapping object, and can be used with any function that requires a handle to
a file mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFileEx" /> function map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMappingFromApp</b> works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable, and both change
the same page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is
not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>You can only successfully request executable protection if your app has the <b>codeGeneration</b> capability.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNuma">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNumaA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNumaW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMapping">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMemoryResourceNotification">
    <summary>
      <para>Creates a memory resource notification object.</para>
    </summary>
    <param name="NotificationType">
      <para>The memory condition under which the object is to be signaled. This parameter can be one of the following
values from the <b>MEMORY_RESOURCE_NOTIFICATION_TYPE</b> enumeration.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LowMemoryResourceNotification</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Available physical memory is running low.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>HighMemoryResourceNotification</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Available physical memory is high.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to a memory resource notification object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended  information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications can use memory resource notification events to scale the memory usage as appropriate. If
available memory is low, the application can reduce its working set. If available memory is high, the application
can allocate more memory.</para>
      <para>Any thread of the calling process can specify the memory resource notification handle in a call to the
<see cref="QueryMemoryResourceNotification" /></para>
      <para>function or one of the <a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The state of the
object is signaled when the specified memory condition exists. This is a system-wide event, so all applications
receive notification when the object is signaled. Note that there is a range of memory availability where neither
the <b>LowMemoryResourceNotification</b> or
<b>HighMemoryResourceNotification</b> object is signaled. In this case, applications should
attempt to keep the memory use constant.</para>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The
system closes the handle automatically when the process terminates. The memory resource notification object is
destroyed when its last handle has been closed.</para>
      <para>To compile an application that uses this function, define the <b>_WIN32_WINNT</b> macro
as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="QueryMemoryResourceNotification" />
  </member>
  <member name="Windows.DiscardVirtualMemory">
    <summary>
      <para>Discards the memory contents of a range of memory pages, without decommitting the memory.
The contents of discarded memory is undefined and must be rewritten by the application.</para>
    </summary>
    <param name="VirtualAddress">
      <para>Page-aligned starting address of the memory to discard.</para>
    </param>
    <param name="Size">
      <para>Size, in bytes, of the memory region to discard.  <i>Size</i> must be an integer multiple of the system page size.</para>
    </param>
    <returns>
      <para>ERROR_SUCCESS if successful; a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</para>
    </returns>
    <remarks>
      <para>If <b>DiscardVirtualMemory</b> fails, the contents of the region is not altered.</para>
      <para>Use this function to discard memory contents that are no longer needed, while keeping the memory region itself committed.
Discarding memory may give physical RAM back to the system.
When the region of memory is again accessed by the application, the backing RAM is restored, and the contents of the memory is undefined.</para>
      <para>
        <b>Important</b>  Calls to <b>DiscardVirtualMemory</b> will fail if the memory protection is not <b>PAGE_READWRITE</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OfferVirtualMemory" />
    <seealso cref="ReclaimVirtualMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.FlushViewOfFile">
    <summary>
      <para>Writes to the disk a byte range within a mapped view of a file.</para>
    </summary>
    <param name="lpBaseAddress">
      <para>A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.</para>
    </param>
    <param name="dwNumberOfBytesToFlush">
      <para>The number of bytes to be flushed. If <i>dwNumberOfBytesToFlush</i> is zero, the file is flushed from the base address to the end of the mapping.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Flushing a range of a mapped view initiates writing of dirty pages within that range to the disk. Dirty pages are those whose contents have changed since the file view was mapped. The <b>FlushViewOfFile</b> function does not flush the file metadata, and it does not wait to  return until  the changes are flushed from the underlying hardware disk cache and physically written to disk. To flush all the dirty pages plus the metadata for the file and ensure that they are physically written to disk, call <b>FlushViewOfFile</b> and then call the <see cref="FlushFileBuffers" /> function.</para>
      <para>When flushing a memory-mapped file over a network,
<b>FlushViewOfFile</b> guarantees that the data has been written from the local computer, but not that the data resides on the remote computer. The server can cache the data on the remote side. Therefore,
<b>FlushViewOfFile</b> can return before the data has been physically written to disk.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.  If required, the caller should use <see cref="SetFileTime" /> to set the timestamp.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>When CsvFs is paused this call might fail with an error indicating that there is a lock conflict.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-view">Creating a File View</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFile" />
    <seealso cref="UnmapViewOfFile" />
  </member>
  <member name="Windows.FreeUserPhysicalPages">
    <summary>
      <para>Frees
physical memory pages that are allocated previously by using
<see cref="AllocateUserPhysicalPages" /> or <see cref="AllocateUserPhysicalPagesNuma" />. If any of these
pages are currently mapped in the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region, they are automatically unmapped by this call. This does not
affect the virtual address space that is occupied by a specified Address Windowing Extensions (AWE) region.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,
<b>FreeUserPhysicalPages</b> is not supported for
32-bit applications.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to a process.</para>
      <para>The function frees memory within the virtual address space of this process.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory to free, in pages.</para>
      <para>On return, if the function fails, this parameter indicates
the number of pages that are freed.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array of page frame numbers of the allocated memory to be freed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>. In this case, the <i>NumberOfPages</i></para>
      <para>parameter reflect how many pages have actually been released. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In a multiprocessor environment, this function maintains coherence of the hardware translation buffer. When this function returns, all threads on all processors are guaranteed to see the correct mapping.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows
Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/awe-example">AWE Example</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</seealso>
    <seealso cref="AllocateUserPhysicalPages" />
    <seealso cref="AllocateUserPhysicalPagesNuma" />
    <seealso cref="MapUserPhysicalPages" />
    <seealso cref="MapUserPhysicalPagesScatter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.GetLargePageMinimum">
    <summary>
      <para>Retrieves the minimum size of a large page.</para>
    </summary>
    <returns>
      <para>If the processor supports large pages, the return value is the minimum size of a large page.</para>
      <para>If the processor does not support large pages, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The minimum large page size varies, but it is typically 2 MB or greater.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">Large Page Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.GetMemoryErrorHandlingCapabilities">
    <summary>
      <para>Gets the memory error handling capabilities of the system.</para>
    </summary>
    <param name="Capabilities">
      <para>A <b>PULONG</b> that receives one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEHC_PATROL_SCRUBBER_PRESENT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The hardware can detect and report failed memory.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as
<b>_WIN32_WINNT_WIN8</b> or higher. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetProcessWorkingSetSize">
    <summary>
      <para>Retrieves the minimum and maximum working set sizes of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpMinimumWorkingSetSize">
      <para>A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
    </param>
    <param name="lpMaximumWorkingSetSize">
      <para>A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The "working set" of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
    SIZE_T  dwMin, dwMax;
    HANDLE hProcess;

    if (argc != 2)
    {
        printf("This program requires a process ID as an argument.\n");
        return 1;
    }

    // Retrieve a handle to the process.

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                            FALSE, atoi(argv[1]));
     if (!hProcess)
    {
        printf( "OpenProcess failed (%d)\n", GetLastError() );
        return 1;
    }

    // Retrieve the working set size of the process.

    if (!GetProcessWorkingSetSize(hProcess, &amp;amp;amp;amp;amp;amp;dwMin, &amp;amp;amp;amp;amp;amp;dwMax))
    {
        printf("GetProcessWorkingSetSize failed (%d)\n",
            GetLastError());
        return 1;
    }

    printf("Process ID: %d\n", atoi(argv[1]));
    printf("Minimum working set: %lu KB\n", dwMin/1024);
    printf("Maximum working set: %lu KB\n", dwMax/1024);

    CloseHandle(hProcess);

    return 0;
}

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-working-set">Process Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="SetProcessWorkingSetSize" />
  </member>
  <member name="Windows.GetProcessWorkingSetSizeEx">
    <summary>
      <para>Retrieves the minimum and maximum working set sizes of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes will be obtained. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpMinimumWorkingSetSize">
      <para>A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
    </param>
    <param name="lpMaximumWorkingSetSize">
      <para>A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active when memory is in short supply.</para>
    </param>
    <param name="Flags">
      <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set may fall below the minimum working set limit if memory demands are high.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set will not fall below the minimum working set limit.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set may exceed the maximum working set limit if there is abundant memory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set will not exceed the maximum working set limit.</para>
          </description>
        </item>
      </list>
    </param>
    <remarks>
      <para>The "working set" of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-working-set">Process Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="SetProcessWorkingSetSizeEx" />
  </member>
  <member name="Windows.GetSystemFileCacheSize">
    <summary>
      <para>Retrieves the current size limits for the working set of the system cache.</para>
    </summary>
    <param name="lpMinimumFileCacheSize">
      <para>A pointer to a variable that receives the minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache, if there is a previous call to the <see cref="SetSystemFileCacheSize" /> function with the <b>FILE_CACHE_MIN_HARD_ENABLE</b> flag.</para>
    </param>
    <param name="lpMaximumFileCacheSize">
      <para>A pointer to a variable that receives the maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if there is a previous call to <see cref="SetSystemFileCacheSize" /> with the <b>FILE_CACHE_MAX_HARD_ENABLE</b> flag.</para>
    </param>
    <param name="lpFlags">
      <para>The flags that indicate which of the file cache limits are enabled.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MAX_HARD_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The maximum size limit is enabled. If this flag is not present, this limit is disabled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MIN_HARD_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The minimum size limit is enabled. If this flag is not present, this limit is disabled.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>The <b>FILE_CACHE</b> constants will be defined in the Windows header files starting with the Windows SDK for Windows Server 2008. If you are using header files from an earlier version of the SDK, add the definitions shown in <see cref="SetSystemFileCacheSize" /> to your code.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso cref="SetSystemFileCacheSize" />
  </member>
  <member name="Windows.GetWriteWatch">
    <summary>
      <para>Retrieves the addresses of
the pages that are written to in a region of virtual memory.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes, <b>GetWriteWatch</b></para>
      <para>is not supported for 32-bit applications.</para>
    </summary>
    <param name="dwFlags">
      <para>Indicates whether the function resets the write-tracking state.</para>
      <para>To reset the write-tracking state, set this
parameter to <b>WRITE_WATCH_FLAG_RESET</b>. If this parameter is 0 (zero),
<b>GetWriteWatch</b> does not reset the write-tracking state.
For more information, see the Remarks section of this topic.</para>
    </param>
    <param name="lpBaseAddress">
      <para>The base address of the memory region for which to retrieve write-tracking information.</para>
      <para>This address must be in
a memory region that is allocated by the <see cref="VirtualAlloc" /></para>
      <para>function using <b>MEM_WRITE_WATCH</b>.</para>
    </param>
    <param name="dwRegionSize">
      <para>The size of the memory region for which to retrieve write-tracking information, in bytes.</para>
    </param>
    <param name="lpAddresses">
      <para>A pointer to a buffer that receives an array of page addresses in the memory region.</para>
      <para>The addresses indicate
the pages that have been written to since the region has been allocated or the write-tracking state has been reset.</para>
    </param>
    <param name="lpdwCount">
      <para>On input, this variable indicates the size of the <i>lpAddresses</i> array, in array
elements.</para>
      <para>On output, the variable receives the number of page addresses that are returned in the array.</para>
    </param>
    <param name="lpdwGranularity">
      <para>A pointer to a variable that receives the page size, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is 0 (zero).</para>
      <para>If the function fails, the return value is a nonzero value.</para>
    </returns>
    <remarks>
      <para>When you call the <see cref="VirtualAlloc" /> function
to reserve or commit memory, you can specify <b>MEM_WRITE_WATCH</b>. This value causes the system to keep track of the
pages that are written to in the committed memory region. You can call the
<b>GetWriteWatch</b> function to retrieve the addresses of the
pages that have been written to since the region has been allocated or the write-tracking state has been reset.</para>
      <para>To reset the write-tracking state, set the <b>WRITE_WATCH_FLAG_RESET</b> value in the
<i>dwFlags</i> parameter. Alternatively, you can call the
<see cref="ResetWriteWatch" /> function to reset the write-tracking
state. However, if you use <b>ResetWriteWatch</b>,  you must
ensure that no threads write to the region during the interval between the
<b>GetWriteWatch</b> and
<b>ResetWriteWatch</b> calls. Otherwise, there may be written
pages that you do not detect.</para>
      <para>The <b>GetWriteWatch</b> function can be useful to
profilers, debugging tools, or garbage collectors.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="ResetWriteWatch" />
    <seealso cref="VirtualAlloc" />
  </member>
  <member name="Windows.MapUserPhysicalPages">
    <summary>
      <para>Maps
previously allocated physical memory pages at a specified address in an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region.</para>
      <para>To perform batch mapping and unmapping of multiple regions, use the
<see cref="MapUserPhysicalPagesScatter" /> function.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,
<b>MapUserPhysicalPages</b> is not supported for 32-bit
applications.</para>
    </summary>
    <param name="VirtualAddress">
      <para>A pointer to the starting address of the region of memory to remap.</para>
      <para>The value of
<i>lpAddress</i> must be within the address range that the
<see cref="VirtualAlloc" /> function returns when the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is
allocated.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
      <para>The
virtual address range is contiguous starting at <i>lpAddress</i>. The physical frames are
specified by the <i>UserPfnArray</i>.</para>
      <para>The total number of pages cannot extend from the
starting address beyond the end of the range that is specified in
<see cref="AllocateUserPhysicalPages" />.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array of physical page frame numbers.</para>
      <para>These frames are mapped by the argument
<i>lpAddress</i> on return from this function. The size of the memory that is allocated should be
at least the <i>NumberOfPages</i> times the size of the data type
<b>ULONG_PTR</b>.</para>
      <para>Do not attempt to modify this buffer. It contains operating system data, and corruption could be
catastrophic. The information in the buffer is not useful to an application.</para>
      <para>If this parameter is <b>NULL</b>, the specified address range is unmapped.  Also, the specified physical pages are not
freed, and you must call <see cref="FreeUserPhysicalPages" /> to
free them.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b> and no mapping is done—partial or otherwise.
To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The physical pages are unmapped but they are not freed. You must call
<see cref="FreeUserPhysicalPages" /> to free the
physical pages.</para>
      <para>Any number of physical memory pages can be specified, but the memory must  not extend outside the virtual
address space that <see cref="VirtualAlloc" /> allocates. Any
existing address maps are automatically overwritten with the new translations, and the old translations are
unmapped.</para>
      <para>You cannot map physical memory pages outside the range that is specified in
<see cref="AllocateUserPhysicalPages" />. You
can map multiple regions simultaneously, but they cannot overlap.</para>
      <para>Physical pages can be located at any physical address, but do not make assumptions about the contiguity of the
physical pages.</para>
      <para>To unmap the current address range, specify <b>NULL</b> as the physical memory page array parameter. Any
currently mapped pages are unmapped, but are not freed. You must call
<see cref="FreeUserPhysicalPages" /> to free the
physical pages.</para>
      <para>In a multiprocessor environment, this function maintains hardware translation buffer coherence. On return
from this function, all threads on all processors are guaranteed to see the correct mapping.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows
Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/awe-example">AWE Example</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</seealso>
    <seealso cref="AllocateUserPhysicalPages" />
    <seealso cref="FreeUserPhysicalPages" />
    <seealso cref="MapUserPhysicalPagesScatter" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.MapViewOfFile">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling process.</para>
      <para>To specify a suggested base address for the view, use the
<see cref="MapViewOfFileEx" /> function. However, this practice is
not recommended.</para>
    </summary>
    <param name="hFileMappingObject">
      <para>A handle to a file mapping object. The
<see cref="CreateFileMapping" /> and
<see cref="OpenFileMapping" /> functions return this handle.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This
parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_ALL_ACCESS</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with the <b>MapViewOfFile</b> function,
<b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_READ</b>
          </description>
          <description>
            <para>A read-only view of the file is mapped. An attempt to write to the file view results in an access
violation.</para>
            <para>The file mapping object must have been created with <b>PAGE_READONLY</b>,
<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or
<b>PAGE_EXECUTE_READWRITE</b> protection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_WRITE</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFile</b>,
(<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and
<b>FILE_MAP_ALL_ACCESS</b> are equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
      </list>
      <para>Using bitwise OR, you can combine the values above with these values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_COPY</b>
          </description>
          <description>
            <para>A copy-on-write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>,
<b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>,
<b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is
private to the process. The new page is backed by the paging file. The protection of the new page changes
from copy-on-write to read/write.</para>
            <para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view
because the calling process can potentially write to every page in the view, making all pages private. The
contents of the new page are never written back to the original file and are lost when the view is
unmapped.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_EXECUTE</b>
          </description>
          <description>
            <para>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must
have been created with <b>PAGE_EXECUTE_READ</b>,
<b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b></para>
            <para>protection.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is available starting with Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_LARGE_PAGES</b>
          </description>
          <description>
            <para>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.<br /><br /><b>Note: </b>On OS versions before Windows 10, version 1703, the <b>FILE_MAP_LARGE_PAGES</b> flag has no effect. On these releases, the view is automatically mapped using large pages if the section was created with the <b>SEC_LARGE_PAGES</b> flag set.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_TARGETS_INVALID</b>
          </description>
          <description>
            <para>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</para>
          </description>
        </item>
      </list>
      <para>For file mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as
<b>FILE_MAP_READ</b>.</para>
      <para>For more information  about access to file mapping objects, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="dwFileOffsetHigh">
      <para>A high-order <b>DWORD</b> of the file offset where the view begins.</para>
    </param>
    <param name="dwFileOffsetLow">
      <para>A low-order <b>DWORD</b> of the file offset where the view is to begin. The combination
of the high and low offsets must specify an offset within the file mapping. They must also match the  memory
allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To
obtain the memory allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function, which fills in the members of
a <see cref="SYSTEM_INFO" /> structure.</para>
    </param>
    <param name="dwNumberOfBytesToMap">
      <para>The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified
by <see cref="CreateFileMapping" />. If this parameter is 0
(zero), the mapping extends from the specified offset to the end of the file mapping.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Mapping a file makes the specified portion of a file visible in the address space of the calling process.</para>
      <para>For files that are larger than the address space, you can only map a small portion of the file data at one
time. When the first view is complete, you can unmap it and map a new view.</para>
      <para>To obtain the size of a view, use the <see cref="VirtualQuery" /></para>
      <para>function.</para>
      <para>Multiple views of a file (or a file mapping object and its mapped file) are <i>coherent</i></para>
      <para>if they contain identical data at a specified time. This occurs if the file views are derived from any file
mapping object that is backed by the same file. A process can duplicate a file mapping object handle into another
process by using the <see cref="DuplicateHandle" /> function, or
another process can open a file mapping object by name by using the
<see cref="OpenFileMapping" /> function.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>MapViewOfFile</b> works with remote files, it does not keep
them coherent. For example, if two computers both map a file as writable, and both change the same page, each
computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped view of a file is not guaranteed to be coherent with a file that is being accessed by the
<see cref="ReadFile" /> or
<see cref="WriteFile" /> function.</para>
      <para>Do not store pointers in the memory mapped file; store offsets from the base of the file mapping so that the
mapping can be used at any address.</para>
      <para>To guard against <b>EXCEPTION_IN_PAGE_ERROR</b></para>
      <para>exceptions, use structured exception handling to protect any code that writes to or reads from a memory mapped
view of a file other than the page file. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>If a file mapping object is backed by the paging file
(<see cref="CreateFileMapping" /> is called with the
<i>hFile</i> parameter set to <b>INVALID_HANDLE_VALUE</b>), the paging file
must be large enough to hold the entire mapping. If it is not,
<b>MapViewOfFile</b> fails. The initial contents of the pages
in a file mapping object backed by the paging file are 0 (zero).</para>
      <para>When a file mapping object that is backed by the paging file is created, the caller can  specify whether
<b>MapViewOfFile</b> should reserve and commit pages at the
same time (<b>SEC_COMMIT</b>) or  simply reserve pages
(<b>SEC_RESERVE</b>). Mapping the file makes the entire mapped virtual address range
unavailable to other allocations in the process. After a page from the reserved range is committed, it cannot be
freed or decommitted by calling <see cref="VirtualFree" />. Reserved and
committed pages are released when the view is unmapped and the file mapping object is closed. For details, see
the <see cref="UnmapViewOfFile" /> and
<see cref="CloseHandle" /> functions.</para>
      <para>To have a file with executable permissions, an application must call
<see cref="CreateFileMapping" /> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>,
and then call <b>MapViewOfFile</b> with
<b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_WRITE</b> or
<b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_READ</b>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>When CsvFs is paused this call might fail with an error indicating that there is a lock conflict.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-view">Creating a File View</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetSystemInfo" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="SYSTEM_INFO" />
    <seealso cref="UnmapViewOfFile" />
  </member>
  <member name="Windows.MapViewOfFile2">
    <summary>
      <para>Maps a view of a file or a pagefile-backed section into the address
space of the specified process.</para>
    </summary>
    <param name="FileMappingHandle">
      <para>A <b>HANDLE</b> to a section that is to be mapped
into the address space of the specified process.</para>
    </param>
    <param name="ProcessHandle">
      <para>A <b>HANDLE</b> to a process into which the section
will be mapped. The handle must have the <b>PROCESS_VM_OPERATION</b> access mask.</para>
    </param>
    <param name="Offset">
      <para>The offset from the beginning of the section.
This must be 64k aligned.</para>
    </param>
    <param name="BaseAddress">
      <para>The desired base address of the view.
The address is rounded down to the nearest 64k boundary.
If this parameter is <b>NULL</b>, the system picks the base
address.</para>
    </param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero (0)
specifies that the entire section is to be mapped.</para>
    </param>
    <param name="AllocationType">
      <para>The type of allocation. This parameter can be zero (0) or one of the following constant values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>MEM_RESERVE</b> - Maps a reserved view.</description>
        </item>
        <item>
          <description>
            <b>MEM_LARGE_PAGES</b> - Maps a large page view. This flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for the <i>BaseAddress</i> parameter, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as
<b>PAGE_READONLY</b>.</para>
    </param>
    <returns>
      <para>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available
using <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileNuma2" />
  </member>
  <member name="Windows.MapViewOfFile3">
    <summary>
      <para>Maps a view of a file or a pagefile-backed section into the address
space of the specified process.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="FileMapping">
      <para>A <b>HANDLE</b> to a section that is to be mapped
into the address space of the specified process.</para>
    </param>
    <param name="Process">
      <para>A <b>HANDLE</b> to a process into which the section
will be mapped.</para>
    </param>
    <param name="BaseAddress">
      <para>The desired base address of the view.
The address is rounded down to the nearest 64k boundary.
If this parameter is <b>NULL</b>, the system picks the base
address.</para>
    </param>
    <param name="Offset">
      <para>The offset from the beginning of the section.
This must be 64k aligned.</para>
    </param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero (0)
specifies that the entire section is to be mapped.</para>
      <para>The size must always be a multiple of the page size.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Maps a reserved view.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Replaces a placeholder with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder.</para>
            <para>After you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the <i>UnmapFlags</i> parameter of <see cref="UnmapViewOfFileEx" /> and <see cref="UnmapViewOfFile2" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
            <para>The 64k alignment requirements on <i>Offset</i> and <i>BaseAddress</i> do not apply when this flag is specified.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Maps a large page view. This flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for the <i>BaseAddress</i> parameter, then the value must be a multiple of <b>GetLargePageMinimum</b>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as
<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="ExtendedParameters">
      <para>An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</para>
    </param>
    <param name="ParameterCount">
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available
using <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This API helps support high-performance games, and server applications, which have particular requirements around managing their virtual address space. For example, mapping memory on top of a previously reserved region; this is useful for implementing an automatically wrapping ring buffer. And allocating memory with specific alignment; for example, to enable your application to commit large/huge page-mapped regions on demand.</para>
      <h4>Examples</h4>
      <para>For a code example, see Scenario 1 in <see cref="VirtualAlloc2" />.</para>
    </remarks>
    <seealso cref="VirtualAlloc2" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFile2" />
    <seealso cref="MapViewOfFileNuma2" />
  </member>
  <member name="Windows.MapViewOfFile3FromApp">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling
Windows Store app.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="FileMapping">
      <para>A <b>HANDLE</b> to a section that is to be mapped
into the address space of the specified process.</para>
    </param>
    <param name="Process">
      <para>A <b>HANDLE</b> to a process into which the section
will be mapped.</para>
    </param>
    <param name="BaseAddress">
      <para>The desired base address of the view.
The address is rounded down to the nearest 64k boundary.
If this parameter is <b>NULL</b>, the system picks the base
address.</para>
    </param>
    <param name="Offset">
      <para>The offset from the beginning of the section.
This must be 64k aligned.</para>
    </param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero (0)
specifies that the entire section is to be mapped.</para>
      <para>The size must always be a multiple of the page size.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Maps a reserved view.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Replaces a placeholder with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder.</para>
            <para>After you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the <i>UnmapFlags</i> parameter of <see cref="UnmapViewOfFileEx" /> and <see cref="UnmapViewOfFile2" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Maps a large page view. See <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as
<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="ExtendedParameters">
      <para>An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</para>
    </param>
    <param name="ParameterCount">
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available
using <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This API helps support high-performance games, and server applications, which have particular requirements around managing their virtual address space. For example, mapping memory on top of a previously reserved region; this is useful for implementing an automatically wrapping ring buffer. And allocating memory with specific alignment; for example, to enable your application to commit large/huge page-mapped regions on demand.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>MapViewOfFile3FromApp</b> works with remote files, it
does not keep them coherent. For example, if two computers both map a file as writable, and both change the same
page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is not
merged.</para>
      <para>You can only successfully request executable protection if your app has the <b>codeGeneration</b> capability.</para>
      <h4>Examples</h4>
      <para>For a code example, see Scenario 1 in <a href="https://msdn.microsoft.com/en-us/library/mt832849(v=vs.85).aspx">Virtual2Alloc</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-view">Creating a File View</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetSystemInfo" />
    <seealso cref="MapViewOfFile3" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="SYSTEM_INFO" />
    <seealso cref="UnmapViewOfFile" />
  </member>
  <member name="Windows.MapViewOfFileEx">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling process. A caller can optionally
specify a suggested base memory address for the view.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="MapViewOfFileExNuma" />.</para>
    </summary>
    <param name="hFileMappingObject">
      <para>A handle to a file mapping object. The
<see cref="CreateFileMapping" /> and
<see cref="OpenFileMapping" /> functions return this handle.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This
parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_ALL_ACCESS</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped.  The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with the <b>MapViewOfFileEx</b> function,
<b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_READ</b>
          </description>
          <description>
            <para>A read-only view of the file is mapped. An attempt to write to the file view results in an access
violation.</para>
            <para>The file mapping object must have been created with <b>PAGE_READONLY</b>,
<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or
<b>PAGE_EXECUTE_READWRITE</b> protection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_WRITE</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFileEx</b>,
(<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and
<b>FILE_MAP_ALL_ACCESS</b> are equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
      </list>
      <para>Using bitwise OR, you can combine the values above with these values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_COPY</b>
          </description>
          <description>
            <para>A copy-on-write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>,
<b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>,
<b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is
private to the process. The new page is backed by the paging file. The protection of the new page changes
from copy-on-write to read/write.</para>
            <para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view
because the calling process can potentially write to every page in the view, making all pages private. The
contents of the new page are never written back to the original file and are lost when the view is
unmapped.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_LARGE_PAGES</b>
          </description>
          <description>
            <para>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_EXECUTE</b>
          </description>
          <description>
            <para>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must
have been created with <b>PAGE_EXECUTE_READ</b>,
<b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b></para>
            <para>protection.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is available starting with Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_TARGETS_INVALID</b>
          </description>
          <description>
            <para>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</para>
          </description>
        </item>
      </list>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as
<b>FILE_MAP_READ</b>.</para>
      <para>For more information  about access to file mapping objects, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="dwFileOffsetHigh">
      <para>The high-order <b>DWORD</b> of the file offset where the view is to begin.</para>
    </param>
    <param name="dwFileOffsetLow">
      <para>The low-order <b>DWORD</b> of the file offset where the view is to begin. The
combination of the high and low offsets must specify an offset within the file mapping. They must also match the
memory allocation granularity of the system. That is, the offset must be a multiple of the allocation
granularity. To obtain the memory allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function, which fills in the members of
a <see cref="SYSTEM_INFO" /> structure.</para>
    </param>
    <param name="dwNumberOfBytesToMap">
      <para>The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified
by <see cref="CreateFileMapping" />. If this parameter is 0
(zero), the mapping extends from the specified offset to the end of the file mapping.</para>
    </param>
    <param name="lpBaseAddress">
      <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a
multiple of the system's memory allocation granularity, or the function fails. To determine the memory
allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function. If there is not enough
address space at the specified address, the function fails.</para>
      <para>If <i>lpBaseAddress</i> is <b>NULL</b>, the operating system chooses
the mapping address. In this scenario, the function is equivalent to the
<see cref="MapViewOfFile" /> function.</para>
      <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no
guarantee that the address will remain safe over time. Therefore, it is better to let the operating system
choose the address. In this case, you would not store pointers in the memory mapped file, you would store
offsets from the base of the file mapping so that the mapping can be used at any address.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Mapping a file makes the specified portion of the file visible in the address space of the calling
process.</para>
      <para>For files that are larger than the address space, you can only map a small portion of the file data at one
time. When the first view is complete, then you unmap it and map a new view.</para>
      <para>To obtain the size of a view, use the
<see cref="VirtualQueryEx" /> function.</para>
      <para>The initial contents of the pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>Typically, the suggested address is used to specify that a file should be mapped at the same address in
multiple processes. This requires the region of address space to be available in all involved processes. No other
memory allocation can take place in the region that is used for mapping, including the use of the
<see cref="VirtualAlloc" /> or
<see cref="VirtualAllocEx" /> function to reserve memory.</para>
      <para>If the <i>lpBaseAddress</i> parameter specifies a base offset, the function succeeds if the
specified memory region is not already in use by the calling process. The system does not ensure that the same
memory region is available for the memory mapped file in other 32-bit processes.</para>
      <para>Multiple views of a file (or a file mapping object and its mapped file) are <i>coherent</i></para>
      <para>if they contain identical data at a specified time. This occurs if the file views are derived from the same file
mapping object. A process can duplicate a file mapping object handle into another process by using the
<see cref="DuplicateHandle" /> function, or another process can open
a file mapping object by name by using the
<see cref="OpenFileMapping" /> function.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>MapViewOfFileEx</b> works with remote files, it does not
keep them coherent. For example, if two computers both map a file as writable, and both change the same page, each
computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped view of a file is not guaranteed to be coherent with a file being accessed by the
<see cref="ReadFile" /> or
<see cref="WriteFile" /> function.</para>
      <para>To guard against <b>EXCEPTION_IN_PAGE_ERROR</b> exceptions, use structured exception
handling to protect any code that writes to or reads from a memory mapped view of a file other than the page file.
For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>To have a file with executable permissions, an application must call
<see cref="CreateFileMapping" /> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then call
<b>MapViewOfFileEx</b> with
<b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_WRITE</b> or
<b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_READ</b>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-view">Creating a File View</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="GetSystemInfo" />
    <seealso cref="MapViewOfFileExNuma" />
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso cref="SYSTEM_INFO" />
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.MapViewOfFileFromApp">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling
Windows Store app.</para>
    </summary>
    <param name="hFileMappingObject">
      <para>A handle to a file mapping object. The
<see cref="CreateFileMappingFromApp" />  function returns
this handle.</para>
    </param>
    <param name="DesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This
parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_ALL_ACCESS</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFileFromApp</b>, <b>FILE_MAP_ALL_ACCESS</b> is equivalent to
<b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_READ</b>
          </description>
          <description>
            <para>A read-only view of the file is mapped. An attempt to write to the file view results in an access
violation.</para>
            <para>The file mapping object must have been created with <b>PAGE_READONLY</b>,
<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or
<b>PAGE_EXECUTE_READWRITE</b> protection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_WRITE</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFileFromApp</b>,
<code>(FILE_MAP_WRITE | FILE_MAP_READ)</code> is equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
      </list>
      <para>Using bitwise OR, you can combine the values above with these values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_COPY</b>
          </description>
          <description>
            <para>A copy-on-write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>,
<b>PAGE_WRITECOPY</b>, or
<b>PAGE_READWRITE</b> protection.</para>
            <para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is
private to the process. The new page is backed by the paging file. The protection of the new page changes
from copy-on-write to read/write.</para>
            <para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view
because the calling process can potentially write to every page in the view, making all pages private. The
contents of the new page are never written back to the original file and are lost when the view is
unmapped.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_LARGE_PAGES</b>
          </description>
          <description>
            <para>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_TARGETS_INVALID</b>
          </description>
          <description>
            <para>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</para>
          </description>
        </item>
      </list>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as
<b>FILE_MAP_READ</b>.</para>
      <para>For more information  about access to file mapping objects, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="FileOffset">
      <para>The file offset where the view is to begin. The offset must specify an offset within the file mapping. They
must also match the  memory allocation granularity of the system. That is, the offset must be a multiple of the
allocation granularity. To obtain the memory allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function, which fills in the members of
a <see cref="SYSTEM_INFO" /> structure.</para>
    </param>
    <param name="NumberOfBytesToMap">
      <para>The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified
by <see cref="CreateFileMappingFromApp" />. If this
parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>MapViewOfFileFromApp</b> works with remote files, it
does not keep them coherent. For example, if two computers both map a file as writable, and both change the same
page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is not
merged.</para>
      <para>You can only successfully request executable protection if your app has the <b>codeGeneration</b> capability.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-view">Creating a File View</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="GetSystemInfo" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="SYSTEM_INFO" />
    <seealso cref="UnmapViewOfFile" />
  </member>
  <member name="Windows.MapViewOfFileNuma2">
    <summary>
      <para>Maps a view of a file or a pagefile-backed section into the address
space of the specified process.</para>
    </summary>
    <param name="FileMappingHandle">
      <para>A <b>HANDLE</b> to a section that is to be mapped
into the address space of the specified process.</para>
    </param>
    <param name="ProcessHandle">
      <para>A <b>HANDLE</b> to a process into which the section
will be mapped.</para>
    </param>
    <param name="Offset">
      <para>The offset from the beginning of the section.
This must be 64k aligned.</para>
    </param>
    <param name="BaseAddress">
      <para>The desired base address of the view.
The address is rounded down to the nearest 64k boundary.
If this parameter is <b>NULL</b>, the system picks the base
address.</para>
    </param>
    <param name="ViewSize">
      <para>The number of bytes to map. A value of zero
(0) specifies that the entire section is to be mapped.</para>
    </param>
    <param name="AllocationType">
      <para>The type of allocation. This parameter can be zero (0) or one of the following constant values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>MEM_RESERVE</b> - Maps a reserved view</description>
        </item>
        <item>
          <description>
            <b>MEM_LARGE_PAGES</b> - Maps a large page view</description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The desired page protection.</para>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>PageProtection</i> parameter has no effect, and should be set to any valid value such as
<b>PAGE_READONLY</b>.</para>
    </param>
    <param name="PreferredNode">
      <para>The preferred NUMA node for this memory.</para>
    </param>
    <returns>
      <para>Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error status is available
using <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileNuma" />
  </member>
  <member name="Windows.OfferVirtualMemory">
    <summary>
      <para>Indicates that the data contained in a range of memory pages is no longer needed by the application and can be discarded by the system if necessary.</para>
      <para>The specified pages will be marked as inaccessible, removed from the process working set, and will not be written to the paging file.</para>
      <para>To later reclaim offered pages, call <see cref="ReclaimVirtualMemory" />.</para>
    </summary>
    <param name="VirtualAddress">
      <para>Page-aligned starting address of the memory to offer.</para>
    </param>
    <param name="Size">
      <para>Size, in bytes, of the memory region to offer.  <i>Size</i> must be an integer multiple of the system page size.</para>
    </param>
    <param name="Priority">
      <para>
        <i>Priority</i> indicates how important the offered memory is to the application.
A higher priority increases the probability that the offered memory can be reclaimed intact when calling <see cref="ReclaimVirtualMemory" />.
The system typically discards lower priority memory before discarding higher priority memory.
<i>Priority</i> must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VMOfferPriorityVeryLow</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The offered memory is very low priority, and should be the first discarded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VMOfferPriorityLow</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The offered memory is low priority.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VMOfferPriorityBelowNormal</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The offered memory is below normal priority.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VMOfferPriorityNormal</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The offered memory is of normal priority to the application, and should be the last discarded.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>ERROR_SUCCESS if successful; a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</para>
    </returns>
    <remarks>
      <para>To reclaim offered pages, call <see cref="ReclaimVirtualMemory" />.
The data in reclaimed pages may have been discarded, in which case the contents of the memory region is undefined and must be rewritten by the application.</para>
      <para>Do not call <b>OfferVirtualMemory</b> to offer virtual memory that is locked.
Doing so will unlock the specified range of pages.</para>
      <para>Note that offering and reclaiming virtual memory is similar to using the MEM_RESET and MEM_RESET_UNDO memory allocation flags,
except that <b>OfferVirtualMemory</b> removes the memory from the process working set and restricts access to the offered pages until they are reclaimed.</para>
    </remarks>
    <seealso cref="DiscardVirtualMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="ReclaimVirtualMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.OpenFileMappingFromApp">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="DesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>. You can only open the file mapping object for <b>FILE_MAP_EXECUTE</b> access if your app has the <b>codeGeneration</b> capability.</para>
    </param>
    <param name="InheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="Name">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>DesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global" or "Local" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can call <b>OpenFileMappingFromApp</b> from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the <b>codeGeneration</b> capability in the app manifest file to use JIT capabilities. <b>OpenFileMappingFromApp</b> lets Windows Store apps use the <a href="https://docs.microsoft.com//dotnet/api/system.io.memorymappedfiles.memorymappedfile">MemoryMappedFile</a> class in the .NET Framework.</para>
      <para>The handle that <b>OpenFileMappingFromApp</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMappingFromApp</b> with a call to
<see cref="CloseHandle" />.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenFileMapping">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global" or "Local" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenFileMappingA">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global" or "Local" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenFileMappingW">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global" or "Local" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.PrefetchVirtualMemory">
    <summary>
      <para>Provides an efficient mechanism to bring into memory potentially discontiguous virtual address ranges
in a process address space.</para>
    </summary>
    <param name="hProcess">
      <para>Handle to the process whose virtual address ranges are to be prefetched. Use the
<see cref="GetCurrentProcess" /> function to use the current
process.</para>
    </param>
    <param name="NumberOfEntries">
      <para>Number of entries in the array pointed to by the <i>VirtualAddresses</i></para>
      <para>parameter.</para>
    </param>
    <param name="VirtualAddresses">
      <para>Pointer to an array of
<see cref="WIN32_MEMORY_RANGE_ENTRY" /> structures which
each specify a virtual address range to be prefetched. The virtual address ranges may cover any part of the
process address space accessible by the target process.</para>
    </param>
    <param name="Flags">
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>PrefetchVirtualMemory</b> function is
targeted at applications that know with reasonable confidence the set of addresses they will be accessing. If
it's likely that these addresses are no longer resident in memory (i.e. they have been paged out to disk),
calling the <b>PrefetchVirtualMemory</b> function on
those address ranges before access will reduce the overall latency because the API will efficiently bring in
those address ranges from disk using large, concurrent I/O requests where possible.</para>
      <para>The <b>PrefetchVirtualMemory</b> function allows
applications to make efficient use of disk hardware by issuing large, concurrent I/Os where possible when the
application provides a list of process address ranges that are going to be accessed. Even for a single address
range (e.g. a file mapping), the
<b>PrefetchVirtualMemory</b> function can provide
performance improvements by issuing a single large I/O rather than the many smaller I/Os that would be issued via
page faulting.</para>
      <para>The <b>PrefetchVirtualMemory</b> function is purely
a performance optimization: prefetching is not necessary for accessing the target address ranges. The prefetched
memory is not added to the target process' working set; it is cached in physical memory. When the prefetched
address ranges are accessed by the target process, they will be added to the working set.</para>
      <para>Since the <b>PrefetchVirtualMemory</b> function can
never be necessary for correct operation of applications, it is treated as a strong hint by the system and is
subject to usual physical memory constraints where it can completely or partially fail under low-memory
conditions. It can also create memory pressure if called with large address ranges, so applications should only
prefetch address ranges they will actually use.</para>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as
<b>_WIN32_WINNT_WIN8</b> or higher. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="WIN32_MEMORY_RANGE_ENTRY" />
  </member>
  <member name="Windows.QueryMemoryResourceNotification">
    <summary>
      <para>Retrieves the state of the specified memory resource object.</para>
    </summary>
    <param name="ResourceNotificationHandle">
      <para>A handle to a memory resource notification object. The
<see cref="CreateMemoryResourceNotification" /> function returns this handle.</para>
    </param>
    <param name="ResourceState">
      <para>The memory pointed to by this parameter receives the state of the memory resource notification object. The value of this parameter is set to <b>TRUE</b> if the specified memory condition exists, and  <b>FALSE</b> if the specified memory condition does not exist.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. For more error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Unlike the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>,
<b>QueryMemoryResourceNotification</b> does not block the calling thread. Therefore, it is an efficient way to check the state of physical memory before proceeding with an operation.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CreateMemoryResourceNotification" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.QueryVirtualMemoryInformation">
    <summary>
      <para>The <b>QueryVirtualMemoryInformation</b> function returns information about a page or a set of pages within the virtual address space of the specified process.</para>
    </summary>
    <param name="Process">
      <para>A handle for the process in whose context the pages to be queried reside.</para>
    </param>
    <param name="VirtualAddress">
      <para>The address of the region of pages to be queried. This value is rounded down to the next host-page-address boundary.</para>
    </param>
    <param name="MemoryInformationClass">
      <para>The memory information class about which to retrieve information. The only supported value is <b>MemoryRegionInfo</b>.</para>
    </param>
    <param name="MemoryInformation">
      <para>A pointer to a buffer that receives the specified information.</para>
      <para>If the <i>MemoryInformationClass</i> parameter has a value of  <b>MemoryRegionInfo</b>, this parameter must point to a <see cref="WIN32_MEMORY_REGION_INFORMATION" /> structure.</para>
    </param>
    <param name="MemoryInformationSize">
      <para>Specifies the length in bytes of the memory information buffer.</para>
    </param>
    <param name="ReturnSize">
      <para>An optional pointer which, if specified, receives the number of bytes placed in the memory information buffer.</para>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> on success. Returns <b>FALSE</b> for failure. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>MemoryInformationClass</i> parameter has a value of <b>MemoryRegionInfo</b>, the <i>MemoryInformation</i> parameter must point to a <see cref="WIN32_MEMORY_REGION_INFORMATION" /> structure. The <i>VirtualAddress</i> parameter must point to an address within a valid memory allocation. If the <i>VirtualAddress</i> parameter points to an unallocated memory region, the function fails.</para>
    </remarks>
    <seealso cref="GetLastError" />
    <seealso cref="MEMORY_BASIC_INFORMATION" />
    <seealso cref="WIN32_MEMORY_REGION_INFORMATION" />
  </member>
  <member name="Windows.ReadProcessMemory">
    <param name="hProcess">
      <para>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</para>
    </param>
    <param name="lpBaseAddress">
      <para>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the contents from the address space of the specified process.</para>
    </param>
    <param name="nSize">
      <para>The number of bytes to be read from the specified process.</para>
    </param>
    <param name="lpNumberOfBytesRead">
      <para>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <i>lpNumberOfBytesRead</i> is <b>NULL</b>, the parameter is ignored.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function fails if the requested read operation crosses into an area of the process that is inaccessible.</para>
    </returns>
    <remarks>
      <para>
        <b>ReadProcessMemory</b> copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function.</para>
      <para>The entire area to be read must be accessible, and if it is not accessible, the function fails.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="OpenProcess" />
    <seealso href="https://docs.microsoft.com//windows/win32/debug/process-functions-for-debugging">Process Functions for Debugging</seealso>
    <seealso cref="VirtualAllocEx" />
    <seealso cref="WriteProcessMemory" />
  </member>
  <member name="Windows.ReclaimVirtualMemory">
    <summary>
      <para>Reclaims a range of memory pages that were offered to the system with <see cref="OfferVirtualMemory" />.</para>
      <para>If the offered memory has been discarded, the contents of the memory region is undefined and must be rewritten by the application.
If the offered memory has not been discarded, it is reclaimed intact.</para>
    </summary>
    <param name="VirtualAddress">
      <para>Page-aligned starting address of the memory to reclaim.</para>
    </param>
    <param name="Size">
      <para>Size, in bytes, of the memory region to reclaim.  <i>Size</i> must be an integer multiple of the system page size.</para>
    </param>
    <returns>
      <para>Returns ERROR_SUCCESS if successful and the memory was reclaimed intact.</para>
      <para>Returns ERROR_BUSY if successful but the memory was discarded and must be rewritten by the application.  In this case, the contents of the memory region is undefined.</para>
      <para>Returns a <a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Code</a> otherwise.</para>
    </returns>
    <remarks>
      <para>Reclaimed memory pages can be used by the application, and will be written to the system paging file if paging occurs.</para>
      <para>If the function returns ERROR_SUCCESS, the data in the reclaimed pages is valid.
If the function returns ERROR_BUSY, the data in the reclaimed pages was discarded by the system and is no longer valid.
For this reason, memory should only be offered to the system if the application does not need or can regenerate the data.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OfferVirtualMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.RegisterBadMemoryNotification">
    <summary>
      <para>Registers a bad memory notification that is called when one or more bad memory pages are detected and the system
cannot remove at least one of them (for example if the pages contains modified data that has not yet been written
to the pagefile.)</para>
    </summary>
    <param name="Callback">
      <para>A pointer to the application-defined
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh691011(v=vs.85)">BadMemoryCallbackRoutine</a> function to
register.</para>
    </param>
    <returns>
      <para>Registration handle that represents the callback notification. Can be passed to the
<see cref="UnregisterBadMemoryNotification" /></para>
      <para>function when no longer needed.</para>
    </returns>
    <remarks>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as
<b>_WIN32_WINNT_WIN8</b> or higher. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.ResetWriteWatch">
    <summary>
      <para>Resets the
write-tracking state for a region of virtual memory. Subsequent calls to the
<see cref="GetWriteWatch" /> function only report pages that are written to since the reset operation.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes, <b>ResetWriteWatch</b></para>
      <para>is not supported for 32-bit applications.</para>
    </summary>
    <param name="lpBaseAddress">
      <para>A pointer to the base address of the memory region for which to reset the write-tracking state.</para>
      <para>This address
must be in a memory region that is allocated by the
<see cref="VirtualAlloc" /> function with <b>MEM_WRITE_WATCH</b>.</para>
    </param>
    <param name="dwRegionSize">
      <para>The size of the memory region for which to reset the write-tracking information, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is 0 (zero).</para>
      <para>If the function fails, the return value is a nonzero value.</para>
    </returns>
    <remarks>
      <para>The <b>ResetWriteWatch</b> function can be useful to an
application such as a garbage collector. The application calls the
<see cref="GetWriteWatch" /> function to retrieve the list of written
pages, and then writes to those pages as part of its cleanup operation. Then the garbage collector calls
<b>ResetWriteWatch</b> to remove the write-tracking records
caused by the cleanup.</para>
      <para>You can also reset the write-tracking state of a memory region by specifying <b>WRITE_WATCH_FLAG_RESET</b> when you
call <see cref="GetWriteWatch" />.</para>
      <para>If you use <b>ResetWriteWatch</b>, you must ensure that
no threads write to the region during the interval between the
<see cref="GetWriteWatch" /> and
<b>ResetWriteWatch</b> calls. Otherwise, there may be written
pages that you not detect.</para>
    </remarks>
    <seealso cref="GetWriteWatch" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="VirtualAlloc" />
  </member>
  <member name="Windows.SetProcessValidCallTargets">
    <summary>
      <para>Provides Control Flow Guard (CFG) with a list of valid indirect call targets and specifies whether they should be marked valid or not. The valid call target information is provided as a list of offsets relative to a virtual memory range (start and size of the range). The call targets specified should be 16-byte aligned and in ascending order.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to the target process.</para>
    </param>
    <param name="VirtualAddress">
      <para>The start of the virtual memory region whose call targets are being marked valid. The memory region must be allocated using one of the executable <a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
    </param>
    <param name="RegionSize">
      <para>The size of the virtual memory region.</para>
    </param>
    <param name="NumberOfOffsets">
      <para>The number of offsets relative to the virtual memory ranges.</para>
    </param>
    <param name="OffsetInformation">
      <para>A list of offsets and flags relative to the virtual memory ranges.</para>
    </param>
    <returns>
      <para>
        <b>TRUE</b> if the operation was successful; otherwise, <b>FALSE</b>. To retrieve error values for this function, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function does not succeed if Control Flow Guard is not enabled for the target process. This can be checked using <see cref="GetProcessMitigationPolicy" />.</para>
    </remarks>
  </member>
  <member name="Windows.SetProcessWorkingSetSize">
    <summary>
      <para>Sets the minimum and maximum working set sizes for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes is to be set.</para>
      <para>The handle must have the <b>PROCESS_SET_QUOTA</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwMinimumWorkingSetSize">
      <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
      <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <param name="dwMaximumWorkingSetSize">
      <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
      <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. Call <see cref="GetLastError" /> to obtain extended error information.</para>
    </returns>
    <remarks>
      <para>The working set of a process is the set of memory pages in the virtual address space of the process that are currently resident in physical memory. These pages are available for an application to use without triggering a page fault. For more information about page faults, see <a href="https://docs.microsoft.com//windows/desktop/Memory/working-set">Working Set</a>. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process.</para>
      <para>The working set of the specified process can be emptied by specifying the value (<b>SIZE_T</b>)–1 for both the minimum and maximum working set sizes. This removes as many pages as possible from the working set. The <see cref="EmptyWorkingSet" /> function can also be used for this purpose.</para>
      <para>If the values of either <i>dwMinimumWorkingSetSize</i> or <i>dwMaximumWorkingSetSize</i> are greater than the process' current working set sizes, the specified process must have the <b>SE_INC_WORKING_SET_NAME</b> privilege. All users generally have this privilege. For more information about security privileges, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privileges">Privileges</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The specified process must have the <b>SE_INC_BASE_PRIORITY_NAME</b> privilege. Users in the Administrators and Power Users groups generally have this privilege.</para>
      <para>The operating system allocates working set sizes on a first-come, first-served basis. For example, if an application successfully sets 40 megabytes as its minimum working set size on a 64-megabyte system, and a second application requests a 40-megabyte working set size, the operating system denies the second application's request.</para>
      <para>Using the <b>SetProcessWorkingSetSize</b> function to set an application's minimum and maximum working set sizes does not guarantee that the requested memory will be reserved, or that it will remain resident at all times. When the application is idle, or a low-memory situation causes a demand for memory, the operating system can reduce the application's working set. An application can use the <see cref="VirtualLock" />function to lock ranges of the application's virtual address space in memory; however, that can potentially degrade the performance of the system.</para>
      <para>When you increase the working set size of an application, you are taking away physical memory from the rest of the system. This can degrade the performance of other applications and the system as a whole. It can also lead to failures of operations that require physical memory to be present (for example, creating processes, threads, and kernel pool). Thus, you must use the
<b>SetProcessWorkingSetSize</b> function carefully. You must always consider the performance of the whole system when you are designing an application.</para>
    </remarks>
    <seealso cref="GetProcessWorkingSetSize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-working-set">Process Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="SetProcessWorkingSetSizeEx" />
    <seealso cref="VirtualLock" />
  </member>
  <member name="Windows.SetProcessWorkingSetSizeEx">
    <summary>
      <para>Sets the minimum and maximum working set sizes for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose working set sizes is to be set.</para>
      <para>The handle must have <b>PROCESS_SET_QUOTA</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwMinimumWorkingSetSize">
      <para>The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is active.</para>
      <para>This parameter must be greater than zero but less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800 bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum value is set to 20 pages.</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process.</para>
    </param>
    <param name="dwMaximumWorkingSetSize">
      <para>The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than this much memory resident in the process whenever the process is active and available memory is low.</para>
      <para>This parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for example, this is 1,413,120 bytes on systems with a 4K page size).</para>
      <para>If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified process. For details, see Remarks.</para>
    </param>
    <param name="Flags">
      <para>The flags that control the enforcement of the minimum and maximum working set sizes.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set may fall below the minimum working set limit if memory demands are high.</para>
            <para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set will not fall below the minimum working set limit.</para>
            <para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <i>The working set may exceed the maximum working set limit if there is abundant memory.</i>
            <para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The working set will not exceed the maximum working set limit.</para>
            <para>This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function is succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the function fails, the return value is zero. To get extended error information, call
<b>GetLastError</b>.</para>
    </returns>
    <remarks>
      <para>The working set of a process is the set of memory pages in the virtual address space of the process that are currently resident in physical memory. These pages are available for an application to use without triggering a page fault. For more information about page faults, see <a href="https://docs.microsoft.com//windows/desktop/Memory/working-set">Working Set</a>. The minimum and maximum working set sizes affect the virtual memory paging behavior of a process.</para>
      <para>The working set of the specified process can be emptied by specifying the value (<b>SIZE_T</b>)–1 for both the minimum and maximum working set sizes. This removes as many pages as possible from the working set. The <see cref="EmptyWorkingSet" /> function can also be used for this purpose.</para>
      <para>If the values of either <i>dwMinimumWorkingSetSize</i> or <i>dwMaximumWorkingSetSize</i> are greater than the process' current working set sizes, the specified process must have the <b>SE_INC_WORKING_SET_NAME</b> privilege. All users generally have this privilege. For more information about security privileges, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privileges">Privileges</a>.</para>
      <para>
        <b>Windows Server 2003:  </b>The specified process must have the <b>SE_INC_BASE_PRIORITY_NAME</b> privilege. Users in the Administrators and Power Users groups generally have this privilege.</para>
      <para>The operating system allocates working set sizes on a first-come, first-served basis. For example, if an application successfully sets 40 megabytes as its minimum working set size on a 64-megabyte system, and a second application requests a 40-megabyte working set size, the operating system denies the second application's request.</para>
      <para>By default, using the
<see cref="SetProcessWorkingSetSize" /> function to set an application's minimum and maximum working set sizes does not guarantee that the requested memory will be reserved, or that it will remain resident at all times. When an application is idle, or a low-memory situation causes a demand for memory, the operating system can reduce the application's working set below its minimum working set limit. If memory is abundant, the system might allow an application to exceed its maximum working set limit. The <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b> and <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b> flags enable you to ensure that limits are enforced.</para>
      <para>When you increase the working set size of an application, you are taking away physical memory from the rest of the system. This can degrade the performance of other applications and the system as a whole. It can also lead to failures of operations that require physical memory to be present (for example, creating processes, threads, and kernel pool). Thus, you must use the
<see cref="SetProcessWorkingSetSize" /> function carefully. You must always consider the performance of the whole system when you are designing an application.</para>
      <para>An application can use the
<see cref="VirtualLock" /> function to lock ranges of the application's virtual address space in memory; however, that can potentially degrade the performance of the system.</para>
    </remarks>
    <seealso cref="GetProcessWorkingSetSizeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-working-set">Process Working Set</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="VirtualLock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/working-set">Working Set</seealso>
  </member>
  <member name="Windows.SetSystemFileCacheSize">
    <summary>
      <para>Limits the size of the working set for the file system cache.</para>
    </summary>
    <param name="MinimumFileCacheSize">
      <para>The minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much memory resident in the system file cache.</para>
      <para>To flush the cache, specify <code>(SIZE_T) -1</code>.</para>
    </param>
    <param name="MaximumFileCacheSize">
      <para>The maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if this call or a previous call to <b>SetSystemFileCacheSize</b> specifies <b>FILE_CACHE_MAX_HARD_ENABLE</b>.</para>
      <para>To flush the cache, specify <code>(SIZE_T) -1</code>.</para>
    </param>
    <param name="Flags">
      <para>The flags that enable or disable the file cache limits. If this parameter is 0 (zero), the size limits retain the current setting, which is either disabled or enabled.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MAX_HARD_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Disable the maximum size limit.</para>
            <para>The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MAX_HARD_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enable the maximum size limit.</para>
            <para>The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MIN_HARD_DISABLE</b>
                </description>
              </item>
              <item>
                <description>0x8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Disable the minimum size limit.</para>
            <para>The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_CACHE_MIN_HARD_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enable the minimum size limit.</para>
            <para>The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The calling process must enable the <b>SE_INCREASE_QUOTA_NAME</b> privilege.</para>
      <para>Setting the <i>MaximumFileCacheSize</i> parameter to a very low value can adversely affect system performance.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>The <b>FILE_CACHE_*</b> constants will be defined in the Windows header files starting with the Windows SDK for Windows Server 2008. If you are using header files from an earlier version of the SDK, add the following definitions to your code.</para>
      <code>#ifndef FILE_CACHE_FLAGS_DEFINED

#define FILE_CACHE_MAX_HARD_ENABLE      0x00000001
#define FILE_CACHE_MAX_HARD_DISABLE     0x00000002
#define FILE_CACHE_MIN_HARD_ENABLE      0x00000004
#define FILE_CACHE_MIN_HARD_DISABLE     0x00000008

#endif // FILE_CACHE_FLAGS_DEFINED

</code>
    </remarks>
    <seealso cref="GetSystemFileCacheSize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.UnmapViewOfFile">
    <summary>
      <para>Unmaps a mapped view of a file from the calling process's address space.</para>
    </summary>
    <param name="lpBaseAddress">
      <para>A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the
<see cref="MapViewOfFile" /> or
<see cref="MapViewOfFileEx" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Unmapping a mapped view of a file invalidates the range occupied by the view in the address space of the process and makes the range available for other allocations. It removes the working set entry for each unmapped virtual page that was part of the working set of the process and reduces the working set size of the process. It also decrements the share count of the corresponding physical page.</para>
      <para>Modified pages in the unmapped view are not written to disk until their share count reaches zero, or in other words, until they are unmapped or trimmed from the working sets of all processes that share the pages. Even then, the modified pages are written "lazily" to disk; that is, modifications may be cached in memory and written to disk at a later time. To minimize the risk of data loss in the event of a power failure or a system crash, applications should explicitly flush modified pages using the <see cref="FlushViewOfFile" /> function.</para>
      <para>Although an application may close the file handle used to create a file mapping object, the system holds the corresponding file open until the last view of the file is unmapped.  Files for which the last view has not yet been unmapped are held open with no sharing restrictions.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-view-within-a-file">Creating a View Within a File</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/closing-a-file-mapping-object">Closing a File Mapping Object</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
  </member>
  <member name="Windows.UnmapViewOfFile2">
    <summary>
      <para>Unmaps a previously mapped view of a file or a
pagefile-backed section.</para>
    </summary>
    <param name="Process">
      <para>A <b>HANDLE</b> to the process from which the section
will be unmapped.</para>
    </param>
    <param name="BaseAddress">
      <para>The base address of a previously mapped
view that is to be unmapped.  This value must be
identical to the value returned by a previous call
to <see cref="MapViewOfFile2" />.</para>
    </param>
    <param name="UnmapFlags">
      <para>This parameter can be zero (0) or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the priority of the pages being unmapped should be temporarily boosted
(with automatic short term decay) because the caller expects that these pages will be accessed again shortly from another thread. For more information about memory priorities, see the <see cref="SetThreadInformation(ThreadMemoryPriority)" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Unmaps a mapped view back to a placeholder (after you've replaced a placeholder with a mapped view using <see cref="MapViewOfFile2" /> or <b>MapViewOfFile2FromApp</b>).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns <b>TRUE</b> if successful. Otherwise, returns <b>FALSE</b> and extended error status is available
using <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="MapViewOfFile2" />
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="UnmapViewOfFileEx" />
  </member>
  <member name="Windows.UnmapViewOfFileEx">
    <summary>
      <para>This is an extended version of <see cref="UnmapViewOfFile" /> that takes an additional flags parameter.</para>
    </summary>
    <param name="BaseAddress">
      <para>A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the
<see cref="MapViewOfFile" /> or
<see cref="MapViewOfFileEx" /> function.</para>
    </param>
    <param name="UnmapFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the priority of the pages being unmapped should be temporarily boosted
(with automatic short term decay) because the caller expects that these pages will be accessed again shortly from another thread. For more information about memory priorities, see the <see cref="SetThreadInformation(ThreadMemoryPriority)" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Unmaps a mapped view back to a placeholder (after you've replaced a placeholder with a mapped view using <see cref="MapViewOfFile2" /> or <b>MapViewOfFile2FromApp</b>).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information about the behavior of this function, see the <see cref="UnmapViewOfFile" /> function.</para>
    </remarks>
  </member>
  <member name="Windows.UnregisterBadMemoryNotification">
    <summary>
      <para>Closes the specified bad memory notification handle.</para>
    </summary>
    <param name="RegistrationHandle">
      <para>Registration handle returned from the
<see cref="RegisterBadMemoryNotification" /></para>
      <para>function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as
<b>_WIN32_WINNT_WIN8</b> or higher. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.VirtualAlloc">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of pages in the virtual address space of the calling process.
Memory allocated by this function is automatically initialized to zero.</para>
      <para>To allocate memory in the address space of another process, use the
<see cref="VirtualAllocEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>The starting address of the region to allocate. If the memory is being reserved, the specified address is
rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is
being committed, the address is rounded down to the next page boundary. To determine the size of a page and the
allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function. If this parameter is
<b>NULL</b>, the system determines where to allocate the region.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAlloc</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region, in bytes. If the <i>lpAddress</i> parameter is
<b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated
pages include all pages containing one or more bytes in the range from <i>lpAddress</i> to
<i>lpAddress</i>+<i>dwSize</i>. This means that a 2-byte range straddling
a page boundary causes both pages to be included in the allocated region.</para>
    </param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call
<b>VirtualAlloc</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The  resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is
already committed does not cause the function to fail. This means that you can commit pages without first
determining the current commitment state of each page.</para>
            <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You can commit reserved pages in subsequent calls to the
<b>VirtualAlloc</b> function. To reserve and commit pages
in one step, call <b>VirtualAlloc</b> with
<b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use a reserved range of memory
until it is released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>lpAddress</i> and
<i>dwSize</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you specify <b>MEM_RESET</b>, the
<b>VirtualAlloc</b> function ignores the value of
<i>flProtect</i>. However, you must still set <i>flProtect</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>
              <b>VirtualAlloc</b> returns an error if you use
<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only
acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>lpAddress</i> and <i>dwSize</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>VirtualAlloc</b> function ignores the value of
<i>flProtect</i>. However, you must still set <i>flProtect</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and
Windows Server 2012.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address. This can be slower than regular allocations, especially
when there are many allocations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_WRITE_WATCH</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes the system to track pages that are written to in the allocated region. If you specify this value,
you must also specify <b>MEM_RESERVE</b>.</para>
            <para>To retrieve the addresses of the pages that have been written to since the region was allocated or the
write-tracking state was reset, call the
<see cref="GetWriteWatch" /> function. To reset the write-tracking
state, call <b>GetWriteWatch</b> or
<see cref="ResetWriteWatch" />. The write-tracking feature
remains enabled for the memory region until the region is freed.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify any one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flProtect</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>VirtualAlloc</b> function can perform the following
operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <b>VirtualAlloc</b> cannot reserve a reserved page. It can
commit a page that is already committed. This means you can commit a range of pages, regardless of whether they
have already been committed, and the function will not fail.
<para>You can use <b>VirtualAlloc</b> to reserve a block of pages
and then make additional calls to <b>VirtualAlloc</b> to commit
individual pages from the reserved block. This enables a process to reserve a range of its virtual address space
without consuming physical storage until it is needed.</para><para>If the <i>lpAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>lpAddress</i> and <i>dwSize</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>flAllocationType</i> parameter. Otherwise, the function fails
and none of the pages are allocated. This compatibility requirement does not preclude committing an already
committed page, as mentioned previously.</para><para>To execute dynamically generated code, use
<b>VirtualAlloc</b> to allocate memory and the
<see cref="VirtualProtect" /> function to grant
<b>PAGE_EXECUTE</b> access.</para><para>The <b>VirtualAlloc</b> function can be used to reserve an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
region of memory within the virtual address space of a specified process. This region of memory can then be used
to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para><para>The <see cref="VirtualFree" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para><para>When creating a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para><h4>Examples</h4><para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reserving-and-committing-memory">Reserving and Committing Memory</a>.</para></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocEx" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.VirtualAlloc2">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of memory within the virtual address space of a specified process. The
function initializes the memory it allocates to zero.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="Process">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information,
see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="BaseAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If an explicit base address is specified, then it must be a multiple of the system allocation granularity. To determine the size of a page and the allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>BaseAddress</i> is <b>NULL</b>, the function determines where to
allocate the region.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAlloc2</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
    </param>
    <param name="Size">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>The size must always be a multiple of the page size.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all
pages that contain one or more bytes in the range from <i>BaseAddress</i> to
<i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte
range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call
<b>VirtualAlloc2</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is already committed does not cause the function to fail. This means that
you can commit pages without first determining the current commitment state of each page.</para>
            <para>If <i>BaseAddress</i> specifies an address within an enclave, <i>AllocationType</i> must be <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You commit reserved pages by calling
<b>VirtualAlloc2</b> again with
<b>MEM_COMMIT</b>. To reserve and commit pages in one step, call
<b>VirtualAlloc2</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use reserved memory until it has
been released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Replaces a placeholder with a normal private allocation. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i> must exactly match those of the placeholder.</para>
            <para>After you replace a placeholder with a private allocation, to free that allocation back to a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>To create a placeholder, call
<b>VirtualAlloc2</b> with
<code>MEM_RESERVE | MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To free/split/coalesce a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>BaseAddress</i> and
<i>Size</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you use <b>MEM_RESET</b>, the
<b>VirtualAlloc2</b> function ignores the value of
<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid
protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>
              <b>VirtualAlloc2</b> returns an error if you use
<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only
acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>BaseAddress</i> and <i>Size</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>VirtualAlloc2</b> function ignores the value of
<i>PageProtection</i>. However, you must still set <i>PageProtection</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and
Windows Server 2012.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address. This can be slower than regular allocations, especially
when there are many allocations.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify any one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>BaseAddress</i> specifies an address within an enclave, <i>PageProtection</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
    </param>
    <param name="ExtendedParameters">
      <para>An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</para>
    </param>
    <param name="ParameterCount">
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This API provides specialized techniques for managing virtual memory in support of high-performance games and server applications. For example, placeholders allow a reserved memory range to be explicitly partitioned, overlaid, and re-mapped; this can be used to implement arbitrarily extendable regions or virtual memory ring buffers. <b>VirtualAlloc2</b> also allows for allocating memory with a specific memory-alignment.</para>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>VirtualAlloc2</b> function can perform the following
operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <para>
        <b>VirtualAlloc2</b> can commit pages that are already committed, but cannot reserve pages that are already reserved.
This means you can commit a range of pages, regardless of whether they have already been committed, and the function will not
fail. In general however, only a minimal range of mostly uncommitted pages should be specified, because committing
a large number of pages that are already committed can cause the <b>VirtualAlloc2</b> call to take much longer.</para>
      <para>You can use <b>VirtualAlloc2</b> to reserve a block of pages and then make additional calls to <b>VirtualAlloc2</b> to
commit individual pages from the reserved block. This enables a process to reserve a range of its virtual address
space without consuming physical storage until it is needed.</para>
      <para>If the <i>lpAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>lpAddress</i> and <i>dwSize</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>flAllocationType</i> parameter. Otherwise, the function fails
and none of the pages is allocated. This compatibility requirement does not preclude committing an already
committed page; see the preceding list.</para>
      <para>To execute dynamically generated code, use
<b>VirtualAlloc2</b> to allocate memory, and the
<see cref="VirtualProtectEx" /> function to grant
<b>PAGE_EXECUTE</b> access.</para>
      <para>The <b>VirtualAlloc2</b> function can be used to reserve
an <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a></para>
      <para>(AWE) region of memory within the virtual address space of a specified process. This region of memory can then be
used to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para>
      <para>The <see cref="VirtualFreeEx" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para>
      <para>When creating a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para>
      <h4>Examples</h4>
      <para>Scenario 1. Create a circular buffer by mapping two adjacent views of the same shared memory section.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//
// This function creates a ring buffer by allocating a pagefile-backed section
// and mapping two views of that section next to each other. This way if the
// last record in the buffer wraps it can still be accessed in a linear fashion
// using its base VA.
//

void*
CreateRingBuffer (
    unsigned int bufferSize,
    _Outptr_ void** secondaryView
    )
{
    BOOL result;
    HANDLE section = nullptr;
    SYSTEM_INFO sysInfo;
    void* ringBuffer = nullptr;
    void* placeholder1 = nullptr;
    void* placeholder2 = nullptr;
    void* view1 = nullptr;
    void* view2 = nullptr;

    GetSystemInfo (&amp;amp;amp;amp;amp;amp;sysInfo);

    if ((bufferSize % sysInfo.dwAllocationGranularity) != 0) {
        return nullptr;
    }

    //
    // Reserve a placeholder region where the buffer will be mapped.
    //

    placeholder1 = (PCHAR) VirtualAlloc2 (
        nullptr,
        nullptr,
        2 * bufferSize,
        MEM_RESERVE | MEM_RESERVE_PLACEHOLDER,
        PAGE_NOACCESS,
        nullptr, 0
    );

    if (placeholder1 == nullptr) {
        printf ("VirtualAlloc2 failed, error %#x\n", GetLastError());
        goto Exit;
    }

    //
    // Split the placeholder region into two regions of equal size.
    //

    result = VirtualFree (
        placeholder1,
        bufferSize,
        MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER
    );

    if (result == FALSE) {
        printf ("VirtualFreeEx failed, error %#x\n", GetLastError());
        goto Exit;
    }

    placeholder2 = (void*) ((ULONG_PTR) placeholder1 + bufferSize);

    //
    // Create a pagefile-backed section for the buffer.
    //

    section = CreateFileMapping (
        INVALID_HANDLE_VALUE,
        nullptr,
        PAGE_READWRITE,
        0,
        bufferSize, nullptr
    );

    if (section == nullptr) {
        printf ("CreateFileMapping failed, error %#x\n", GetLastError());
        goto Exit;
    }

    //
    // Map the section into the first placeholder region.
    //

    view1 = MapViewOfFile3 (
        section,
        nullptr,
        placeholder1,
        0,
        bufferSize,
        MEM_REPLACE_PLACEHOLDER,
        PAGE_READWRITE,
        nullptr, 0
    );

    if (view1 == nullptr) {
        printf ("MapViewOfFile3 failed, error %#x\n", GetLastError());
        goto Exit;
    }

    //
    // Ownership transferred, don’t free this now.
    //

    placeholder1 = nullptr;

    //
    // Map the section into the second placeholder region.
    //

    view2 = MapViewOfFile3 (
        section,
        nullptr,
        placeholder2,
        0,
        bufferSize,
        MEM_REPLACE_PLACEHOLDER,
        PAGE_READWRITE,
        nullptr, 0
    );

    if (view2 == nullptr) {
        printf ("MapViewOfFile3 failed, error %#x\n", GetLastError());
        goto Exit;
    }

    //
    // Success, return both mapped views to the caller.
    //

    ringBuffer = view1;
    *secondaryView = view2;

    placeholder2 = nullptr;
    view1 = nullptr;
    view2 = nullptr;

Exit:

    if (section != nullptr) {
        CloseHandle (section);
    }

    if (placeholder1 != nullptr) {
        VirtualFree (placeholder1, 0, MEM_RELEASE);
    }

    if (placeholder2 != nullptr) {
        VirtualFree (placeholder2, 0, MEM_RELEASE);
    }

    if (view1 != nullptr) {
        UnmapViewOfFileEx (view1, 0);
    }

    if (view2 != nullptr) {
        UnmapViewOfFileEx (view2, 0);
    }

    return ringBuffer;
}

int __cdecl wmain()
{
    char* ringBuffer;
    void* secondaryView;
    unsigned int bufferSize = 0x10000;

    ringBuffer = (char*) CreateRingBuffer (bufferSize, &amp;amp;amp;amp;amp;amp;secondaryView);

    if (ringBuffer == nullptr) {
        printf ("CreateRingBuffer failed\n");
        return 0;
    }

    //
    // Make sure the buffer wraps properly.
    //

    ringBuffer[0] = 'a';

    if (ringBuffer[bufferSize] == 'a') {
        printf ("The buffer wraps as expected\n");
    }

    UnmapViewOfFile (ringBuffer);
    UnmapViewOfFile (secondaryView);
}

</code>
      <para>Scenario 2. Specify a preferred NUMA node when allocating memory.</para>
      <code>
void*
AllocateWithPreferredNode (size_t size, unsigned int numaNode)
{
    MEM_EXTENDED_PARAMETER param = {0};

    param.Type = MemExtendedParameterNumaNode;
    param.ULong = numaNode;

    return VirtualAlloc2 (
        nullptr, nullptr,
        size,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE,
        &amp;amp;amp;amp;amp;amp;param, 1);
}

</code>
      <para>Scenario 3. Allocate memory in a specific virtual address range (below 4GB, in this example) and with specific alignment.</para>
      <code>
void*
AllocateAlignedBelow2GB (size_t size, size_t alignment)
{
    MEM_ADDRESS_REQUIREMENTS addressReqs = {0};
    MEM_EXTENDED_PARAMETER param = {0};

    addressReqs.Alignment = alignment;
    addressReqs.HighestEndingAddress = (PVOID)(ULONG_PTR) 0x7fffffff;

    param.Type = MemExtendedParameterAddressRequirements;
    param.Pointer = &amp;amp;amp;amp;amp;amp;addressReqs;

    return VirtualAlloc2 (
        nullptr, nullptr,
        size,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE,
        &amp;amp;amp;amp;amp;amp;param, 1);
}

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="ReadProcessMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="VirtualFreeEx" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualQuery" />
    <seealso cref="WriteProcessMemory" />
  </member>
  <member name="Windows.VirtualAlloc2FromApp">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of pages in the virtual address space of the calling process.
Memory allocated by this function is automatically initialized to zero.</para>
      <para>Using this function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a placeholder operation (specifically, replacement).</para>
      <para>To specify the NUMA node, see the <i>ExtendedParameters</i> parameter.</para>
    </summary>
    <param name="Process">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information,
see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="BaseAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If an explicit base address is specified, then it must be a multiple of the system allocation granularity. To determine the size of a page and the allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>BaseAddress</i> is <b>NULL</b>, the function determines where to
allocate the region.</para>
    </param>
    <param name="Size">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>The size must always be a multiple of the page size.</para>
      <para>If <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all
pages that contain one or more bytes in the range from <i>BaseAddress</i> to
<i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte
range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call
<b>Virtual2AllocFromApp</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The  resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is
already committed does not cause the function to fail. This means that you can commit pages without first
determining the current commitment state of each page.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You can commit reserved pages in subsequent calls to the
<b>Virtual2AllocFromApp</b> function. To reserve and commit pages
in one step, call <b>Virtual2AllocFromApp</b> with
<b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use a reserved range of memory
until it is released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_REPLACE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Replaces a placeholder with a normal private allocation. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i> must exactly match those of the placeholder.</para>
            <para>After you replace a placeholder with a private allocation, to free that allocation back to a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00040000</description>
              </item>
            </list>
          </description>
          <description>
            <para>To create a placeholder, call
<see cref="VirtualAlloc2" /> with
<code>MEM_RESERVE | MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To free/split/coalesce a placeholder, see the <i>dwFreeType</i> parameter of <see cref="VirtualFree" /> and <see cref="VirtualFreeEx" />.</para>
            <para>A placeholder is a type of reserved memory region.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>BaseAddress</i> and
<i>Size</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you specify <b>MEM_RESET</b>, the
<b>Virtual2AllocFromApp</b> function ignores the value of
<i>Protection</i>. However, you must still set <i>Protection</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>
              <b>Virtual2AllocFromApp</b> returns an error if you use
<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only
acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>BaseAddress</i> and <i>Size</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>Virtual2AllocFromApp</b> function ignores the value of
<i>Protection</i>. However, you must still set <i>Protection</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address. This can be slower than regular allocations, especially
when there are many allocations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_WRITE_WATCH</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes the system to track pages that are written to in the allocated region. If you specify this value,
you must also specify <b>MEM_RESERVE</b>.</para>
            <para>To retrieve the addresses of the pages that have been written to since the region was allocated or the
write-tracking state was reset, call the
<see cref="GetWriteWatch" /> function. To reset the write-tracking
state, call <b>GetWriteWatch</b> or
<see cref="ResetWriteWatch" />. The write-tracking feature
remains enabled for the memory region until the region is freed.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="PageProtection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>. The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READ</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>
    </param>
    <param name="ExtendedParameters">
      <para>An optional pointer to one or more extended parameters of type <see cref="MEM_EXTENDED_PARAMETER" />. Each of those extended parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided, then the behavior is the same as for the <see cref="VirtualAlloc" />/<see cref="MapViewOfFile" /> functions (that is, the preferred NUMA node for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).</para>
    </param>
    <param name="ParameterCount">
      <para>The number of extended parameters pointed to by <i>ExtendedParameters</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This API helps support high-performance games, and server applications, which have particular requirements around managing their virtual address space. For example, mapping memory on top of a previously reserved region; this is useful for implementing an automatically wrapping ring buffer. And allocating memory with specific alignment; for example, to enable your application to commit large/huge page-mapped regions on demand.</para>
      <para>You can call <b>Virtual2AllocFromApp</b> from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the <b>codeGeneration</b> capability in the app manifest file to use JIT capabilities.</para>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>Virtual2AllocFromApp</b> function can perform the following
operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <b>Virtual2AllocFromApp</b> cannot reserve a reserved page. It can
commit a page that is already committed. This means you can commit a range of pages, regardless of whether they
have already been committed, and the function will not fail.
<para>You can use <b>Virtual2AllocFromApp</b> to reserve a block of pages
and then make additional calls to <b>Virtual2AllocFromApp</b> to commit
individual pages from the reserved block. This enables a process to reserve a range of its virtual address space
without consuming physical storage until it is needed.</para><para>If the <i>BaseAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>BaseAddress</i> and <i>Size</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>AllocationType</i> parameter. Otherwise, the function fails
and none of the pages are allocated. This compatibility requirement does not preclude committing an already
committed page, as mentioned previously.</para><para><b>Virtual2AllocFromApp</b> does not allow the creation of executable pages.</para><para>The <b>Virtual2AllocFromApp</b> function can be used to reserve an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
region of memory within the virtual address space of a specified process. This region of memory can then be used
to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para><para>The <see cref="VirtualFree" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para><para>When creating a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para><h4>Examples</h4><para>For code examples, see <a href="https://msdn.microsoft.com/en-us/library/mt832849(v=vs.85).aspx">Virtual2Alloc</a>.</para></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualAllocEx" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtectFromApp" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.VirtualAllocEx">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of memory within the virtual address space of a specified process. The
function initializes the memory it allocates to zero.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="VirtualAllocExNuma" />.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information,
see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation
granularity.</para>
      <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest
page boundary. To determine the size of a page and the allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to
allocate the region.</para>
      <para>If this address is within an enclave that you have not initialized by calling <see cref="InitializeEnclave" />, <b>VirtualAllocEx</b> allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</para>
      <para>If the address in within an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to allocate, in bytes.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds
<i>dwSize</i> up to the next page boundary.</para>
      <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all
pages that contain one or more bytes in the range from <i>lpAddress</i> to
<i>lpAddress</i>+<i>dwSize</i>. This means, for example, that a 2-byte
range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call
<b>VirtualAllocEx</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is already committed does not cause the function to fail. This means that
you can commit pages without first determining the current commitment state of each page.</para>
            <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You commit reserved pages by calling
<b>VirtualAllocEx</b> again with
<b>MEM_COMMIT</b>. To reserve and commit pages in one step, call
<b>VirtualAllocEx</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use reserved memory until it has
been released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>lpAddress</i> and
<i>dwSize</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you use <b>MEM_RESET</b>, the
<b>VirtualAllocEx</b> function ignores the value of
<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid
protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>
              <b>VirtualAllocEx</b> returns an error if you use
<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only
acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>lpAddress</i> and <i>dwSize</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>VirtualAllocEx</b> function ignores the value of
<i>flProtect</i>. However, you must still set <i>flProtect</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and
Windows Server 2012.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address. This can be slower than regular allocations, especially
when there are many allocations.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify any one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>If <i>lpAddress</i> specifies an address within an enclave, <i>flProtect</i> cannot be any of the following values:</para>
      <list type="bullet">
        <item>
          <description>PAGE_NOACCESS</description>
        </item>
        <item>
          <description>PAGE_GUARD</description>
        </item>
        <item>
          <description>PAGE_NOCACHE</description>
        </item>
        <item>
          <description>PAGE_WRITECOMBINE</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>VirtualAllocEx</b> function can perform the following
operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <b>VirtualAllocEx</b> cannot reserve a reserved page. It
can commit a page that is already committed. This means you can commit a range of pages, regardless of whether
they have already been committed, and the function will not fail.
<para>You can use <b>VirtualAllocEx</b> to reserve a block of
pages and then make additional calls to <b>VirtualAllocEx</b></para><para>to commit individual pages from the reserved block. This enables a process to reserve a range of its virtual
address space without consuming physical storage until it is needed.</para><para>If the <i>lpAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>lpAddress</i> and <i>dwSize</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>flAllocationType</i> parameter. Otherwise, the function fails
and none of the pages is allocated. This compatibility requirement does not preclude committing an already
committed page; see the preceding list.</para><para>To execute dynamically generated code, use
<b>VirtualAllocEx</b> to allocate memory and the
<see cref="VirtualProtectEx" /> function to grant
<b>PAGE_EXECUTE</b> access.</para><para>The <b>VirtualAllocEx</b> function can be used to reserve
an <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a></para><para>(AWE) region of memory within the virtual address space of a specified process. This region of memory can then be
used to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para><para>The <see cref="VirtualFreeEx" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para><para>When creating a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="ReadProcessMemory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="VirtualFreeEx" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualQuery" />
    <seealso cref="WriteProcessMemory" />
  </member>
  <member name="Windows.VirtualAllocExNuma">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of memory within the virtual address space of the specified process, and
specifies the NUMA node for the physical memory.</para>
    </summary>
    <param name="hProcess">
      <para>The handle to a process. The function allocates memory within the virtual address space of this process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information,
see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</para>
      <para>If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation
granularity.</para>
      <para>If you are committing memory that is already reserved, the function rounds this address down to the nearest
page boundary. To determine the size of a page and the allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function determines where to
allocate the region.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to be allocated, in bytes.</para>
      <para>If <i>lpAddress</i> is <b>NULL</b>, the function rounds
<i>dwSize</i> up to the next page boundary.</para>
      <para>If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all
pages that contain one or more bytes in the range from <i>lpAddress</i> to
<code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte
range that straddles a page boundary causes the function to allocate both pages.</para>
    </param>
    <param name="flAllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call the function with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>lpAddress</i> fails unless the entire range has already been reserved. The resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is already committed does not cause the function to fail. This means that
you can commit pages without first determining the current commitment state of each page.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You commit reserved pages by calling the function again with <b>MEM_COMMIT</b>. To
reserve and commit pages in one step, call the function with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use reserved memory until it has
been released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>lpAddress</i> and
<i>dwSize</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you use <b>MEM_RESET</b>, the function ignores the value of
<i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid
protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>The function returns an error if you use <b>MEM_RESET</b> and the range of memory is
mapped to a file. A shared view is only acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>lpAddress</i> and <i>dwSize</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>VirtualAllocExNuma</b> function ignores the value of
<i>flProtect</i>. However, you must still set <i>flProtect</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and
Windows Server 2012.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="flProtect">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify any one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>Protection attributes specified when protecting a page cannot conflict with those specified when allocating
a page.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <para>Used only when allocating a new VA region (either committed or reserved). Otherwise this parameter is ignored
when the API is used to commit pages in a region that already exists</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>VirtualAllocExNuma</b> function can perform the
following operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <para>
        <b>VirtualAllocExNuma</b> cannot reserve a reserved
page. It can commit a page that is already committed. This means you can commit a range of pages, regardless of
whether they have already been committed, and the function will not fail.</para>
      <para>You can use <b>VirtualAllocExNuma</b> to reserve a
block of pages and then make additional calls to
<b>VirtualAllocExNuma</b> to commit individual pages from
the reserved block. This enables a process to reserve a range of its virtual address space without consuming
physical storage until it is needed.</para>
      <para>If the <i>lpAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>lpAddress</i> and <i>dwSize</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>flAllocationType</i> parameter. Otherwise, the function fails
and none of the pages is allocated. This compatibility requirement does not preclude committing an already
committed page; see the preceding list.</para>
      <para>Because <b>VirtualAllocExNuma</b> does not allocate any
physical pages, it will succeed whether or not the pages are available on that node or elsewhere in the system.
The physical pages are allocated on demand. If the preferred node runs out of pages, the memory manager will use
pages from other nodes. If the memory is paged out, the same process is used when it is brought back in.</para>
      <para>To execute dynamically generated code, use
<b>VirtualAllocExNuma</b> to allocate memory and the
<see cref="VirtualProtectEx" /> function to grant
<b>PAGE_EXECUTE</b> access.</para>
      <para>The <b>VirtualAllocExNuma</b> function can be used to
reserve an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a></para>
      <para>(AWE) region of memory within the virtual address space of a specified process. This region of memory can then be
used to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para>
      <para>The <see cref="VirtualFreeEx" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600
or later.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/allocating-memory-from-a-numa-node">Allocating Memory from a NUMA Node</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocEx" />
    <seealso cref="VirtualFreeEx" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.VirtualAllocFromApp">
    <summary>
      <para>Reserves, commits, or changes the state  of a region of pages in the virtual address space of the calling process.
Memory allocated by this function is automatically initialized to zero.</para>
    </summary>
    <param name="BaseAddress">
      <para>The starting address of the region to allocate. If the memory is being reserved, the specified address is
rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is
being committed, the address is rounded down to the next page boundary. To determine the size of a page and the
allocation granularity on the host computer, use the
<see cref="GetSystemInfo" /> function. If this parameter is
<b>NULL</b>, the system determines where to allocate the region.</para>
    </param>
    <param name="Size">
      <para>The size of the region, in bytes. If the <i>BaseAddress</i> parameter is
<b>NULL</b>, this value is rounded up to the next page boundary. Otherwise, the allocated
pages include all pages containing one or more bytes in the range from <i>BaseAddress</i> to
<i>BaseAddress</i>+<i>Size</i>. This means that a 2-byte range straddling
a page boundary causes both pages to be included in the allocated region.</para>
    </param>
    <param name="AllocationType">
      <para>The type of memory allocation. This parameter must contain one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified
reserved memory pages. The function also guarantees that when the caller later initially accesses the memory,
the contents will be zero.  Actual physical pages are not allocated unless/until the virtual addresses are
actually accessed.</para>
            <para>To reserve and commit pages in one step, call
<b>VirtualAllocFromApp</b> with
<code>MEM_COMMIT | MEM_RESERVE</code>.</para>
            <para>Attempting to commit a specific address range by specifying <b>MEM_COMMIT</b> without
<b>MEM_RESERVE</b> and a non-<b>NULL</b><i>BaseAddress</i> fails unless the entire range has already been reserved. The  resulting
error code is <b>ERROR_INVALID_ADDRESS</b>.</para>
            <para>An attempt to commit a page that is
already committed does not cause the function to fail. This means that you can commit pages without first
determining the current commitment state of each page.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves a range of the process's virtual address space without allocating any actual physical storage in
memory or in the paging file on disk.</para>
            <para>You can commit reserved pages in subsequent calls to the
<b>VirtualAllocFromApp</b> function. To reserve and commit pages
in one step, call <b>VirtualAllocFromApp</b> with
<b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>.</para>
            <para>Other memory allocation functions, such as <b>malloc</b> and
<see cref="LocalAlloc" />, cannot use a reserved range of memory
until it is released.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that data in the memory range specified by <i>BaseAddress</i> and
<i>Size</i> is no longer of interest. The pages should not be read from or written to
the paging file. However, the memory block will be used again later, so it should not be decommitted. This
value cannot be used with any other value.</para>
            <para>Using this value does not guarantee that the range operated on with <b>MEM_RESET</b></para>
            <para>will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it.</para>
            <para>When you specify <b>MEM_RESET</b>, the
<b>VirtualAllocFromApp</b> function ignores the value of
<i>Protection</i>. However, you must still set <i>Protection</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para>
            <para>
              <b>VirtualAllocFromApp</b> returns an error if you use
<b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only
acceptable if it is mapped to a paging file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RESET_UNDO</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <b>MEM_RESET_UNDO</b> should only be called on an address range to which
<b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the
specified memory range specified by <i>BaseAddress</i> and <i>Size</i><para>is of interest to the caller and attempts to reverse the effects of <b>MEM_RESET</b>. If
the function succeeds, that means all data in the specified address range is intact. If the function fails,
at least some of the data in the address range has been replaced with zeroes.</para><para>This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you
specify <b>MEM_RESET</b>, the
<b>VirtualAllocFromApp</b> function ignores the value of
<i>Protection</i>. However, you must still set <i>Protection</i> to a
valid protection value, such as <b>PAGE_NOACCESS</b>.</para></description>
        </item>
      </list>
      <para>This parameter can also specify the following values as indicated.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>.</para>
            <para>The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
<see cref="GetLargePageMinimum" /> function.</para>
            <para>If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PHYSICAL</b>
                </description>
              </item>
              <item>
                <description>0x00400000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves an address range that can be used to map
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
pages.</para>
            <para>This value must be used with <b>MEM_RESERVE</b> and no other values.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_TOP_DOWN</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates memory at the highest possible address. This can be slower than regular allocations, especially
when there are many allocations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_WRITE_WATCH</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes the system to track pages that are written to in the allocated region. If you specify this value,
you must also specify <b>MEM_RESERVE</b>.</para>
            <para>To retrieve the addresses of the pages that have been written to since the region was allocated or the
write-tracking state was reset, call the
<see cref="GetWriteWatch" /> function. To reset the write-tracking
state, call <b>GetWriteWatch</b> or
<see cref="ResetWriteWatch" />. The write-tracking feature
remains enabled for the memory region until the region is freed.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Protection">
      <para>The memory protection for the region of pages to be allocated. If the pages are being committed, you can
specify one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>. The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READ</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the base address of the allocated region of pages.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can call <b>VirtualAllocFromApp</b> from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the <b>codeGeneration</b> capability in the app manifest file to use JIT capabilities.</para>
      <para>Each page has an associated <a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">page state</a>. The
<b>VirtualAllocFromApp</b> function can perform the following
operations:</para>
      <list type="bullet">
        <item>
          <description>Commit a region of reserved pages</description>
        </item>
        <item>
          <description>Reserve a region of free pages</description>
        </item>
        <item>
          <description>Simultaneously reserve and commit a region of free pages</description>
        </item>
      </list>
      <b>VirtualAllocFromApp</b> cannot reserve a reserved page. It can
commit a page that is already committed. This means you can commit a range of pages, regardless of whether they
have already been committed, and the function will not fail.
<para>You can use <b>VirtualAllocFromApp</b> to reserve a block of pages
and then make additional calls to <b>VirtualAllocFromApp</b> to commit
individual pages from the reserved block. This enables a process to reserve a range of its virtual address space
without consuming physical storage until it is needed.</para><para>If the <i>BaseAddress</i> parameter is not <b>NULL</b>, the function uses
the <i>BaseAddress</i> and <i>Size</i> parameters to compute the region of
pages to be allocated. The current state of the entire range of pages must be compatible with the type of
allocation specified by the <i>AllocationType</i> parameter. Otherwise, the function fails
and none of the pages are allocated. This compatibility requirement does not preclude committing an already
committed page, as mentioned previously.</para><para><b>VirtualAllocFromApp</b> does not allow the creation of executable pages.</para><para>The <b>VirtualAllocFromApp</b> function can be used to reserve an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE)
region of memory within the virtual address space of a specified process. This region of memory can then be used
to map physical pages into and out of virtual memory as required by the application. The
<b>MEM_PHYSICAL</b> and <b>MEM_RESERVE</b> values must be set in the
<i>AllocationType</i> parameter. The <b>MEM_COMMIT</b> value must not be
set. The page protection must be set to <b>PAGE_READWRITE</b>.</para><para>The <see cref="VirtualFree" /> function can decommit a committed
page, releasing the page's storage, or it can simultaneously decommit and release a committed page. It can also
release a reserved page, making it a free page.</para><para>When creating a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualAllocEx" />
    <seealso cref="VirtualFree" />
    <seealso cref="VirtualLock" />
    <seealso cref="VirtualProtectFromApp" />
    <seealso cref="VirtualQuery" />
  </member>
  <member name="Windows.VirtualFree">
    <summary>
      <para>Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.</para>
      <para>To free memory allocated in another process by the
<see cref="VirtualAllocEx" /> function, use the
<see cref="VirtualFreeEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be freed.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be the base address returned by the
<see cref="VirtualAlloc" /> function when the region of pages is reserved.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to be freed, in bytes.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to
<see cref="VirtualAlloc" />.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by
<see cref="VirtualAlloc" /> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by
<b>VirtualAlloc</b>. After that, the entire region is in the reserved state.</para>
    </param>
    <param name="dwFreeType">
      <para>The type of free operation. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_DECOMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.</para>
            <para>The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state.</para>
            <para>The <b>MEM_DECOMMIT</b> value is not supported when the <i>lpAddress</i> parameter provides the base address for an enclave.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RELEASE</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After this operation, the pages are in the free state.</para>
            <para>If you specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned by the
<see cref="VirtualAlloc" /> function when the region is reserved. The function fails if either of these conditions is not met.</para>
            <para>If any pages in the region are committed currently, the function first decommits, and then releases them.</para>
            <para>The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state.</para>
          </description>
        </item>
      </list>
      <para>When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COALESCE_PLACEHOLDERS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>To coalesce two adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match those of the placeholder.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using <see cref="VirtualAlloc2" /> or <a href="https://msdn.microsoft.com/en-us/library/mt832850(v=vs.85).aspx">Virtual2AllocFromApp</a>).</para>
            <para>To split a placeholder into two placeholders, specify <code>MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER</code>.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each page of memory in a process virtual address space has a
<a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">Page State</a>. The
<b>VirtualFree</b> function can decommit a range of pages that are in different states, some committed and some uncommitted. This means that you can decommit a range of pages without first determining the current commitment state of each page. Decommitting a page releases its physical storage, either in memory or in the paging file on disk.</para>
      <para>If a page is decommitted but not released, its state changes to reserved. Subsequently, you can call
<see cref="VirtualAlloc" /> to commit it, or <b>VirtualFree</b> to release it. Attempts to read from or write to a reserved page results in an access violation exception.</para>
      <para>The
<b>VirtualFree</b> function can release a range of pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state of each page. The entire range of pages originally reserved by the
<see cref="VirtualAlloc" /> function must be released at the same time.</para>
      <para>If a page is released, its state changes to free, and it is available for subsequent allocation operations. After memory is released or decommited, you can never refer to the memory again. Any information that may have been in that memory is gone forever. Attempting to read from or write to a free page results in an access violation exception. If you need to keep information, do not decommit or free memory that contains the information.</para>
      <para>The
<b>VirtualFree</b> function can be used on an AWE region of memory, and it invalidates any physical page mappings in the region when freeing the address space. However, the physical page is not deleted, and the application can use them. The application must explicitly call
<see cref="FreeUserPhysicalPages" /> to free the physical pages. When the process is terminated, all resources are cleaned up automatically.</para>
      <para>To delete an enclave when you finish using it, specify the following values:</para>
      <list type="bullet">
        <item>
          <description>The base address of the enclave for the <i>lpAddress</i> parameter.</description>
        </item>
        <item>
          <description>0 for the <i>dwSize</i> parameter.</description>
        </item>
        <item>
          <description>
            <b>MEM_RELEASE</b> for the <i>dwFreeType</i> parameter. The <b>MEM_DECOMMIT</b> value is not supported for enclaves.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reserving-and-committing-memory">Reserving and Committing Memory</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualFreeEx" />
  </member>
  <member name="Windows.VirtualFreeEx">
    <summary>
      <para>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to a process. The function frees memory within the virtual address space of the process.</para>
      <para>The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>A pointer to the starting address of the region of memory to be freed.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>lpAddress</i> must be the base address returned by the
<see cref="VirtualAllocEx" /> function when the region is reserved.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region of memory to free, in bytes.</para>
      <para>If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>, <i>dwSize</i> must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to
<see cref="VirtualAllocEx" />.</para>
      <para>If <i>dwFreeType</i> is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by
<see cref="VirtualAllocEx" /> and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by
<b>VirtualAllocEx</b>. After that, the entire region is in the reserved state.</para>
    </param>
    <param name="dwFreeType">
      <para>The type of free operation. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_DECOMMIT</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.</para>
            <para>The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state.</para>
            <para>The <b>MEM_DECOMMIT</b> value is not supported when the <i>lpAddress</i> parameter provides the base address for an enclave.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_RELEASE</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After this operation, the pages are in the free state.</para>
            <para>If you specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned by the
<see cref="VirtualAlloc" /> function when the region is reserved. The function fails if either of these conditions is not met.</para>
            <para>If any pages in the region are committed currently, the function first decommits, and then releases them.</para>
            <para>The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state.</para>
          </description>
        </item>
      </list>
      <para>When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_COALESCE_PLACEHOLDERS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>To coalesce two adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match those of the placeholder.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MEM_PRESERVE_PLACEHOLDER</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using <see cref="VirtualAlloc2" /> or <a href="https://msdn.microsoft.com/en-us/library/mt832850(v=vs.85).aspx">Virtual2AllocFromApp</a>).</para>
            <para>To split a placeholder into two placeholders, specify <code>MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER</code>.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each page of memory in a process virtual address space has a
<a href="https://docs.microsoft.com//windows/desktop/Memory/page-state">Page State</a>.  The
<b>VirtualFreeEx</b> function can decommit a range of pages that are in different states, some committed and some uncommitted. This means that you can decommit a range of pages without first determining the current commitment state of each page. Decommitting a page releases its physical storage, either in memory or in the paging file on disk.</para>
      <para>If a page is decommitted but not released, its state changes to reserved. Subsequently, you can  call
<see cref="VirtualAllocEx" /> to commit it, or
<b>VirtualFreeEx</b> to release it. Attempting to read from or write to a reserved page results in an access violation exception.</para>
      <para>The
<b>VirtualFreeEx</b> function can release a range of pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state of each page. The entire range of pages originally reserved by
<see cref="VirtualAllocEx" /> must be released at the same time.</para>
      <para>If a page is released, its state changes to free, and it is available for subsequent allocation operations. After memory is released or decommitted, you can never refer to the memory again. Any information that may have been in that memory is gone forever. Attempts to read from or write to a free page results in an access violation exception. If you need to keep information, do not decommit or free memory that  contains the information.</para>
      <para>The
<b>VirtualFreeEx</b> function can be used on an AWE region of memory and it invalidates any physical page mappings in the region when freeing the address space. However, the physical pages are not deleted, and the application can use them. The application must explicitly call
<see cref="FreeUserPhysicalPages" /> to free the physical pages. When the  process is terminated, all resources are automatically cleaned up.</para>
      <para>To delete an enclave when you finish using it, specify the following values:</para>
      <list type="bullet">
        <item>
          <description>The base address of the enclave for the <i>lpAddress</i> parameter.</description>
        </item>
        <item>
          <description>0 for the <i>dwSize</i> parameter.</description>
        </item>
        <item>
          <description>
            <b>MEM_RELEASE</b> for the <i>dwFreeType</i> parameter. The <b>MEM_DECOMMIT</b> value is not supported for enclaves.</description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocEx" />
  </member>
  <member name="Windows.VirtualLock">
    <summary>
      <para>Locks the specified region of the process's virtual address space into physical memory, ensuring that subsequent access to the region will not incur a page fault.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be locked.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region to be locked, in bytes. The region of affected pages includes all pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes both pages to be locked.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>All pages in the specified region must be committed. Memory protected with <b>PAGE_NOACCESS</b> cannot be locked.</para>
      <para>Locking pages into memory may degrade the performance of the system by reducing the available RAM and forcing the system to swap out other critical pages to the paging file. Each version of Windows has a limit on the maximum number of pages a process can lock. This limit is intentionally small to avoid severe performance degradation. Applications that need to lock larger numbers of pages must first call the
<see cref="SetProcessWorkingSetSize" /> function to increase their minimum and maximum working set sizes. The maximum number of pages that a process can lock is equal to the number of pages in its minimum working set minus a small overhead.</para>
      <para>Pages that a process has locked remain in physical memory until the process unlocks them or terminates. These pages are guaranteed not to be written to the pagefile while they are locked.</para>
      <para>To unlock a region of locked pages, use the
<see cref="VirtualUnlock" /> function. Locked pages are automatically unlocked when the process terminates.</para>
      <para>This function is not like the
<see cref="GlobalLock" /> or
<see cref="LocalLock" /> function in that it does not increment a lock count and translate a handle into a pointer. There is no lock count for virtual pages, so multiple calls to the
<see cref="VirtualUnlock" /> function are never required to unlock a region of pages.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-guard-pages">Creating Guard Pages</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso cref="SetProcessWorkingSetSize" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualUnlock" />
  </member>
  <member name="Windows.VirtualProtect">
    <summary>
      <para>Changes the protection on a region of committed pages in the virtual address space of the calling
process.</para>
      <para>To change the access protection of any process, use the
<see cref="VirtualProtectEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>The address of the starting page of the region of pages whose access protection attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the
<see cref="VirtualAlloc" /> or
<see cref="VirtualAllocEx" /> function using
<b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by
separate calls to <b>VirtualAlloc</b> or
<b>VirtualAllocEx</b> using
<b>MEM_RESERVE</b>.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region whose access protection attributes are to be changed, in bytes. The region of
affected pages includes all pages containing one or more bytes in the range from the
<i>lpAddress</i> parameter to
<code>(lpAddress+dwSize)</code>. This means that a 2-byte range
straddling a page boundary causes the protection attributes of both pages to be changed.</para>
    </param>
    <param name="flNewProtect">
      <para>The memory protection option. This parameter can be one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was
mapped (see <see cref="MapViewOfFile" />,
<see cref="MapViewOfFileEx" />, and
<see cref="MapViewOfFileExNuma" />).</para>
    </param>
    <param name="lpflOldProtect">
      <para>A pointer to a variable that receives the previous access protection value of the first page in the
specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid
variable, the function fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can set the access protection value on committed pages only. If the state of any page in the specified
region is not committed, the function fails and returns without modifying the access protection of any pages in the
specified region.</para>
      <para>The <b>PAGE_GUARD</b> protection modifier establishes guard pages. Guard pages act as
one-shot access alarms. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-guard-pages">Creating Guard Pages</a>.</para>
      <para>It is best to avoid using <b>VirtualProtect</b> to change
page protections on memory blocks allocated by <see cref="GlobalAlloc" />,
<see cref="HeapAlloc" />, or
<see cref="LocalAlloc" />, because multiple memory blocks can exist on a
single page. The heap manager assumes that all pages in the heap grant at least read and write access.</para>
      <para>When protecting a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place.  Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualProtectEx" />
  </member>
  <member name="Windows.VirtualProtectEx">
    <summary>
      <para>Changes the protection on a region of committed pages in the virtual address space of a specified
process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose memory protection is to be changed. The handle must have the
<b>PROCESS_VM_OPERATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages whose access protection attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the
<see cref="VirtualAlloc" /> or
<see cref="VirtualAllocEx" /> function using
<b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by
separate calls to <b>VirtualAlloc</b> or
<b>VirtualAllocEx</b> using
<b>MEM_RESERVE</b>.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region whose access protection attributes are changed, in bytes. The region of affected
pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i></para>
      <para>parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte
range straddling a page boundary causes the protection attributes of both pages to be changed.</para>
    </param>
    <param name="flNewProtect">
      <para>The memory protection option. This parameter can be one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was
mapped (see <see cref="MapViewOfFile" />,
<see cref="MapViewOfFileEx" />, and
<see cref="MapViewOfFileExNuma" />).</para>
    </param>
    <param name="lpflOldProtect">
      <para>A pointer to a variable that receives the previous access protection of the first page in the specified
region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the
function fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The access protection value can be set only on committed pages. If the state of any page in the specified
region is not committed, the function fails and returns without modifying the access protection of any pages in
the specified region.</para>
      <para>The <b>PAGE_GUARD</b> protection modifier establishes guard pages. Guard pages act as
one-shot access alarms. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-guard-pages">Creating Guard Pages</a>.</para>
      <para>It is best to avoid using <b>VirtualProtectEx</b> to
change page protections on memory blocks allocated by
<see cref="GlobalAlloc" />,
<see cref="HeapAlloc" />, or
<see cref="LocalAlloc" />, because multiple memory blocks can exist on a
single page. The heap manager assumes that all pages in the heap grant at least read and write access.</para>
      <para>When protecting a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place. Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAlloc" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualQueryEx" />
  </member>
  <member name="Windows.VirtualProtectFromApp">
    <summary>
      <para>Changes the protection on a region of committed pages in the virtual address space of the calling
process.</para>
    </summary>
    <param name="Address">
      <para>A pointer an address that describes the starting page of the region of pages whose access protection
attributes are to be changed.</para>
      <para>All pages in the specified region must be within the same reserved region allocated when calling the
<see cref="VirtualAlloc" />, <see cref="VirtualAllocFromApp" />, or
<see cref="VirtualAllocEx" /> function using
<b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were allocated by
separate calls to <b>VirtualAlloc</b>, <b>VirtualAllocFromApp</b>,  or
<b>VirtualAllocEx</b> using
<b>MEM_RESERVE</b>.</para>
    </param>
    <param name="Size">
      <para>The size of the region whose access protection attributes are to be changed, in bytes. The region of
affected pages includes all pages containing one or more bytes in the range from the
<i>Address</i> parameter to
<code>(Address+Size)</code>. This means that a 2-byte range
straddling a page boundary causes the protection attributes of both pages to be changed.</para>
    </param>
    <param name="NewProtection">
      <para>The memory protection option. This parameter can be one of the
<a href="https://docs.microsoft.com//windows/desktop/Memory/memory-protection-constants">memory protection constants</a>.</para>
      <para>For mapped views, this value must be compatible with the access protection specified when the view was
mapped (see <see cref="MapViewOfFile" />,
<see cref="MapViewOfFileEx" />, and
<see cref="MapViewOfFileExNuma" />).</para>
      <para>The following constants generate an error:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE_READWRITE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_WRITECOPY</b>
          </description>
        </item>
      </list>
      <para>The following constants are allowed only for apps that have the <b>codeGeneration</b> capability:</para>
      <list type="bullet">
        <item>
          <description>
            <b>PAGE_EXECUTE</b>
          </description>
        </item>
        <item>
          <description>
            <b>PAGE_EXECUTE_READ</b>
          </description>
        </item>
      </list>
    </param>
    <param name="OldProtection">
      <para>A pointer to a variable that receives the previous access protection value of the first page in the
specified region of pages. If this parameter is <b>NULL</b> or does not point to a valid
variable, the function fails.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can call <b>VirtualProtectFromApp</b> from Windows Store apps with just-in-time (JIT) capabilities to use JIT functionality. The app must include the <b>codeGeneration</b> capability in the app manifest file to use JIT capabilities.</para>
      <para>You can set the access protection value on committed pages only. If the state of any page in the specified
region is not committed, the function fails and returns without modifying the access protection of any pages in the
specified region.</para>
      <para>The <b>PAGE_GUARD</b> protection modifier establishes guard pages. Guard pages act as
one-shot access alarms. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-guard-pages">Creating Guard Pages</a>.</para>
      <para>It is best to avoid using <b>VirtualProtectFromApp</b> to change
page protections on memory blocks allocated by <see cref="GlobalAlloc" />,
<see cref="HeapAlloc" />, or
<see cref="LocalAlloc" />, because multiple memory blocks can exist on a
single page. The heap manager assumes that all pages in the heap grant at least read and write access.</para>
      <para>
        <b>VirtualProtectFromApp</b> allows you to mark pages as executable, but does not allow you to set both write and execute permissions at the same time.</para>
      <para>When protecting a region that will be executable, the calling program bears responsibility for ensuring cache
coherency via an appropriate call to
<see cref="FlushInstructionCache" /> once the code has been set
in place.  Otherwise attempts to execute code out of the newly executable region may produce unpredictable
results.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocFromApp" />
    <seealso cref="VirtualProtect" />
    <seealso cref="VirtualProtectEx" />
  </member>
  <member name="Windows.VirtualQuery">
    <summary>
      <para>Retrieves information about a range of pages in the virtual address space of the calling process.</para>
      <para>To retrieve information about a range of pages in the address space of another process, use the
<see cref="VirtualQueryEx" /> function.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a
<see cref="MEMORY_BASIC_INFORMATION" /> structure in which information about the specified page range is returned.</para>
    </param>
    <param name="dwLength">
      <para>The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</para>
    </param>
    <returns>
      <para>The return value is the actual number of bytes returned in the information buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>VirtualQuery</b> provides information about a region of consecutive pages beginning at a specified address that share the following attributes:</para>
      <list type="bullet">
        <item>
          <description>The state of all pages is the same (<b>MEM_COMMIT</b>, <b>MEM_RESERVE</b>, <b>MEM_FREE</b>, <b>MEM_PRIVATE</b>, <b>MEM_MAPPED</b>, or <b>MEM_IMAGE</b>).</description>
        </item>
        <item>
          <description>If the initial page is not free, all pages in the region are part of the same initial allocation of pages created by a single call to <see cref="VirtualAlloc" />, <see cref="MapViewOfFile" />, or one of the following extended versions of these functions: <see cref="VirtualAllocEx" />, <see cref="VirtualAllocExNuma" />, <see cref="MapViewOfFileEx" />, <see cref="MapViewOfFileExNuma" />.</description>
        </item>
        <item>
          <description>The access granted to all pages is the same (<b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>, <b>PAGE_NOACCESS</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE</b>, <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_READWRITE</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_GUARD</b>, or <b>PAGE_NOCACHE</b>).</description>
        </item>
      </list>
      <para>The function determines the attributes of the first page in the region and then scans subsequent pages until it scans the entire range of pages or until it encounters a page with a nonmatching set of attributes. The function returns the attributes and the size of the region of pages with matching attributes, in bytes. For example, if there is a 40 megabyte (MB) region of free memory, and
<b>VirtualQuery</b> is called on a page that is 10 MB into the region, the function will obtain a state of <b>MEM_FREE</b> and a size of 30 MB.</para>
      <para>If a shared copy-on-write page is modified, it becomes private to the process that modified the page. However, the <b>VirtualQuery</b> function will continue to report such pages as <b>MEM_MAPPED</b> (for data views) or <b>MEM_IMAGE</b> (for executable image views) rather than <b>MEM_PRIVATE</b>. To detect whether copy-on-write has occurred for a specific page, either access the page or lock it using the <see cref="VirtualLock" /> function to make sure the page is resident in memory, then use the <see cref="QueryWorkingSetEx" /> function to check the <b>Shared</b> bit in the extended working set information for the page. If the <b>Shared</b> bit is clear, the page is private.</para>
      <para>This function reports on a region of pages in the memory of the calling process, and the
<see cref="VirtualQueryEx" /> function reports on a region of pages in the memory of a specified process.</para>
    </remarks>
    <seealso cref="GetSystemInfo" />
    <seealso cref="MEMORY_BASIC_INFORMATION" />
    <seealso cref="MapViewOfFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualQueryEx" />
  </member>
  <member name="Windows.VirtualQueryEx">
    <summary>
      <para>Retrieves information about a range of pages within the virtual address space of a specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose memory information is queried. The handle must have been opened with the <b>PROCESS_QUERY_INFORMATION</b> access right, which enables using the handle to read information from the process object. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the
<see cref="GetSystemInfo" /> function.</para>
      <para>If <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function fails with <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a
<see cref="MEMORY_BASIC_INFORMATION" /> structure in which information about the specified page range is returned.</para>
    </param>
    <param name="dwLength">
      <para>The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.</para>
    </param>
    <returns>
      <para>The return value is the actual number of bytes returned in the information buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>VirtualQueryEx</b> provides information about a region of consecutive pages beginning at a specified address that share the following attributes:</para>
      <list type="bullet">
        <item>
          <description>The state of all pages is the same (<b>MEM_COMMIT</b>, <b>MEM_RESERVE</b>, <b>MEM_FREE</b>, <b>MEM_PRIVATE</b>, <b>MEM_MAPPED</b>, or <b>MEM_IMAGE</b>).</description>
        </item>
        <item>
          <description>If the initial page is not free, all pages in the region are part of the same initial allocation of pages created by a single call to <see cref="VirtualAlloc" />, <see cref="MapViewOfFile" />, or one of the following extended versions of these functions: <see cref="VirtualAllocEx" />, <see cref="VirtualAllocExNuma" />, <see cref="MapViewOfFileEx" />, <see cref="MapViewOfFileExNuma" />.</description>
        </item>
        <item>
          <description>The access granted to all pages is the same (<b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>, <b>PAGE_NOACCESS</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE</b>, <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_READWRITE</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_GUARD</b>, or <b>PAGE_NOCACHE</b>).</description>
        </item>
      </list>
      <para>The
<b>VirtualQueryEx</b> function determines the attributes of the first page in the region and then scans subsequent pages until it scans the entire range of pages, or until it encounters a page with a nonmatching set of attributes. The function returns the attributes and the size of the region of pages with matching attributes, in bytes. For example, if there is a 40 megabyte (MB) region of free memory, and
<b>VirtualQueryEx</b> is called on a page that is 10 MB into the region, the function will obtain a state of <b>MEM_FREE</b> and a size of 30 MB.</para>
      <para>If a shared copy-on-write page is modified, it becomes private to the process that modified the page. However, the <b>VirtualQueryEx</b> function will continue to report such pages as <b>MEM_MAPPED</b> (for data views) or <b>MEM_IMAGE</b> (for executable image views) rather than <b>MEM_PRIVATE</b>. To detect whether copy-on-write has occurred for a specific page, either access the page or lock it using the <see cref="VirtualLock" /> function to make sure the page is resident in memory, then use the <see cref="QueryWorkingSet" /> or <see cref="QueryWorkingSetEx" /> function to check the <b>Shared</b> bit in the extended working set information for the page. If the <b>Shared</b> bit is clear, the page is private.</para>
    </remarks>
    <seealso cref="GetSystemInfo" />
    <seealso cref="MEMORY_BASIC_INFORMATION" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualAllocEx" />
    <seealso cref="VirtualProtectEx" />
  </member>
  <member name="Windows.VirtualUnlock">
    <summary>
      <para>Unlocks a specified range of pages in the virtual address space of a process, enabling the system to swap the pages out to the paging file if necessary.</para>
    </summary>
    <param name="lpAddress">
      <para>A pointer to the base address of the region of pages to be unlocked.</para>
    </param>
    <param name="dwSize">
      <para>The size of the region being unlocked, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes both pages to be unlocked.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For the function to succeed, the range specified need not match a range passed to a previous call to the
<see cref="VirtualLock" /> function, but all pages in the range must be locked. If any of the pages in the specified range are not locked, <b>VirtualUnlock</b> removes such pages from the working set, sets last error to <b>ERROR_NOT_LOCKED</b>, and returns <b>FALSE</b>.</para>
      <para>Calling
<b>VirtualUnlock</b> on a range of memory that is not locked releases the pages from the process's working set.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-memory-functions">Virtual Memory Functions</seealso>
    <seealso cref="VirtualLock" />
  </member>
  <member name="Windows.WriteProcessMemory">
    <summary>
      <para>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</para>
    </param>
    <param name="lpBaseAddress">
      <para>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that contains data to be written in  the address space of the specified process.</para>
    </param>
    <param name="nSize">
      <para>The number of bytes to be written to the specified process.</para>
    </param>
    <param name="lpNumberOfBytesWritten">
      <para>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <i>lpNumberOfBytesWritten</i> is <b>NULL</b>, the parameter is ignored.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />. The function fails if the requested write operation crosses into an area of the process that is inaccessible.</para>
    </returns>
    <remarks>
      <para>
        <b>WriteProcessMemory</b> copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is  being debugged.</para>
      <para>The entire area to be written to must be accessible, and if it is not accessible, the function fails.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/process-functions-for-debugging">Process Functions for Debugging</seealso>
    <seealso cref="ReadProcessMemory" />
    <seealso cref="VirtualAllocEx" />
  </member>
</doc>