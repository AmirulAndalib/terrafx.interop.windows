<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.EnumSystemFirmwareTables">
    <summary>
      <para>Enumerates all system firmware tables of the specified type.</para>
    </summary>
    <param name="FirmwareTableProviderSignature">
      <para>The identifier of the firmware table provider to which the query is to be directed. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>'ACPI'</description>
          <description>The ACPI firmware table provider.</description>
        </item>
        <item>
          <description>'FIRM'</description>
          <description>The raw firmware table provider. Not supported for UEFI systems; use 'RSMB' instead.</description>
        </item>
        <item>
          <description>'RSMB'</description>
          <description>The raw SMBIOS firmware table provider.</description>
        </item>
      </list>
    </param>
    <param name="pFirmwareTableEnumBuffer">
      <para>A pointer to a buffer that receives the list of  firmware tables. If this parameter is <b>NULL</b>, the return value is the required buffer size.</para>
      <para>For more information on the contents of this buffer, see the Remarks section.</para>
    </param>
    <param name="BufferSize">
      <para>The size of the <i>pFirmwareTableBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes written to the buffer. This value will always be less than or equal to <i>BufferSize</i>.</para>
      <para>If the function fails because the buffer is not large enough, the return value is the required buffer size, in bytes. This value is always greater than <i>BufferSize</i>.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can access the System Management BIOS (SMBIOS) information by declaring the <b>smbios</b> restricted capability in the app manifest.
See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-smbios-information-from-a-universal-windows-app">Access SMBIOS information from a Universal Windows App</a> for details. Only raw SMBIOS (RSMB) firmware tables can be accessed from a Universal Windows app.</para>
      <para>As of Windows Server 2003 with Service Pack 1 (SP1), applications cannot access the \Device\PhysicalMemory object. Access to this object is limited to kernel-mode drivers. This change affects applications read System Management BIOS (SMBIOS) or other BIOS data stored in the lowest 1MB of physical memory. Applications have the following alternatives to read data from low physical memory:</para>
      <list type="bullet">
        <item>
          <description>Retrieve the SMBIOS properties using WMI. Many individual properties are contained in the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-provider">Win32 classes</a>. You can also retrieve the raw SMBIOS data in a single buffer using the <b>MSSMBios_RawSMBiosTables</b> class.</description>
        </item>
        <item>
          <description>Use the <see cref="GetSystemFirmwareTable" /> function to read the raw SMBIOS firmware table.</description>
        </item>
      </list>
      <para>There is no way for applications to write to low physical memory.</para>
      <para>The raw SMBIOS table provider ('RSMB') currently returns a single table identifier, 0x0000. This corresponds to the raw SMBIOS firmware table.</para>
      <para>The raw firmware table provider ('FIRM') returns a list of <b>DWORD</b> table identifiers. Each identifier corresponds to the beginning of a physical address range. Currently, this provider returns 'C0000' and 'E0000'. These values correspond to physical memory from 0xC0000 to 0xDFFFF and 0xE0000 to 0xFFFFF, respectively.</para>
      <para>The ACPI table provider ('ACPI') returns a list of <b>DWORD</b> table identifiers. Each identifier returned corresponds to Signature field of the DESCRIPTION_HEADER structure for an ACPI table currently in the ACPI namespace of the system.</para>
      <para>For ACPI, if the system contains multiple tables with the same name, they are all enumerated with <b>EnumSystemFirmwareTables</b>. However, <see cref="GetSystemFirmwareTable" /> retrieves only the first table in the list with this name.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-smbios-information-from-a-universal-windows-app">Access SMBIOS information from a Universal Windows App</seealso>
    <seealso cref="GetSystemFirmwareTable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameEx">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameExA">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameExW">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameEx">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameExA">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameExW">
    <summary>
      <para>Retrieves a NetBIOS or DNS name associated with the local computer. The names are established at system startup, when the system reads them from the registry.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be retrieved. This parameter is a value from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type. The following table provides additional information.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNameDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the local computer. This name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNameNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>The name of the DNS domain assigned to the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS domain name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsFullyQualified</b>
          </description>
          <description>
            <para>The fully qualified DNS name that uniquely identifies the computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the fully qualified DNS name of the local computer, not the name of the cluster virtual server.</para>
            <para>The fully qualified DNS name is a combination of the DNS host name and the DNS domain name, using the form <i>HostName</i>.<i>DomainName</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>The DNS host name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the DNS host name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>The NetBIOS name of the local computer. If the local computer is a node in a cluster, <i>lpBuffer</i> receives the NetBIOS name of the local computer, not the name of the cluster virtual server.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name.</para>
      <para>The length of the name may be greater than MAX_COMPUTERNAME_LENGTH characters because DNS allows longer names. To ensure that this buffer is large enough, set this parameter to <b>NULL</b> and use the required buffer size returned in the <i>lpnSize</i> parameter.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating <b>null</b> character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_MORE_DATA. This parameter receives the size of the buffer required,  including the terminating <b>null</b> character.</para>
      <para>If <i>lpBuffer</i> is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpBuffer</i> buffer is too small. The <i>lpnSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If group policy is not set for the local machine, the
<b>GetComputerNameEx</b> function retrieves the NetBIOS or DNS names established at system startup. If  group policy is set, the function returns the primary domain name set by group policy. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the local computer is not configured to use DNS names, <b>GetComputerNameEx</b> will not return DNS information. To configure the computer to do this, follow the steps outlined in the operating system help and change the primary DNS suffix of the computer, then restart the computer.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
      <para>If you are working with environments that use different DNS layouts, where the computer's FQDN does not match the FQDN of its domain, use <see cref="LsaQueryInformationPolicy" /> instead.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#define _WIN32_WINNT 0x0500

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void _tmain(void)
{
    TCHAR buffer[256] = TEXT("");
    TCHAR szDescription[8][32] = {TEXT("NetBIOS"),
        TEXT("DNS hostname"),
        TEXT("DNS domain"),
        TEXT("DNS fully-qualified"),
        TEXT("Physical NetBIOS"),
        TEXT("Physical DNS hostname"),
        TEXT("Physical DNS domain"),
        TEXT("Physical DNS fully-qualified")};
    int cnf = 0;
    DWORD dwSize = _countof(buffer);

    for (cnf = 0; cnf &lt; ComputerNameMax; cnf++)
    {
        if (!GetComputerNameEx((COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;amp;amp;amp;amp;dwSize))
        {
            _tprintf(TEXT("GetComputerNameEx failed (%d)\n"), GetLastError());
            return;
        }
        else _tprintf(TEXT("%s: %s\n"), szDescription[cnf], buffer);

        dwSize = _countof(buffer);
        ZeroMemory(buffer, dwSize);
    }
}

</code>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="ResUtilGetEnvironmentWithNetName" />
    <seealso cref="ResUtilSetResourceServiceEnvironment" />
    <seealso cref="ResUtilSetResourceServiceStartParameters" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetIntegratedDisplaySize">
    <summary>
      <para>Retrieves the best estimate of the diagonal size of the built-in screen, in inches.</para>
    </summary>
    <param name="sizeInInches">
      <para>The best estimate of the diagonal size of the built-in screen, in inches.</para>
    </param>
    <returns>
      <para>The result code indicating if the function succeeded or failed.</para>
    </returns>
    <remarks>
      <para>Uses the display driver as the source for display size information. Registry overrides to screen size will not be used. Uses the display adapter connection type to determine which display, if any, is integral to the system.  If no internal display detected, an error will be returned.   This requires the display to be active to be detected. For example, the lid cannot be closed when the function is called.</para>
      <para>To compile an application that uses this function, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>The following function displays the best estimate of the diagonal size of the built-in screen, in inches.</para>
      <code>void ShowIntegratedDisplaySize()
{
  Platform.String^ buffer;

  double sizeInInches;
  HRESULT result = GetIntegratedDisplaySize(&amp;amp;amp;amp;amp;amp;sizeInInches) ;

  if (SUCCEEDED(result))
  {
    buffer += "Internal display size is " + sizeInInches.ToString() + " inches.\n";
  }
  else
  {
    buffer += "No valid Internal display found. \n";
  }

  // Output the string buffer here...
}

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetLocalTime">
    <summary>
      <para>Retrieves the current local date and time.</para>
      <para>To retrieve the current date and time in Coordinated Universal Time (UTC) format, use the <see cref="GetSystemTime" /> function.</para>
    </summary>
    <param name="lpSystemTime">
      <para>A pointer to a
<see cref="SYSTEMTIME" /> structure to receive the current local date and time.</para>
    </param>
    <remarks>
      <para>To set the current local date and time, use the <see cref="SetLocalTime" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<see cref="SYSTEMTIME" />.</para>
    </remarks>
    <seealso cref="GetSystemTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/local-time">Local Time</seealso>
    <seealso cref="SYSTEMTIME" />
    <seealso cref="SetLocalTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetLogicalProcessorInformation">
    <summary>
      <para>Retrieves information about logical processors and related hardware.</para>
      <para>To retrieve information about logical processors and related hardware, including processor groups, use the <see cref="GetLogicalProcessorInformationEx" /> function.</para>
    </summary>
    <param name="Buffer">
      <para>A pointer to a buffer that receives  an array of <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" /> structures. If the function fails, the contents of this buffer are undefined.</para>
    </param>
    <param name="ReturnedLength">
      <para>On input, specifies the length of the buffer pointed to by  <i>Buffer</i>, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and <i>ReturnLength</i> is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER, and <i>ReturnLength</i> is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of <i>ReturnLength</i> is undefined.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is TRUE and at least one <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" /> structure is written to the output buffer.</para>
      <para>If the function fails, the return value is FALSE. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetLogicalProcessorInformation</b> can be used to get information about the relationship between logical processors in the system, including:</para>
      <list type="bullet">
        <item>
          <description>The logical processors that are part of a <a href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA</a> node.</description>
        </item>
        <item>
          <description>The logical processors that share resources. An example of this type of resource sharing would be hyperthreading scenarios.</description>
        </item>
      </list>
      <para>Your application can use this information when affinitizing your threads and processes to take best advantage of the hardware properties of the platform, or to determine the number of logical and physical processors for licensing purposes.</para>
      <para>Each of the <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" /> structures returned in the buffer contains the following:</para>
      <list type="bullet">
        <item>
          <description>A logical processor affinity mask, which indicates the logical processors that the information in the structure applies to.</description>
        </item>
        <item>
          <description>A logical processor mask of type <see cref="LOGICAL_PROCESSOR_RELATIONSHIP" />, which indicates the relationship between the logical processors in the mask. Applications calling this function must be prepared to handle additional indicator values in the future.</description>
        </item>
      </list>
      <para>Note that the order in which the structures are returned in the buffer  may change between calls to this function.</para>
      <para>The size of the <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" /> structure varies between processor architectures and versions of Windows. For this reason, applications should first call this function to obtain the required buffer size, then dynamically allocate memory for the buffer.</para>
      <para>On systems with more than 64 logical processors, the <b>GetLogicalProcessorInformation</b> function retrieves logical processor information about processors in the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> to which the calling thread is currently assigned. Use the <see cref="GetLogicalProcessorInformationEx" /> function to retrieve information about processors in all processor groups on the system.</para>
      <blockquote>
        <para>[!NOTE]
Starting with <i>TBD Release Iron</i>, the behavior of this and other NUMA functions has been modified to better support systems with nodes containing more that 64 processors. For more information about this change, including information about enabling the old behavior of this API, see <a href="https://docs.microsoft.com//windows/win32/procthread/numa-support">NUMA Support</a>.</para>
      </blockquote>
      <h3>Behavior starting with TBD Release Iron</h3>
      <para>The relationship structures for <see cref="RelationNumaNode" /> contain the affinity mask for the node's affinity within the calling thread's group.</para>
      <h4>Examples</h4>
      <para>The following C++ example uses the <b>GetLogicalProcessorInformation</b> function to display information about processors on the current system.  Because <b>GetLogicalProcessorInformation</b> is not present on all systems, this example uses the <see cref="GetProcAddress" /> function instead of calling <b>GetLogicalProcessorInformation</b> directly.</para>
      <para>This example reports the number of active processor cores. This example also reports the number of NUMA nodes, physical packages, and caches on systems that support this information.   For more information, see the description of the <b>Relationship</b> member of the <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" /> structure. <b>Windows Server 2003, Windows XP Professional x64 Edition and Windows XP with SP3:  </b>This example reports the number of physical processors rather than the number of active processor cores.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

typedef BOOL (WINAPI *LPFN_GLPI)(
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,
    PDWORD);


// Helper function to count set bits in the processor mask.
DWORD CountSetBits(ULONG_PTR bitMask)
{
    DWORD LSHIFT = sizeof(ULONG_PTR)*8 - 1;
    DWORD bitSetCount = 0;
    ULONG_PTR bitTest = (ULONG_PTR)1 &lt;&lt; LSHIFT;
    DWORD i;

    for (i = 0; i &lt;= LSHIFT; ++i)
    {
        bitSetCount += ((bitMask &amp;amp;amp;amp;amp;amp; bitTest)?1:0);
        bitTest/=2;
    }

    return bitSetCount;
}

int _cdecl _tmain ()
{
    LPFN_GLPI glpi;
    BOOL done = FALSE;
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = NULL;
    DWORD returnLength = 0;
    DWORD logicalProcessorCount = 0;
    DWORD numaNodeCount = 0;
    DWORD processorCoreCount = 0;
    DWORD processorL1CacheCount = 0;
    DWORD processorL2CacheCount = 0;
    DWORD processorL3CacheCount = 0;
    DWORD processorPackageCount = 0;
    DWORD byteOffset = 0;
    PCACHE_DESCRIPTOR Cache;

    glpi = (LPFN_GLPI) GetProcAddress(
                            GetModuleHandle(TEXT("kernel32")),
                            "GetLogicalProcessorInformation");
    if (NULL == glpi)
    {
        _tprintf(TEXT("\nGetLogicalProcessorInformation is not supported.\n"));
        return (1);
    }

    while (!done)
    {
        DWORD rc = glpi(buffer, &amp;amp;amp;amp;amp;amp;returnLength);

        if (FALSE == rc)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (buffer)
                    free(buffer);

                buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(
                        returnLength);

                if (NULL == buffer)
                {
                    _tprintf(TEXT("\nError: Allocation failure\n"));
                    return (2);
                }
            }
            else
            {
                _tprintf(TEXT("\nError %d\n"), GetLastError());
                return (3);
            }
        }
        else
        {
            done = TRUE;
        }
    }

    ptr = buffer;

    while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) &lt;= returnLength)
    {
        switch (ptr-&gt;Relationship)
        {
        case RelationNumaNode:
            // Non-NUMA systems report a single record of this type.
            numaNodeCount++;
            break;

        case RelationProcessorCore:
            processorCoreCount++;

            // A hyperthreaded core supplies more than one logical processor.
            logicalProcessorCount += CountSetBits(ptr-&gt;ProcessorMask);
            break;

        case RelationCache:
            // Cache data is in ptr-&gt;Cache, one CACHE_DESCRIPTOR structure for each cache.
            Cache = &amp;amp;amp;amp;amp;amp;ptr-&gt;Cache;
            if (Cache-&gt;Level == 1)
            {
                processorL1CacheCount++;
            }
            else if (Cache-&gt;Level == 2)
            {
                processorL2CacheCount++;
            }
            else if (Cache-&gt;Level == 3)
            {
                processorL3CacheCount++;
            }
            break;

        case RelationProcessorPackage:
            // Logical processors share a physical package.
            processorPackageCount++;
            break;

        default:
            _tprintf(TEXT("\nError: Unsupported LOGICAL_PROCESSOR_RELATIONSHIP value.\n"));
            break;
        }
        byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
        ptr++;
    }

    _tprintf(TEXT("\nGetLogicalProcessorInformation results:\n"));
    _tprintf(TEXT("Number of NUMA nodes: %d\n"),
             numaNodeCount);
    _tprintf(TEXT("Number of physical processor packages: %d\n"),
             processorPackageCount);
    _tprintf(TEXT("Number of processor cores: %d\n"),
             processorCoreCount);
    _tprintf(TEXT("Number of logical processors: %d\n"),
             logicalProcessorCount);
    _tprintf(TEXT("Number of processor L1/L2/L3 caches: %d/%d/%d\n"),
             processorL1CacheCount,
             processorL2CacheCount,
             processorL3CacheCount);

    free(buffer);

    return 0;
}


</code>
    </remarks>
    <seealso cref="GetLogicalProcessorInformationEx" />
    <seealso cref="LOGICAL_PROCESSOR_RELATIONSHIP" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION" />
  </member>
  <member name="Windows.GetLogicalProcessorInformationEx">
    <summary>
      <para>Retrieves information about the relationships of logical processors and related hardware.</para>
    </summary>
    <param name="RelationshipType">
      <para>The type of relationship to retrieve. This parameter can be one of the following <see cref="LOGICAL_PROCESSOR_RELATIONSHIP" /> values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationCache</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors  that share a cache.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationNumaNode</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors  that are part of the same NUMA node.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationProcessorCore</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors that share a single processor core.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationProcessorPackage</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors that share a physical package.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationGroup</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors that share a processor group.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RelationAll</b>
                </description>
              </item>
              <item>
                <description>0xffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about logical processors for all relationship types (cache, NUMA node, processor core, physical package, and processor group).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="Buffer">
      <para>A pointer to a buffer that receives  an array of <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX" /> structures. If the function fails, the contents of this buffer are undefined.</para>
    </param>
    <param name="ReturnedLength">
      <para>On input, specifies the length of the buffer pointed to by  <i>Buffer</i>, in bytes. If the buffer is large enough to contain all of the data, this function succeeds and <i>ReturnedLength</i> is set to the number of bytes returned. If the buffer is not large enough to contain all of the data, the function fails, <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER, and <i>ReturnedLength</i> is set to the buffer length required to contain all of the data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of <i>ReturnedLength</i> is undefined.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is TRUE and at least one <see cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX" /> structure is written to the output buffer.</para>
      <para>If the function fails, the return value is FALSE. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a 32-bit process running under WOW64 calls this function on a system with more than 64 processors, some of the processor affinity masks returned by the function may be incorrect. This is  because the high-order <b>DWORD</b> of the 64-bit &lt;a href=" the affinity masks for processors 32 through 63 are incorrectly represented as duplicates of the masks for processors 0 through 31. In addition, the affinity masks for processors 32 through 63 are incorrectly represented as duplicates of the masks for processors 0 through 31. In addition, the sum of all per-group <b>ActiveProcessorCount</b> and <b>MaximumProcessorCount</b> values reported in <see cref="PROCESSOR_GROUP_INFO" /> structures may exclude some active logical processors.</para>
      <para>When this function is called with a relationship type of <b>RelationProcessorCore</b>, it returns a <see cref="PROCESSOR_RELATIONSHIP" /> structure for every active processor core in every processor group in the system. This is by design, because an unaffinitized 32-bit thread can run on any logical processor in a given group, including processors 32 through 63. A 32-bit caller can use the total count of <b>PROCESSOR_RELATIONSHIP</b> structures to determine the actual number of active processor cores on the system. However, the affinity of a 32-bit thread cannot be explicitly set to logical processor 32 through 63 of any processor group.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
Starting with <i>TBD Release Iron</i>, the behavior of this and other NUMA functions has been modified to better support systems with nodes containing more that 64 processors. For more information about this change, including information about enabling the old behavior of this API, see <a href="https://docs.microsoft.com//windows/win32/procthread/numa-support">NUMA Support</a>.</para>
      </blockquote>
      <h3>Behavior starting with TBD Release Iron</h3>
      <para>Requests for <see cref="RelationNumaNode" /> will return <see cref="NUMA_NODE_RELATIONSHIP" /> structures that contain only the affinity of the node within it's primary group. The <see cref="GroupCount" /> value will be 1 and the structure size is fixed.</para>
      <para>Requests for <b>RelationNumaNodeEx</b> or <b>RelationAll</b> will return <b>NUMA_NODE_RELATIONSHIP</b> structures that contain an array of affinities for the node over all groups. The <b>GroupCount</b> reports the number of affinities and the size of structure is variable.</para>
    </remarks>
    <seealso cref="SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX" />
  </member>
  <member name="Windows.GetNativeSystemInfo">
    <summary>
      <para>Retrieves information about the current system to an application running under
<a href="https://docs.microsoft.com//windows/desktop/WinProg64/running-32-bit-applications">WOW64</a>. If the function is called from a 64-bit application, or on a 64-bit system that does not have an Intel64 or x64 processor (such as ARM64), it is equivalent to the
<see cref="GetSystemInfo" /> function.</para>
    </summary>
    <param name="lpSystemInfo">
      <para>A pointer to a
<see cref="SYSTEM_INFO" /> structure that receives the information.</para>
    </param>
    <remarks>
      <para>To determine whether a Win32-based application is running under WOW64, call the
<see cref="IsWow64Process2" /> function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
    </remarks>
    <seealso cref="IsWow64Process" />
    <seealso cref="SYSTEM_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetPhysicallyInstalledSystemMemory">
    <summary>
      <para>Retrieves the amount of RAM that is physically installed on the computer.</para>
    </summary>
    <param name="TotalMemoryInKilobytes">
      <para>A pointer to a
variable that receives the amount of physically installed RAM, in kilobytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b> and sets the
<i>TotalMemoryInKilobytes</i> parameter to a nonzero value.</para>
      <para>If the function fails, it returns <b>FALSE</b> and does not modify the
<i>TotalMemoryInKilobytes</i> parameter. To get extended error information, use the <see cref="GetLastError" /> function. Common errors are listed in the following table.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>The <i>TotalMemoryInKilobytes</i> parameter is <b>NULL</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_DATA</b>
            </para>
          </description>
          <description>
            <para>The System Management BIOS (SMBIOS) data is malformed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetPhysicallyInstalledSystemMemory</b> function retrieves the amount of physically installed RAM from the computer's SMBIOS  firmware tables. This can differ from the amount reported by the <see cref="GlobalMemoryStatusEx" /> function, which sets the <b>ullTotalPhys</b> member of the <see cref="MEMORYSTATUSEX" /> structure to the amount of physical memory that is available for the operating system to use. The amount of memory available to the operating system can be less than the amount of memory physically installed in the computer because the BIOS and some drivers may reserve memory as I/O regions for memory-mapped devices, making the memory unavailable to the operating system and applications.</para>
      <para>The amount of physical memory retrieved by the <b>GetPhysicallyInstalledSystemMemory</b> function must be equal to or greater than the amount reported by the <see cref="GlobalMemoryStatusEx" /> function; if it is less, the SMBIOS data is malformed and the function fails with <b>ERROR_INVALID_DATA</b>. Malformed SMBIOS data may indicate a problem with the user's computer.</para>
    </remarks>
    <seealso cref="EnumSystemFirmwareTables" />
    <seealso cref="GetSystemFirmwareTable" />
    <seealso cref="GlobalMemoryStatusEx" />
  </member>
  <member name="Windows.GetProcessorSystemCycleTime">
    <summary>
      <para>Retrieves the cycle time each processor in the specified processor group spent executing deferred procedure calls (DPCs) and interrupt service routines (ISRs) since the processor became active.</para>
    </summary>
    <param name="Group">
      <para>The number of the processor group for which to retrieve the cycle time.</para>
    </param>
    <param name="Buffer">
      <para>A pointer to a buffer to receive a SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION structure for each processor in the group. On output, the DWORD64 <b>CycleTime</b> member of this structure is set to the cycle time for one processor.</para>
    </param>
    <param name="ReturnedLength">
      <para>The size of the buffer, in bytes. When the function returns, this parameter contains the number of bytes written to <i>Buffer</i>. If the buffer is too small for the data, the function fails with ERROR_INSUFFICIENT_BUFFER and sets the <i>ReturnedLength</i> parameter to the required buffer size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
      <para>If the error value is ERROR_INSUFFICIENT_BUFFER, the <i>ReturnedLength</i> parameter contains the required buffer size.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0601 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">Processor Groups</seealso>
  </member>
  <member name="Windows.GetProductInfo">
    <summary>
      <para>Retrieves the product type for the operating system on the local computer, and maps the type to the product types supported by the specified operating system.</para>
      <para>To retrieve product type information on versions of Windows prior to the minimum supported operating systems specified in the Requirements section, use the <see cref="GetVersionEx" /> function. You can also use the <b>OperatingSystemSKU</b> property of the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-operatingsystem">Win32_OperatingSystem</a> WMI class.</para>
    </summary>
    <param name="dwOSMajorVersion">
      <para>The major version number of the operating system. The minimum value is 6.</para>
      <para>The combination of the <i>dwOSMajorVersion</i>, <i>dwOSMinorVersion</i>, <i>dwSpMajorVersion</i>, and <i>dwSpMinorVersion</i> parameters describes the maximum target operating system version for the application. For example, Windows Vista and Windows Server 2008 are version 6.0.0.0 and Windows 7 and Windows Server 2008 R2 are version 6.1.0.0. All Windows 10 based releases will be listed as version 6.3.</para>
    </param>
    <param name="dwOSMinorVersion">
      <para>The minor version number of the operating system. The minimum value is 0.</para>
    </param>
    <param name="dwSpMajorVersion">
      <para>The major version number of the operating system service pack. The minimum value is 0.</para>
    </param>
    <param name="dwSpMinorVersion">
      <para>The minor version number of the operating system service pack. The minimum value is 0.</para>
    </param>
    <param name="pdwReturnedProductType">
      <para>The product type. This parameter cannot be <b>NULL</b>. If the specified operating system  is less than the current operating system, this information is mapped to the types supported by the specified operating system. If the specified operating system is greater than the highest supported operating system, this information is mapped to the types supported by the current operating system.</para>
      <para>This parameter can be one of the following values (some products below may be out of support).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_BUSINESS</b>
                </description>
              </item>
              <item>
                <description>0x00000006</description>
              </item>
            </list>
          </description>
          <description>
            <para>Business</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_BUSINESS_N</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Business N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CLUSTER_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000012</description>
              </item>
            </list>
          </description>
          <description>
            <para>HPC Edition</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CLUSTER_SERVER_V</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Hyper Core V</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CORE</b>
                </description>
              </item>
              <item>
                <description>0x00000065</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Home</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CORE_COUNTRYSPECIFIC</b>
                </description>
              </item>
              <item>
                <description>0x00000063</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Home China</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CORE_N</b>
                </description>
              </item>
              <item>
                <description>0x00000062</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Home N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_CORE_SINGLELANGUAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000064</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Home Single Language</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_EVALUATION_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000050</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter (evaluation installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_A_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x00000091</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter, Semi-Annual Channel (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_A_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x00000092</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard, Semi-Annual Channel (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter (full installation. For Server Core installations of Windows Server 2012 and later, use the method, <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh846315(v=vs.85)">Determining whether Server Core is running</a>.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000000C</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter (core installation, Windows Server 2008 R2 and earlier)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_SERVER_CORE_V</b>
                </description>
              </item>
              <item>
                <description>0x00000027</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter without Hyper-V (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_DATACENTER_SERVER_V</b>
                </description>
              </item>
              <item>
                <description>0x00000025</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Datacenter without Hyper-V (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_EDUCATION</b>
                </description>
              </item>
              <item>
                <description>0x00000079</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Education</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_EDUCATION_N</b>
                </description>
              </item>
              <item>
                <description>0x0000007A</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Education N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_E</b>
                </description>
              </item>
              <item>
                <description>0x00000046</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise E</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_EVALUATION</b>
                </description>
              </item>
              <item>
                <description>0x00000048</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise Evaluation</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_N</b>
                </description>
              </item>
              <item>
                <description>0x0000001B</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_N_EVALUATION</b>
                </description>
              </item>
              <item>
                <description>0x00000054</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise N Evaluation</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_S</b>
                </description>
              </item>
              <item>
                <description>0x0000007D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise 2015 LTSB</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_S_EVALUATION</b>
                </description>
              </item>
              <item>
                <description>0x00000081</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise 2015 LTSB Evaluation</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_S_N</b>
                </description>
              </item>
              <item>
                <description>0x0000007E</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise 2015 LTSB N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_S_N_EVALUATION</b>
                </description>
              </item>
              <item>
                <description>0x00000082</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Enterprise 2015 LTSB N Evaluation</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0000000A</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Enterprise (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000000E</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Enterprise (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_SERVER_CORE_V</b>
                </description>
              </item>
              <item>
                <description>0x00000029</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Enterprise without Hyper-V (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_SERVER_IA64</b>
                </description>
              </item>
              <item>
                <description>0x0000000F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Enterprise for Itanium-based Systems</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ENTERPRISE_SERVER_V</b>
                </description>
              </item>
              <item>
                <description>0x00000026</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Enterprise without Hyper-V (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL</b>
                </description>
              </item>
              <item>
                <description>0x0000003C</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Server Solution Additional</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC</b>
                </description>
              </item>
              <item>
                <description>0x0000003E</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Server Solution Additional SVC</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT</b>
                </description>
              </item>
              <item>
                <description>0x0000003B</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Server Solution Management</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC</b>
                </description>
              </item>
              <item>
                <description>0x0000003D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Server Solution Management SVC</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_BASIC</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Home Basic</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_BASIC_E</b>
                </description>
              </item>
              <item>
                <description>0x00000043</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not supported</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_BASIC_N</b>
                </description>
              </item>
              <item>
                <description>0x00000005</description>
              </item>
            </list>
          </description>
          <description>
            <para>Home Basic N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_PREMIUM</b>
                </description>
              </item>
              <item>
                <description>0x00000003</description>
              </item>
            </list>
          </description>
          <description>
            <para>Home Premium</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_PREMIUM_E</b>
                </description>
              </item>
              <item>
                <description>0x00000044</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not supported</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_PREMIUM_N</b>
                </description>
              </item>
              <item>
                <description>0x0000001A</description>
              </item>
            </list>
          </description>
          <description>
            <para>Home Premium N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_PREMIUM_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000022</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Home Server 2011</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HOME_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000013</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Storage Server 2008 R2 Essentials</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_HYPERV</b>
                </description>
              </item>
              <item>
                <description>0x0000002A</description>
              </item>
            </list>
          </description>
          <description>
            <para>Microsoft Hyper-V Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_IOTUAP</b>
                </description>
              </item>
              <item>
                <description>0x0000007B</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 IoT Core</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_IOTUAPCOMMERCIAL</b>
                </description>
              </item>
              <item>
                <description>0x00000083</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 IoT Core Commercial</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT</b>
                </description>
              </item>
              <item>
                <description>0x0000001E</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Business Server Management Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Business Server Messaging Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x0000001F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Essential Business Server Security Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MOBILE_CORE</b>
                </description>
              </item>
              <item>
                <description>0x00000068</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Mobile</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MOBILE_ENTERPRISE</b>
                </description>
              </item>
              <item>
                <description>0x00000085</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Mobile Enterprise</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MULTIPOINT_PREMIUM_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0000004D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows MultiPoint Server Premium (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_MULTIPOINT_STANDARD_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0000004C</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows MultiPoint Server Standard (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PRO_WORKSTATION</b>
                </description>
              </item>
              <item>
                <description>0x000000A1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Pro for Workstations</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PRO_WORKSTATION_N</b>
                </description>
              </item>
              <item>
                <description>0x000000A2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Pro for Workstations N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PROFESSIONAL</b>
                </description>
              </item>
              <item>
                <description>0x00000030</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10  Pro</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PROFESSIONAL_E</b>
                </description>
              </item>
              <item>
                <description>0x00000045</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not supported</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PROFESSIONAL_N</b>
                </description>
              </item>
              <item>
                <description>0x00000031</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows 10 Pro N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_PROFESSIONAL_WMC</b>
                </description>
              </item>
              <item>
                <description>0x00000067</description>
              </item>
            </list>
          </description>
          <description>
            <para>Professional with Media Center</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SB_SOLUTION_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000032</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Small Business Server 2011 Essentials</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SB_SOLUTION_SERVER_EM</b>
                </description>
              </item>
              <item>
                <description>0x00000036</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server For SB Solutions EM</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SERVER_FOR_SB_SOLUTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00000033</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server For SB Solutions</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM</b>
                </description>
              </item>
              <item>
                <description>0x00000037</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server For SB Solutions EM</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SERVER_FOR_SMALLBUSINESS</b>
                </description>
              </item>
              <item>
                <description>0x00000018</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Server 2008 for Windows Essential Server Solutions</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SERVER_FOR_SMALLBUSINESS_V</b>
                </description>
              </item>
              <item>
                <description>0x00000023</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Server 2008 without Hyper-V for Windows Essential Server Solutions</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SERVER_FOUNDATION</b>
                </description>
              </item>
              <item>
                <description>0x00000021</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Foundation</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SMALLBUSINESS_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000009</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows Small Business Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SMALLBUSINESS_SERVER_PREMIUM</b>
                </description>
              </item>
              <item>
                <description>0x00000019</description>
              </item>
            </list>
          </description>
          <description>
            <para>Small Business Server Premium</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000003F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Small Business Server Premium (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_SOLUTION_EMBEDDEDSERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000038</description>
              </item>
            </list>
          </description>
          <description>
            <para>Windows MultiPoint Server</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_EVALUATION_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0000004F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard (evaluation installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000007</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard (full installation. For Server Core installations of Windows Server 2012 and later, use the method, <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh846315(v=vs.85)">Determining whether Server Core is running</a>.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER_CORE </b>
                </description>
              </item>
              <item>
                <description>0x0000000D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard (core installation, Windows Server 2008 R2 and earlier)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER_CORE_V</b>
                </description>
              </item>
              <item>
                <description>0x00000028</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard without Hyper-V (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER_V</b>
                </description>
              </item>
              <item>
                <description>0x00000024</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Standard without Hyper-V</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER_SOLUTIONS</b>
                </description>
              </item>
              <item>
                <description>0x00000034</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Solutions Premium</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE</b>
                </description>
              </item>
              <item>
                <description>0x00000035</description>
              </item>
            </list>
          </description>
          <description>
            <para>Server Solutions Premium (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STARTER</b>
                </description>
              </item>
              <item>
                <description>0x0000000B</description>
              </item>
            </list>
          </description>
          <description>
            <para>Starter</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STARTER_E</b>
                </description>
              </item>
              <item>
                <description>0x00000042</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not supported</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STARTER_N</b>
                </description>
              </item>
              <item>
                <description>0x0000002F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Starter N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_ENTERPRISE_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000017</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Enterprise</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000002E</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Enterprise (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_EXPRESS_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000014</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Express</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_EXPRESS_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000002B</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Express (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000060</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Standard (evaluation installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_STANDARD_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000015</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Standard</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_STANDARD_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000002C</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Standard (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x0000005F</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Workgroup (evaluation installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_WORKGROUP_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000016</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Workgroup</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_STORAGE_WORKGROUP_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000002D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Storage Server Workgroup (core installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ULTIMATE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Ultimate</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ULTIMATE_E</b>
                </description>
              </item>
              <item>
                <description>0x00000047</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not supported</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_ULTIMATE_N</b>
                </description>
              </item>
              <item>
                <description>0x0000001C</description>
              </item>
            </list>
          </description>
          <description>
            <para>Ultimate N</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_UNDEFINED</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>An unknown product</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_WEB_SERVER</b>
                </description>
              </item>
              <item>
                <description>0x00000011</description>
              </item>
            </list>
          </description>
          <description>
            <para>Web Server (full installation)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PRODUCT_WEB_SERVER_CORE</b>
                </description>
              </item>
              <item>
                <description>0x0000001D</description>
              </item>
            </list>
          </description>
          <description>
            <para>Web Server (core installation)</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. This function fails if one of the input parameters is invalid.</para>
    </returns>
    <remarks>
      <para>To detect whether a server role or feature is installed, use the  <a href="https://docs.microsoft.com//windows/desktop/WmiSdk/win32-serverfeature">Server Feature</a> WMI provider.</para>
      <para>Subsequent releases of Windows will map the product types it supports to the set of product types supported by each supported previous release of Windows, back to version 6.0.0.0. Therefore, an application that does an equality test for any of these values will continue to work on future releases, even when new product types are added.</para>
      <para>PRODUCT_*_SERVER_CORE values are not returned in Windows Server 2012, and later. For  example, the base server edition, Server Datacenter, is used to build the two different installation options: "full server" and "core server". With Windows Server 2012,  <b>GetProductInfo</b> will return PRODUCT_DATACENTER regardless of the option used during product installation. As noted above, for Server Core installations of Windows Server 2012 and later, use the method <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/hh846315(v=vs.85)">Determining whether Server Core is running</a>.</para>
      <para>The following table indicates the product types that were introduced in 6.1.0.0, and what they will map to if <b>GetProductInfo</b> is called with version 6.0.0.0 on a 6.1.0.0 system.</para>
      <list type="table">
        <listheader>
          <description>New for 6.1.0.0</description>
          <description>Value returned with 6.0.0.0</description>
        </listheader>
        <item>
          <description>PRODUCT_PROFESSIONAL</description>
          <description>PRODUCT_BUSINESS</description>
        </item>
        <item>
          <description>PRODUCT_PROFESSIONAL_N</description>
          <description>PRODUCT_BUSINESS_N</description>
        </item>
        <item>
          <description>PRODUCT_STARTER_N</description>
          <description>PRODUCT_STARTER</description>
        </item>
      </list>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectory">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectoryA">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectoryW">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectory">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectoryA">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemDirectoryW">
    <summary>
      <para>Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the system directory is the root directory. For example, if the system directory is named Windows\System32 on drive C, the path of the system directory retrieved by this function is C:\Windows\System32.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string copied to the buffer, not including the terminating null character. If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications should not create files in the system directory. If the user is running a shared version of the operating system, the application does not have write access to the system directory.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SetCurrentDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemFirmwareTable">
    <summary>
      <para>Retrieves the specified firmware table from the firmware table provider.</para>
    </summary>
    <param name="FirmwareTableProviderSignature">
      <para>The identifier of the firmware table provider to which the query is to be directed. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>'ACPI'</description>
          <description>The ACPI firmware table provider.</description>
        </item>
        <item>
          <description>'FIRM'</description>
          <description>The raw firmware table provider.</description>
        </item>
        <item>
          <description>'RSMB'</description>
          <description>The raw SMBIOS firmware table provider.</description>
        </item>
      </list>
    </param>
    <param name="FirmwareTableID">
      <para>The identifier of the firmware table. This identifier is little endian, you must reverse the characters in the string.</para>
      <para>For example, FACP is an ACPI provider, as described in the Signature field of the DESCRIPTION_HEADER structure in the ACPI specification (see <a href="http://www.acpi.info/">http://www.acpi.info</a>). Therefore, use 'PCAF' to specify the FACP table, as shown in the following example:</para>
      <para>
        <code>retVal = GetSystemFirmwareTable('ACPI', 'PCAF', pBuffer, BUFSIZE);</code>
      </para>
      <para>For more information, see the Remarks section of the <see cref="EnumSystemFirmwareTables" /> function.</para>
    </param>
    <param name="pFirmwareTableBuffer">
      <para>A pointer to a buffer that receives the requested firmware table. If this parameter is <b>NULL</b>, the return value is the required buffer size.</para>
      <para>For more information on the contents of this buffer, see the Remarks section.</para>
    </param>
    <param name="BufferSize">
      <para>The size of the <i>pFirmwareTableBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes written to the buffer. This value will always be less than or equal to <i>BufferSize</i>.</para>
      <para>If the function fails because the buffer is not large enough, the return value is the required buffer size, in bytes. This value is always greater than <i>BufferSize</i>.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can access the System Management BIOS (SMBIOS) information by declaring the <b>smbios</b> restricted capability in the app manifest.
See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-smbios-information-from-a-universal-windows-app">Access SMBIOS information from a Universal Windows App</a> for details. Only raw SMBIOS (RSMB) firmware tables can be accessed from a Universal Windows app.</para>
      <para>As of Windows Server 2003 with Service Pack 1 (SP1), applications cannot access the \Device\PhysicalMemory object. Access to this object is limited to kernel-mode drivers. This change affects applications read System Management BIOS (SMBIOS) or other BIOS data stored in the lowest 1MB of physical memory. Applications have the following alternatives to read data from low physical memory:</para>
      <list type="bullet">
        <item>
          <description>Retrieve the SMBIOS properties using WMI. Many individual properties are contained in the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-provider">Win32 classes</a>. You can also retrieve the raw SMBIOS data in a single buffer using the <b>MSSMBios_RawSMBiosTables</b> class.</description>
        </item>
        <item>
          <description>Use the <b>GetSystemFirmwareTable</b> function to read the raw SMBIOS firmware table.</description>
        </item>
      </list>
      <para>There is no way for applications to write to low physical memory.</para>
      <para>The raw SMBIOS table provider ('RSMB') retrieves the contents of the raw SMBIOS firmware table. The <i>pFirmwareTableBuffer</i> buffer receives the following data:</para>
      <code>#include &lt;windows.h&gt;

struct RawSMBIOSData
{
    BYTE    Used20CallingMethod;
    BYTE    SMBIOSMajorVersion;
    BYTE    SMBIOSMinorVersion;
    BYTE    DmiRevision;
    DWORD    Length;
    BYTE    SMBIOSTableData[];
};

</code>
      <para>The raw firmware table provider ('FIRM') retrieves the contents of the specified physical address range. The function returns the size of the address range.</para>
      <para>The ACPI table provider ('ACPI') retrieves the contents of the specified ACPI table. Because OEMs can include ACPI firmware tables that are not listed in the ACPI specification, you should first call <see cref="EnumSystemFirmwareTables" /> to enumerate all ACPI tables that are currently on the system.</para>
      <para>For ACPI, if the system contains multiple tables with the same name, they are all enumerated with <see cref="EnumSystemFirmwareTables" />. However, <b>GetSystemFirmwareTable</b> retrieves only the first table in the list with this name.</para>
      <h4>Examples</h4>
      <para>The following example illustrates retrieving the SMBIOS table.</para>
      <code>DWORD error = ERROR_SUCCESS;
DWORD smBiosDataSize = 0;
RawSMBIOSData* smBiosData = NULL; // Defined in this link
DWORD bytesWritten = 0;

// Query size of SMBIOS data.
smBiosDataSize = GetSystemFirmwareTable('RSMB', 0, NULL, 0);

// Allocate memory for SMBIOS data
smBiosData = (RawSMBIOSData*) HeapAlloc(GetProcessHeap(), 0, smBiosDataSize);
if (!smBiosData) {
    error = ERROR_OUTOFMEMORY;
    goto exit;
}

// Retrieve the SMBIOS table
bytesWritten = GetSystemFirmwareTable('RSMB', 0, smBiosData, smBiosDataSize);

if (bytesWritten != smBiosDataSize) {
    error = ERROR_INVALID_DATA;
    goto exit;
}

// Process the SMBIOS data and free the memory under an exit label

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-smbios-information-from-a-universal-windows-app">Access SMBIOS information from a Universal Windows App</seealso>
    <seealso cref="EnumSystemFirmwareTables" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemInfo">
    <summary>
      <para>Retrieves information about the current system.</para>
      <para>To retrieve accurate information for an application running on WOW64, call the
<see cref="GetNativeSystemInfo" /> function.</para>
    </summary>
    <param name="lpSystemInfo">
      <para>A pointer to a
<see cref="SYSTEM_INFO" /> structure that receives the information.</para>
    </param>
    <seealso cref="GetNativeSystemInfo" />
    <seealso cref="SYSTEM_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemTime">
    <summary>
      <para>Retrieves the current system date and time in Coordinated Universal Time (UTC) format.</para>
      <para>To retrieve the current system date and time in local time, use the <see cref="GetLocalTime" /> function.</para>
    </summary>
    <param name="lpSystemTime">
      <para>A pointer to a
<see cref="SYSTEMTIME" /> structure to receive the current system date and time. The <i>lpSystemTime</i> parameter must not be <b>NULL</b>. Using <b>NULL</b> will result in an access violation.</para>
    </param>
    <remarks>
      <para>To set the current system date and time, use the <see cref="SetSystemTime" /> function.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    SYSTEMTIME st, lt;

    GetSystemTime(&amp;amp;amp;amp;amp;amp;st);
    GetLocalTime(&amp;amp;amp;amp;amp;amp;lt);

    printf("The system time is: %02d:%02d\n", st.wHour, st.wMinute);
    printf(" The local time is: %02d:%02d\n", lt.wHour, lt.wMinute);
}
</code>
      <code>// Sample output

The system time is: 19:34
 The local time is: 12:34
</code>
      <para>For more information about this example, see
<see cref="SYSTEMTIME" />.</para>
    </remarks>
    <seealso cref="GetLocalTime" />
    <seealso cref="GetSystemTimeAdjustment" />
    <seealso cref="GetSystemTimeAsFileTime" />
    <seealso cref="SYSTEMTIME" />
    <seealso cref="SetSystemTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetSystemTimeAdjustment">
    <summary>
      <para>Determines whether the system is applying periodic time adjustments to its time-of-day clock, and obtains the value and period of any such adjustments.</para>
    </summary>
    <param name="lpTimeAdjustment">
      <para>A pointer to a variable that the function sets to the number of <i>lpTimeIncrement</i> 100-nanosecond units added to the time-of-day clock for every  period of time which actually passes as counted by the system. This value only has meaning if <i>lpTimeAdjustmentDisabled</i> is <b>FALSE</b>.</para>
    </param>
    <param name="lpTimeIncrement">
      <para>A pointer to a variable that the function sets to the interval in 100-nanosecond units at which the system will add <i>lpTimeAdjustment</i> to the time-of-day clock. This value only has meaning if <i>lpTimeAdjustmentDisabled</i> is <b>FALSE</b>.</para>
    </param>
    <param name="lpTimeAdjustmentDisabled">
      <para>A pointer to a variable that the function sets to indicate whether periodic time adjustment is in effect.</para>
      <para>A value of <b>TRUE</b> indicates that periodic time adjustment is disabled, and the system time-of-day clock advances at the normal rate. In this mode, the system may adjust the time of day using its own internal time synchronization mechanisms. These internal time synchronization mechanisms may cause the time-of-day clock to change during the normal course of the system operation, which can include noticeable jumps in time as deemed necessary by the system.</para>
      <para>A value of <b>FALSE</b> indicates that periodic time adjustment is being used to adjust the time-of-day clock. For each <i>lpTimeIncrement</i> period of time that actually passes, <i>lpTimeAdjustment</i> will be added to the time of day.  If the <i>lpTimeAdjustment</i> value is smaller than <i>lpTimeIncrement</i>, the system time-of-day clock will advance at a rate slower than normal. If the <i>lpTimeAdjustment</i> value is larger than <i>lpTimeIncrement</i>, the time-of-day clock will advance at a rate faster than normal. If <i>lpTimeAdjustment</i> equals <i>lpTimeIncrement</i>, the time-of-day clock will advance at its normal speed.  The <i>lpTimeAdjustment</i>  value can be set by calling <see cref="SetSystemTimeAdjustment" />. The <i>lpTimeIncrement</i> value is fixed by the system upon start, and does not change during system operation. In this mode, the system will not interfere with the time adjustment scheme, and will not attempt to synchronize time of day on its own via other techniques.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetSystemTimeAdjustment</b> and <see cref="SetSystemTimeAdjustment" /> functions can be used to support algorithms that want to synchronize the time-of-day clock, reported by <see cref="GetSystemTime" /> and <see cref="GetLocalTime" />, with another time source by using a periodic time adjustment.</para>
      <para>The <b>GetSystemTimeAdjustment</b> function lets a caller determine whether periodic time adjustment is enabled, and if it is, obtain the amount of each adjustment and the time between adjustments. The <see cref="SetSystemTimeAdjustment" /> function lets a caller enable or disable periodic time adjustment, and set the value of the adjusting increment.</para>
    </remarks>
    <seealso cref="GetLocalTime" />
    <seealso cref="GetSystemTime" />
    <seealso cref="SetSystemTimeAdjustment" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetSystemTimeAsFileTime">
    <summary>
      <para>Retrieves the current system date and time. The information is in Coordinated Universal Time (UTC) format.</para>
    </summary>
    <param name="lpSystemTimeAsFileTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure to receive the current system date and time in UTC format.</para>
    </param>
    <seealso cref="FILETIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/file-times">File Times</seealso>
    <seealso cref="GetSystemTime" />
    <seealso cref="SYSTEMTIME" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</seealso>
    <seealso cref="SystemTimeToFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.GetSystemTimePreciseAsFileTime">
    <summary>
      <para>The
<b>GetSystemTimePreciseAsFileTime</b></para>
      <para>function retrieves the current system date and time with the highest possible level of precision (&lt;1us). The
retrieved information is in Coordinated Universal Time (UTC) format.</para>
    </summary>
    <param name="lpSystemTimeAsFileTime">
      <para>Type: <b>LPFILETIME</b></para>
      <para>A pointer to a <see cref="FILETIME" /> structure that contains the
current system date and time in UTC format.</para>
    </param>
    <remarks>
      <para>
        <b>Note</b>  This function is best suited for high-resolution time-of-day measurements, or time stamps that are synchronized to UTC. For high-resolution interval measurements, use <see cref="QueryPerformanceCounter" /> or <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-kequeryperformancecounter">KeQueryPerformanceCounter</a>. For more info about acquiring high-resolution time stamps, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/acquiring-high-resolution-time-stamps">Acquiring high-resolution time stamps</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetSystemWindowsDirectory">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemWindowsDirectoryA">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemWindowsDirectoryW">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemWindowsDirectory">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemWindowsDirectoryA">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetSystemWindowsDirectoryW">
    <summary>
      <para>Retrieves the path of the shared Windows directory on a multi-user system.</para>
      <para>This function is provided primarily for compatibility. Applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the path. This path does not end with a backslash unless the Windows directory is the root directory. For example, if the Windows directory is named Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in <b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On a system that is running Terminal Services, each user has a unique Windows directory. The system Windows directory is shared by all users, so it is the directory where an application should store initialization and help files that apply to all users.</para>
      <para>With Terminal Services, the
<b>GetSystemWindowsDirectory</b> function retrieves the path of the system Windows directory, while the
<see cref="GetWindowsDirectory" /> function retrieves the path of a Windows directory that is private for each user. On a single-user system,
<b>GetSystemWindowsDirectory</b> is the same as
<b>GetWindowsDirectory</b>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetSystemWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="SHGetFolderLocation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetTickCount">
    <summary>
      <para>Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.</para>
    </summary>
    <returns>
      <para>The return value is the number of milliseconds that have elapsed since the system was started.</para>
    </returns>
    <remarks>
      <para>The resolution of the <b>GetTickCount</b> function is limited to the resolution of the system timer, which is typically in the range of  10 milliseconds to 16 milliseconds. The resolution of the <b>GetTickCount</b> function is not affected by adjustments made by the
<see cref="GetSystemTimeAdjustment" /> function.</para>
      <para>The elapsed time is stored as a <b>DWORD</b> value. Therefore, the time will wrap around to zero if the system is run continuously for 49.7 days. To avoid this problem, use the <see cref="GetTickCount64" /> function. Otherwise, check for an overflow condition when comparing times.</para>
      <para>If you need a higher resolution timer, use a
<a href="https://docs.microsoft.com//windows/desktop/Multimedia/multimedia-timers">multimedia timer</a> or a
<a href="https://docs.microsoft.com//windows/desktop/winmsg/about-timers">high-resolution timer</a>.</para>
      <para>To obtain the time elapsed since the computer was started, retrieve the System Up Time counter in the performance data in the registry key <b>HKEY_PERFORMANCE_DATA</b>. The value returned is an 8-byte value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/PerfCtrs/performance-counters-portal">Performance Counters</a>.</para>
      <para>To obtain the time the system has spent in the working state since it was started, use the <see cref="QueryUnbiasedInterruptTime" /> function.</para>
      <para>
        <b>Note</b>  The <see cref="QueryUnbiasedInterruptTime" /> function produces different results on debug ("checked") builds of Windows, because the interrupt-time count and tick count are advanced by approximately 49 days. This helps to identify bugs that might not occur until the system has been running for a long time. The checked build is available to MSDN subscribers through the <a href="https://msdn.microsoft.com/default.aspx">Microsoft Developer Network (MSDN)</a> Web site.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/windows-time">Windows Time</seealso>
  </member>
  <member name="Windows.GetTickCount64">
    <summary>
      <para>Retrieves the number of milliseconds that have elapsed since the system was started.</para>
    </summary>
    <returns>
      <para>The number of milliseconds.</para>
    </returns>
    <remarks>
      <para>The resolution of the <b>GetTickCount64</b> function is limited to the resolution of the system timer, which is typically in the range of  10 milliseconds to 16 milliseconds. The resolution of the <b>GetTickCount64</b> function is not affected by adjustments made by the
<see cref="GetSystemTimeAdjustment" /> function.</para>
      <para>If you need a higher resolution timer, use a
<a href="https://docs.microsoft.com//windows/desktop/Multimedia/multimedia-timers">multimedia timer</a> or a
<a href="https://docs.microsoft.com//windows/desktop/winmsg/about-timers">high-resolution timer</a>.</para>
      <para>To obtain the time the system has spent in the working state since it was started, use the <see cref="QueryUnbiasedInterruptTime" /> function.</para>
      <para>
        <b>Note</b>  The <see cref="QueryUnbiasedInterruptTime" /> function produces different results on debug ("checked") builds of Windows, because the interrupt-time count and tick count are advanced by approximately 49 days. This helps to identify bugs that might not occur until the system has been running for a long time. The checked build is available to MSDN subscribers through the <a href="https://msdn.microsoft.com/default.aspx">Microsoft Developer Network (MSDN)</a> Web site.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/windows-time">Windows Time</seealso>
  </member>
  <member name="Windows.GetVersion">
    <summary>
      <para>
        <b>GetVersion</b> may be altered or unavailable for releases after Windows 8.1. Instead, use the <a href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</a>. For Windows 10 apps, please see <a href="https://docs.microsoft.com//windows/win32/sysinfo/targeting-your-application-at-windows-8-1">Targeting your applications for Windows</a>.</para>
      <para>With the release of Windows 8.1, the behavior of the <b>GetVersion</b> API has changed in the value it will return for the operating system version. The value returned by the <b>GetVersion</b> function now depends on how the application is manifested.</para>
      <para>Applications not manifested for Windows 8.1 or Windows 10 will return the Windows 8 OS version value (6.2).  Once an application is manifested for a given operating system version, <b>GetVersion</b> will always return the version that the application is manifested for in future releases.  To manifest your applications for Windows 8.1 or Windows 10, refer to <a href="https://docs.microsoft.com//windows/desktop/SysInfo/targeting-your-application-at-windows-8-1">Targeting your application for Windows</a>.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value includes the major and minor version numbers of the operating system in the low-order word, and information about the operating system platform in the high-order word.</para>
      <para>For all platforms, the low-order word contains the version number of the operating system. The low-order byte of this word specifies the major version number, in hexadecimal notation. The high-order byte specifies the minor version (revision) number, in hexadecimal notation. The  high-order bit is zero, the next 7 bits represent the build number, and the low-order byte is 5.</para>
    </returns>
    <remarks>
      <para>The
<see cref="GetVersionEx" /> function was developed because many existing applications err when examining the packed <b>DWORD</b> value returned by
<b>GetVersion</b>, transposing the major and minor version numbers.
<b>GetVersionEx</b> forces applications to explicitly examine each element of version information.
<see cref="VerifyVersionInfo" /> eliminates further potential for error by comparing the required system version with the current system version for you.</para>
      <h4>Examples</h4>
      <para>The following code fragment illustrates how to extract information from the
<b>GetVersion</b> return value: <see cref="OSVERSIONINFOEX" /></para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    DWORD dwVersion = 0;
    DWORD dwMajorVersion = 0;
    DWORD dwMinorVersion = 0;
    DWORD dwBuild = 0;

    dwVersion = GetVersion();

    // Get the Windows version.

    dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));

    // Get the build number.

    if (dwVersion &lt; 0x80000000)
        dwBuild = (DWORD)(HIWORD(dwVersion));

    printf("Version is %d.%d (%d)\n",
                dwMajorVersion,
                dwMinorVersion,
                dwBuild);
}

</code>
    </remarks>
    <seealso cref="GetVersionEx" />
    <seealso cref="OSVERSIONINFO" />
    <seealso cref="OSVERSIONINFOEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
    <seealso cref="VerifyVersionInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</seealso>
  </member>
  <member name="Windows.GetVersionEx">
    <summary>
      <para>
        <b>GetVersionExA</b> may be altered or unavailable for releases after Windows 8.1. Instead, use the <a href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</a>. For Windows 10 apps, please see <a href="https://docs.microsoft.com//windows/win32/sysinfo/targeting-your-application-at-windows-8-1">Targeting your applications for Windows</a>.</para>
      <para>With the release of Windows 8.1, the behavior of the <b>GetVersionEx</b> API has changed in the value it will return for the operating system version. The value returned by the <b>GetVersionEx</b> function now depends on how the application is manifested.</para>
      <para>Applications not manifested for Windows 8.1 or Windows 10 will return the Windows 8 OS version value (6.2).  Once an application is manifested for a given operating system version, <b>GetVersionEx</b> will always return the version that the application is manifested for in future releases.  To manifest your applications for Windows 8.1 or Windows 10, refer to <a href="https://docs.microsoft.com//windows/desktop/SysInfo/targeting-your-application-at-windows-8-1">Targeting your application for Windows</a>.</para>
    </summary>
    <param name="lpVersionInformation">
      <para>An
<see cref="OSVERSIONINFO" /> or <see cref="OSVERSIONINFOEX" /> structure that receives the operating system information.</para>
      <para>Before calling the
<b>GetVersionEx</b> function, set the <b>dwOSVersionInfoSize</b> member of the structure as appropriate to indicate which data structure is being passed to this function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The function fails if you specify an invalid value for the <b>dwOSVersionInfoSize</b> member of the
<see cref="OSVERSIONINFO" /> or
<see cref="OSVERSIONINFOEX" /> structure.</para>
    </returns>
    <remarks>
      <para>Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present. This is because the operating system may have had new features added in a redistributable DLL. Rather than using
<b>GetVersionEx</b> to determine the operating system platform or version number, test for the presence of the feature itself. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</a>.</para>
      <para>The <see cref="GetSystemMetrics" /> function provides additional information about the current operating system.</para>
      <list type="table">
        <listheader>
          <description>Product</description>
          <description>Setting</description>
        </listheader>
        <item>
          <description>Windows XP Media Center Edition</description>
          <description>SM_MEDIACENTER</description>
        </item>
        <item>
          <description>Windows XP Starter Edition</description>
          <description>SM_STARTER</description>
        </item>
        <item>
          <description>Windows XP Tablet PC Edition</description>
          <description>SM_TABLETPC</description>
        </item>
        <item>
          <description>Windows Server 2003 R2</description>
          <description>SM_SERVERR2</description>
        </item>
      </list>
      <para>To check for specific operating systems or operating system features, use the <see cref="IsOS" /> function. The <see cref="GetProductInfo" /> function retrieves the product type.</para>
      <para>To retrieve information for the operating system on a remote computer, use the <see cref="NetWkstaGetInfo" /> function, the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-operatingsystem">Win32_OperatingSystem</a> WMI class, or the <a href="https://docs.microsoft.com//windows/desktop/ADSI/iadscomputer-property-methods">OperatingSystem</a> property of the <b>IADsComputer</b> interface.</para>
      <para>To compare the current system version to a required version, use the
<see cref="VerifyVersionInfo" /> function instead of using
<b>GetVersionEx</b> to perform the comparison yourself.</para>
      <para>If compatibility mode is in effect, the <b>GetVersionEx</b> function reports the operating system as it identifies itself, which may not be the operating system that is installed. For example, if compatibility mode is in effect, <b>GetVersionEx</b> reports the operating system that is selected for <a href="https://docs.microsoft.com//previous-versions/bb757005(v=msdn.10)">application compatibility</a>.</para>
      <h4>Examples</h4>
      <para>When using the
<b>GetVersionEx</b> function to determine whether your application is running on a particular version of the operating system, check for version numbers that are greater than or equal to the desired version numbers. This ensures that the test succeeds for later versions of the operating system. For example, if your application requires Windows XP or later, use the following test.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    OSVERSIONINFO osvi;
    BOOL bIsWindowsXPorLater;

    ZeroMemory(&amp;amp;amp;amp;amp;amp;osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&amp;amp;amp;amp;amp;amp;osvi);

    bIsWindowsXPorLater =
       ( (osvi.dwMajorVersion &gt; 5) ||
       ( (osvi.dwMajorVersion == 5) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; (osvi.dwMinorVersion &gt;= 1) ));

    if(bIsWindowsXPorLater)
        printf("The system meets the requirements.\n");
    else printf("The system does not meet the requirements.\n");
}

</code>
      <para>For an example that identifies the current operating system, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetVersionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVersion" />
    <seealso cref="OSVERSIONINFO" />
    <seealso cref="OSVERSIONINFOEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
    <seealso cref="VerifyVersionInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</seealso>
  </member>
  <member name="Windows.GetVersionExA">
    <summary>
      <para>
        <b>GetVersionExA</b> may be altered or unavailable for releases after Windows 8.1. Instead, use the <a href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</a>. For Windows 10 apps, please see <a href="https://docs.microsoft.com//windows/win32/sysinfo/targeting-your-application-at-windows-8-1">Targeting your applications for Windows</a>.</para>
      <para>With the release of Windows 8.1, the behavior of the <b>GetVersionEx</b> API has changed in the value it will return for the operating system version. The value returned by the <b>GetVersionEx</b> function now depends on how the application is manifested.</para>
      <para>Applications not manifested for Windows 8.1 or Windows 10 will return the Windows 8 OS version value (6.2).  Once an application is manifested for a given operating system version, <b>GetVersionEx</b> will always return the version that the application is manifested for in future releases.  To manifest your applications for Windows 8.1 or Windows 10, refer to <a href="https://docs.microsoft.com//windows/desktop/SysInfo/targeting-your-application-at-windows-8-1">Targeting your application for Windows</a>.</para>
    </summary>
    <param name="lpVersionInformation">
      <para>An
<see cref="OSVERSIONINFO" /> or <see cref="OSVERSIONINFOEX" /> structure that receives the operating system information.</para>
      <para>Before calling the
<b>GetVersionEx</b> function, set the <b>dwOSVersionInfoSize</b> member of the structure as appropriate to indicate which data structure is being passed to this function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The function fails if you specify an invalid value for the <b>dwOSVersionInfoSize</b> member of the
<see cref="OSVERSIONINFO" /> or
<see cref="OSVERSIONINFOEX" /> structure.</para>
    </returns>
    <remarks>
      <para>Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present. This is because the operating system may have had new features added in a redistributable DLL. Rather than using
<b>GetVersionEx</b> to determine the operating system platform or version number, test for the presence of the feature itself. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</a>.</para>
      <para>The <see cref="GetSystemMetrics" /> function provides additional information about the current operating system.</para>
      <list type="table">
        <listheader>
          <description>Product</description>
          <description>Setting</description>
        </listheader>
        <item>
          <description>Windows XP Media Center Edition</description>
          <description>SM_MEDIACENTER</description>
        </item>
        <item>
          <description>Windows XP Starter Edition</description>
          <description>SM_STARTER</description>
        </item>
        <item>
          <description>Windows XP Tablet PC Edition</description>
          <description>SM_TABLETPC</description>
        </item>
        <item>
          <description>Windows Server 2003 R2</description>
          <description>SM_SERVERR2</description>
        </item>
      </list>
      <para>To check for specific operating systems or operating system features, use the <see cref="IsOS" /> function. The <see cref="GetProductInfo" /> function retrieves the product type.</para>
      <para>To retrieve information for the operating system on a remote computer, use the <see cref="NetWkstaGetInfo" /> function, the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-operatingsystem">Win32_OperatingSystem</a> WMI class, or the <a href="https://docs.microsoft.com//windows/desktop/ADSI/iadscomputer-property-methods">OperatingSystem</a> property of the <b>IADsComputer</b> interface.</para>
      <para>To compare the current system version to a required version, use the
<see cref="VerifyVersionInfo" /> function instead of using
<b>GetVersionEx</b> to perform the comparison yourself.</para>
      <para>If compatibility mode is in effect, the <b>GetVersionEx</b> function reports the operating system as it identifies itself, which may not be the operating system that is installed. For example, if compatibility mode is in effect, <b>GetVersionEx</b> reports the operating system that is selected for <a href="https://docs.microsoft.com//previous-versions/bb757005(v=msdn.10)">application compatibility</a>.</para>
      <h4>Examples</h4>
      <para>When using the
<b>GetVersionEx</b> function to determine whether your application is running on a particular version of the operating system, check for version numbers that are greater than or equal to the desired version numbers. This ensures that the test succeeds for later versions of the operating system. For example, if your application requires Windows XP or later, use the following test.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    OSVERSIONINFO osvi;
    BOOL bIsWindowsXPorLater;

    ZeroMemory(&amp;amp;amp;amp;amp;amp;osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&amp;amp;amp;amp;amp;amp;osvi);

    bIsWindowsXPorLater =
       ( (osvi.dwMajorVersion &gt; 5) ||
       ( (osvi.dwMajorVersion == 5) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; (osvi.dwMinorVersion &gt;= 1) ));

    if(bIsWindowsXPorLater)
        printf("The system meets the requirements.\n");
    else printf("The system does not meet the requirements.\n");
}

</code>
      <para>For an example that identifies the current operating system, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetVersionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVersion" />
    <seealso cref="OSVERSIONINFO" />
    <seealso cref="OSVERSIONINFOEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
    <seealso cref="VerifyVersionInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</seealso>
  </member>
  <member name="Windows.GetVersionExW">
    <summary>
      <para>
        <b>GetVersionExA</b> may be altered or unavailable for releases after Windows 8.1. Instead, use the <a href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</a>. For Windows 10 apps, please see <a href="https://docs.microsoft.com//windows/win32/sysinfo/targeting-your-application-at-windows-8-1">Targeting your applications for Windows</a>.</para>
      <para>With the release of Windows 8.1, the behavior of the <b>GetVersionEx</b> API has changed in the value it will return for the operating system version. The value returned by the <b>GetVersionEx</b> function now depends on how the application is manifested.</para>
      <para>Applications not manifested for Windows 8.1 or Windows 10 will return the Windows 8 OS version value (6.2).  Once an application is manifested for a given operating system version, <b>GetVersionEx</b> will always return the version that the application is manifested for in future releases.  To manifest your applications for Windows 8.1 or Windows 10, refer to <a href="https://docs.microsoft.com//windows/desktop/SysInfo/targeting-your-application-at-windows-8-1">Targeting your application for Windows</a>.</para>
    </summary>
    <param name="lpVersionInformation">
      <para>An
<see cref="OSVERSIONINFO" /> or <see cref="OSVERSIONINFOEX" /> structure that receives the operating system information.</para>
      <para>Before calling the
<b>GetVersionEx</b> function, set the <b>dwOSVersionInfoSize</b> member of the structure as appropriate to indicate which data structure is being passed to this function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The function fails if you specify an invalid value for the <b>dwOSVersionInfoSize</b> member of the
<see cref="OSVERSIONINFO" /> or
<see cref="OSVERSIONINFOEX" /> structure.</para>
    </returns>
    <remarks>
      <para>Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present. This is because the operating system may have had new features added in a redistributable DLL. Rather than using
<b>GetVersionEx</b> to determine the operating system platform or version number, test for the presence of the feature itself. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</a>.</para>
      <para>The <see cref="GetSystemMetrics" /> function provides additional information about the current operating system.</para>
      <list type="table">
        <listheader>
          <description>Product</description>
          <description>Setting</description>
        </listheader>
        <item>
          <description>Windows XP Media Center Edition</description>
          <description>SM_MEDIACENTER</description>
        </item>
        <item>
          <description>Windows XP Starter Edition</description>
          <description>SM_STARTER</description>
        </item>
        <item>
          <description>Windows XP Tablet PC Edition</description>
          <description>SM_TABLETPC</description>
        </item>
        <item>
          <description>Windows Server 2003 R2</description>
          <description>SM_SERVERR2</description>
        </item>
      </list>
      <para>To check for specific operating systems or operating system features, use the <see cref="IsOS" /> function. The <see cref="GetProductInfo" /> function retrieves the product type.</para>
      <para>To retrieve information for the operating system on a remote computer, use the <see cref="NetWkstaGetInfo" /> function, the <a href="https://docs.microsoft.com//windows/desktop/CIMWin32Prov/win32-operatingsystem">Win32_OperatingSystem</a> WMI class, or the <a href="https://docs.microsoft.com//windows/desktop/ADSI/iadscomputer-property-methods">OperatingSystem</a> property of the <b>IADsComputer</b> interface.</para>
      <para>To compare the current system version to a required version, use the
<see cref="VerifyVersionInfo" /> function instead of using
<b>GetVersionEx</b> to perform the comparison yourself.</para>
      <para>If compatibility mode is in effect, the <b>GetVersionEx</b> function reports the operating system as it identifies itself, which may not be the operating system that is installed. For example, if compatibility mode is in effect, <b>GetVersionEx</b> reports the operating system that is selected for <a href="https://docs.microsoft.com//previous-versions/bb757005(v=msdn.10)">application compatibility</a>.</para>
      <h4>Examples</h4>
      <para>When using the
<b>GetVersionEx</b> function to determine whether your application is running on a particular version of the operating system, check for version numbers that are greater than or equal to the desired version numbers. This ensures that the test succeeds for later versions of the operating system. For example, if your application requires Windows XP or later, use the following test.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    OSVERSIONINFO osvi;
    BOOL bIsWindowsXPorLater;

    ZeroMemory(&amp;amp;amp;amp;amp;amp;osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&amp;amp;amp;amp;amp;amp;osvi);

    bIsWindowsXPorLater =
       ( (osvi.dwMajorVersion &gt; 5) ||
       ( (osvi.dwMajorVersion == 5) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; (osvi.dwMinorVersion &gt;= 1) ));

    if(bIsWindowsXPorLater)
        printf("The system meets the requirements.\n");
    else printf("The system does not meet the requirements.\n");
}

</code>
      <para>For an example that identifies the current operating system, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetVersionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVersion" />
    <seealso cref="OSVERSIONINFO" />
    <seealso cref="OSVERSIONINFOEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/operating-system-version">Operating System Version</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
    <seealso cref="VerifyVersionInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/version-helper-apis">Version Helper functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectory">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectoryA">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectoryW">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectory">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectoryA">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetWindowsDirectoryW">
    <summary>
      <para>Retrieves the
path of the Windows directory.</para>
      <para>This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder
and persistent data in the Application Data folder in the user's profile. For more information, see
<see cref="ShGetFolderPath" />.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the path. This path does not end with a
backslash unless the Windows directory is the root directory. For example, if the Windows directory is named
Windows on drive C, the path of the Windows directory retrieved by this function is C:\Windows. If the system
was installed in the root directory of drive C, the path retrieved is C:.</para>
    </param>
    <param name="uSize">
      <para>The maximum size of the buffer specified by the <i>lpBuffer</i> parameter, in
<b>TCHARs</b>. This value should be set to <b>MAX_PATH</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
<b>TCHARs</b>, not including the terminating null character.</para>
      <para>If the length is greater than the size of the buffer, the return value is the size of the buffer required to
hold the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The Windows directory is the directory where some legacy applications  store initialization and help files. New applications should not store files in the Windows directory; instead, they should store system-wide data in the application's installation directory, and user-specific data in the user's profile.</para>
      <para>If the
user is running a shared version of the system, the Windows directory is guaranteed to be private for each user.</para>
      <para>If an application creates other files that it wants to store on a per-user basis, it should place them in the
directory specified by the HOMEPATH environment variable. This directory will be different for each user, if so
specified by an administrator, through the User Manager administrative tool. HOMEPATH always specifies either the
user's home directory, which is guaranteed to be private for each user, or a default directory (for example,
C:\USERS\DEFAULT) where the user will have all access.</para>
      <para>
        <b>Terminal Services:  </b>If the application is running in a Terminal Services environment, each user has a private Windows directory.
There is also a shared Windows directory for the system. If the application is Terminal-Services-aware (has the
<b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b> flag set in the image header), this
function returns the path of the system Windows directory, just as the
<see cref="GetSystemWindowsDirectory" /> function does.
Otherwise, it retrieves the path of the private Windows directory for the user.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines GetWindowsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetSystemWindowsDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GlobalMemoryStatusEx">
    <summary>
      <para>Retrieves information about the system's current usage of both physical and virtual memory.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a
<see cref="MEMORYSTATUSEX" /> structure that receives information about current memory availability.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>You can use the
<b>GlobalMemoryStatusEx</b> function to determine how much memory your application can allocate without severely impacting other applications.</para>
      <para>The information returned by the
<b>GlobalMemoryStatusEx</b> function is volatile. There is no guarantee that two sequential calls to this function will return the same information.</para>
      <para>The  <b>ullAvailPhys</b> member of the <see cref="MEMORYSTATUSEX" /> structure at <i>lpBuffer</i> includes memory for all NUMA nodes.</para>
      <h4>Examples</h4>
      <para>The following code shows a simple use of the
<b>GlobalMemoryStatusEx</b> function.</para>
      <code>//  Sample output:
//  There is       51 percent of memory in use.
//  There are 2029968 total KB of physical memory.
//  There are  987388 free  KB of physical memory.
//  There are 3884620 total KB of paging file.
//  There are 2799776 free  KB of paging file.
//  There are 2097024 total KB of virtual memory.
//  There are 2084876 free  KB of virtual memory.
//  There are       0 free  KB of extended memory.

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

// Use to convert bytes to KB
#define DIV 1024

// Specify the width of the field in which to print the numbers.
// The asterisk in the format specifier "%*I64d" takes an integer
// argument and uses it to pad and right justify the number.
#define WIDTH 7

void _tmain()
{
  MEMORYSTATUSEX statex;

  statex.dwLength = sizeof (statex);

  GlobalMemoryStatusEx (&amp;amp;amp;amp;amp;amp;statex);

  _tprintf (TEXT("There is  %*ld percent of memory in use.\n"),
            WIDTH, statex.dwMemoryLoad);
  _tprintf (TEXT("There are %*I64d total KB of physical memory.\n"),
            WIDTH, statex.ullTotalPhys/DIV);
  _tprintf (TEXT("There are %*I64d free  KB of physical memory.\n"),
            WIDTH, statex.ullAvailPhys/DIV);
  _tprintf (TEXT("There are %*I64d total KB of paging file.\n"),
            WIDTH, statex.ullTotalPageFile/DIV);
  _tprintf (TEXT("There are %*I64d free  KB of paging file.\n"),
            WIDTH, statex.ullAvailPageFile/DIV);
  _tprintf (TEXT("There are %*I64d total KB of virtual memory.\n"),
            WIDTH, statex.ullTotalVirtual/DIV);
  _tprintf (TEXT("There are %*I64d free  KB of virtual memory.\n"),
            WIDTH, statex.ullAvailVirtual/DIV);

  // Show the amount of extended memory available.

  _tprintf (TEXT("There are %*I64d free  KB of extended memory.\n"),
            WIDTH, statex.ullAvailExtendedVirtual/DIV);
}

</code>
    </remarks>
    <seealso cref="MEMORYSTATUSEX" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/virtual-address-space-and-physical-storage">Virtual Address Space and Physical Storage</seealso>
  </member>
  <member name="Windows.InstallELAMCertificateInfo">
    <summary>
      <para>Installs the certificate information specified in the resource file, which is linked into the ELAM
driver at build time. This API is used by anti-malware vendors to launch the anti-malware software's user-mode
service as protected. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Services/protecting-anti-malware-services-">Protecting Anti-Malware Services</a>.</para>
    </summary>
    <param name="ELAMFile">
      <para>A handle to an ELAM driver file which contains the resource file with the certificate information. The handle
to the ELAM driver file must be opened for read access only and must not be shared for write access.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is TRUE.</para>
      <para>If the function fails, the return value is FALSE. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Anti-malware vendors can use this API to register their anti-malware user-mode service that needs to be
launched as protected.  Note that the file handle supplied in the <i>hElamFile</i> parameter must be opened for read access
only and must not be shareable for write access.</para>
      <para>For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Services/protecting-anti-malware-services-">Protecting Anti-Malware Services</a>.</para>
      <h4>Examples</h4>
      <para>Code example:</para>
      <code>HANDLE FileHandle = NULL;

FileHandle = CreateFile(&lt;Insert Elam driver file name&gt;,
                        FILE_READ_DATA,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

if (InstallElamCertificateInfo(FileHandle) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}
</code>
    </remarks>
  </member>
  <member name="Windows.IsUserCetAvailableInEnvironment">
    <summary>
      <para>Queries whether user-mode Hardware-enforced Stack Protection is available for the specified environment.</para>
    </summary>
    <param name="UserCetEnvironment">
      <para>The environment to query. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>USER_CET_ENVIRONMENT_WIN32_PROCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000000UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>The Win32 environment.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>USER_CET_ENVIRONMENT_SGX2_ENCLAVE</b>
                </description>
              </item>
              <item>
                <description>0x00000002UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>The Intel Software Guard Extensions 2 (SGX2) enclave environment.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>USER_CET_ENVIRONMENT_VBS_ENCLAVE</b>
                </description>
              </item>
              <item>
                <description>0x00000010UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>The virtualization-based security (VBS) enclave environment.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>USER_CET_ENVIRONMENT_VBS_BASIC_ENCLAVE</b>
                </description>
              </item>
              <item>
                <description>0x00000011UL</description>
              </item>
            </list>
          </description>
          <description>
            <para>The virtualization-based security (VBS) basic enclave environment.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>TRUE if user-mode Hardware-enforced Stack Protection is available for the specified environment, FALSE otherwise.</para>
    </returns>
  </member>
  <member name="Windows.SetComputerName">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameA">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameW">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameEx">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameExA">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameExW">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameEx">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameExA">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameExW">
    <summary>
      <para>Sets a new NetBIOS or DNS name for the local computer. Name changes made by
<b>SetComputerNameEx</b> do not take effect until the user restarts the computer.</para>
    </summary>
    <param name="NameType">
      <para>The type of name to be set. This parameter can be one of the following values from the
<see cref="COMPUTER_NAME_FORMAT" /> enumeration type.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsDomain</b>
          </description>
          <description>
            <para>Sets the primary DNS suffix of the computer.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalDnsHostname</b>
          </description>
          <description>
            <para>Sets the NetBIOS and the Computer Name (the first label of the full DNS name) to the name specified in <i>lpBuffer</i>. If the name exceeds MAX_COMPUTERNAME_LENGTH characters, the NetBIOS name is truncated to MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>ComputerNamePhysicalNetBIOS</b>
          </description>
          <description>
            <para>Sets the NetBIOS name to the name specified in <i>lpBuffer</i>. The name cannot exceed MAX_COMPUTERNAME_LENGTH characters, not including the terminating null character.</para>
            <para>Warning: Using this option to set the NetBIOS name breaks the convention of interdependent NetBIOS and DNS names. Applications that use the
<see cref="DnsHostnameToComputerName" /> function to derive the NetBIOS name from the first label of the DNS name will fail if this convention is broken.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>The new name. The name cannot include control characters, leading or trailing spaces, or any of the following characters: " / \ [ ] : | &lt; &gt; + = ; , ?</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>SetComputerNameEx</b> can set the Computer Name (the first label of the full DNS name) or the primary DNS suffix of the local computer. It cannot set a fully qualified DNS name in one call.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerNameEx</b> sets NetBIOS or DNS name of the local computer, not that of the cluster virtual server.</para>
      <para>The process that calls the
<b>SetComputerNameEx</b> function must have administrator privileges on the local computer.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMPUTER_NAME_FORMAT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="DnsHostnameToComputerName" />
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerName">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameA">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetComputerNameW">
    <summary>
      <para>Sets a new NetBIOS name for the local computer. The name is stored in the registry and the name change takes effect the next time the user restarts the computer.</para>
      <para>If the local computer is a node in a cluster,
<b>SetComputerName</b> sets NetBIOS name of the local computer, not that of the cluster virtual server.</para>
      <para>To set the DNS host name or the DNS domain name, call the
<see cref="SetComputerNameEx" /> function.</para>
    </summary>
    <param name="lpComputerName">
      <para>The computer name that will take effect the next time the computer is started. The name must not be longer than MAX_COMPUTERNAME_LENGTH characters.</para>
      <para>The standard character set includes letters, numbers, and the following symbols: ! @ # $ % ^ &amp; ' ) ( . - _ { } ~ . If this parameter contains one or more characters that are outside the standard character set,
<b>SetComputerName</b> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications using this function must have administrator rights.</para>
      <blockquote>
        <para>[!NOTE]
The sysinfoapi.h header defines SetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerName" />
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.SetLocalTime">
    <summary>
      <para>Sets the current local time and date.</para>
    </summary>
    <param name="lpSystemTime">
      <para>A pointer to a
<see cref="SYSTEMTIME" /> structure that contains the new local date and time.</para>
      <para>The <b>wDayOfWeek</b> member of the
<see cref="SYSTEMTIME" /> structure is ignored.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The calling process must have the SE_SYSTEMTIME_NAME privilege. This privilege is disabled by default. The
<b>SetLocalTime</b> function enables the SE_SYSTEMTIME_NAME privilege before changing the local time and disables the privilege before returning. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>The system uses UTC internally. Therefore, when you call
<b>SetLocalTime</b>, the system uses the current time zone information to perform the conversion, including the daylight saving time setting. Note that the system uses the daylight saving time setting of the current time, not the new time you are setting. Therefore, to ensure the correct result, call
<b>SetLocalTime</b> a second time, now that the first call has updated the daylight saving time setting.</para>
    </remarks>
    <seealso cref="GetLocalTime" />
    <seealso cref="GetSystemTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/local-time">Local Time</seealso>
    <seealso cref="SYSTEMTIME" />
    <seealso cref="SetSystemTimeAdjustment" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.SetSystemTime">
    <summary>
      <para>Sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).</para>
    </summary>
    <param name="lpSystemTime">
      <para>A pointer to a
<see cref="SYSTEMTIME" /> structure that contains the new system date and time.</para>
      <para>The <b>wDayOfWeek</b> member of the
<see cref="SYSTEMTIME" /> structure is ignored.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The calling process must have the SE_SYSTEMTIME_NAME privilege. This privilege is disabled by default. The
<b>SetSystemTime</b> function enables the SE_SYSTEMTIME_NAME privilege before changing the system time and disables the privilege before returning. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
    </remarks>
    <seealso cref="GetSystemTime" />
    <seealso cref="SYSTEMTIME" />
    <seealso cref="SetSystemTimeAdjustment" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-time">System Time</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.SetSystemTimeAdjustmentPrecise">
    <summary>
      <para>Enables or disables periodic time adjustments to the system's time-of-day clock. When enabled, such time adjustments can be used to synchronize the time of day with some other source of time information.</para>
    </summary>
    <param name="dwTimeAdjustment">
      <para>Supplies the adjusted clock update frequency.</para>
    </param>
    <param name="bTimeAdjustmentDisabled">
      <para>Supplies a flag which specifies the time adjustment mode that the system is to use.</para>
      <para>A value of <b>TRUE</b> indicates that the system should synchronize time-of-day using its own internal mechanisms. In this case, the value of <i>dwTimeAdjustment</i> is ignored.</para>
      <para>A value of <b>FALSE</b> indicates that the application is in control, and that the specified value of <i>dwTimeAdjustment</i> is to be added to the time-of-day clock at each clock update interrupt.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is non-zero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. One way the function can fail is if the caller does not possess the SE_SYSTEMTIME_NAME privilege.</para>
    </returns>
    <remarks>
      <para>To use this function, the caller must have system-time privilege (SE_SYSTEMTIME_NAME). This privilege is disabled by default. Use the
<see cref="AdjustTokenPrivileges" /> function to enable the privilege before calling
this function, then disable the privilege after the function call. For more information, see
the code example below.</para>
      <h4>Examples</h4>
      <para>This sample demonstrates how to enable system-time privileges, adjust the system clock using <see cref="GetSystemTimeAdjustmentPrecise" /> and <b>SetSystemTimeAdjustmentPrecise</b>, and how to neatly print the current system-time adjustments.</para>
      <code>
/******************************************************************
*
* ObtainRequiredPrivileges
*
* Enables system time adjustment privilege.
*
******************************************************************/
HRESULT
ObtainRequiredPrivileges()
{
    HRESULT hr;
    HANDLE hProcToken = NULL;
    TOKEN_PRIVILEGES tp = {0};
    LUID luid;

    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &amp;amp;amp;amp;amp;amp;luid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        printf("Failed to lookup privilege value. hr=0x%08x\n", hr);
        return hr;
    }

    // get the token for our process
    if (!OpenProcessToken(GetCurrentProcess(),
    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
    &amp;amp;amp;amp;amp;amp;hProcToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        printf("Failed to open process token. hr=0x%08x\n", hr);
        return hr;
    }

    // Enable just the SYSTEMTIME privilege
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hProcToken, FALSE, &amp;amp;amp;amp;amp;amp;tp, 0, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        printf("Failed to adjust process token privileges. hr=0x%08x\n", hr);
    }
    else
    {
        hr = S_OK;
        printf("Added SYSTEMTIME privilege to the process token\n");
    }

    if (NULL != hProcToken)
    {
        CloseHandle(hProcToken);
    }
    return hr;
}

/******************************************************************
*
* PrintCurrentClockAdjustments
*
* Prints current values of the system time adjustments.
*
******************************************************************/
void
PrintCurrentClockAdjustments()
{
    // More granular clock adjustments
    DWORD64 ullCurrentAdjustment = 0;
    DWORD64 ullTimeIncrement = 0;
    BOOL bEnabledPrecise = 0;
    HRESULT hrPrecise = S_OK;

    // Legacy clock adjustments
    DWORD dwCurrentAdjustment = 0;
    DWORD dwTimeIncrement = 0;
    BOOL bEnabled = 0;
    HRESULT hr = S_OK;

    if (!GetSystemTimeAdjustmentPrecise(&amp;amp;amp;amp;amp;amp;ullCurrentAdjustment, &amp;amp;amp;amp;amp;amp;ullTimeIncrement, &amp;amp;amp;amp;amp;amp;bEnabledPrecise))
    {
        hrPrecise = HRESULT_FROM_WIN32(GetLastError());
    }

    if (!GetSystemTimeAdjustment(&amp;amp;amp;amp;amp;amp;dwCurrentAdjustment, &amp;amp;amp;amp;amp;amp;dwTimeIncrement, &amp;amp;amp;amp;amp;amp;bEnabled))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    printf("Precise_ADJ:%I64u Precise_INCR:%I64u Precise_EN:%d Precise_hr:0x%08x ADJ:%u INCR:%u EN:%d hr:0x%08x\n",
            ullCurrentAdjustment, ullTimeIncrement, bEnabledPrecise, hrPrecise,
            dwCurrentAdjustment, dwTimeIncrement, bEnabled, hr);
}

/******************************************************************
*
* RunNewAdjustmentSequence
*
* Adjust the system time using high-resolution
* GetSystemTimeAdjustmentPrecise() and SetSystemTimeAdjustmentPrecise() API.
*
******************************************************************/
void
RunNewAdjustmentSequence(DWORD dwPPMAdjustment)
{
    DWORD64 ullCurrentAdjustment = 0;
    DWORD64 ullTimeIncrement = 0;
    BOOL bEnabledPrecise = 0;
    LARGE_INTEGER liPerfCounterFrequency = {0};
    DWORD dwNewAdjustmentUnits;
    const DWORD cMicroSecondsPerSecond = 1000000;

    if (dwPPMAdjustment &gt; 1000)
    {
        printf("Adjustment too large. Skipping new adjustment sequence.\n");
        return;
    }

    printf("Starting adjustment sequence using new API...\n");

    if (!GetSystemTimeAdjustmentPrecise(&amp;amp;amp;amp;amp;amp;ullCurrentAdjustment, &amp;amp;amp;amp;amp;amp;ullTimeIncrement, &amp;amp;amp;amp;amp;amp;bEnabledPrecise))
    {
        printf("Failed to read the system time adjustment. Adjustment sequence aborted. hr:0x%08x\n",
        HRESULT_FROM_WIN32(GetLastError()));
        return;
    }

    (void)QueryPerformanceFrequency(&amp;amp;amp;amp;amp;amp;liPerfCounterFrequency);
    printf("System Performance Counter Frequency: %I64u\n",
    liPerfCounterFrequency.QuadPart);


    dwNewAdjustmentUnits = (DWORD)(((float) dwPPMAdjustment * liPerfCounterFrequency.QuadPart/ cMicroSecondsPerSecond));

    printf("Adjusting the system clock by +%d PPM (+%d new units)\n",
    dwPPMAdjustment, dwNewAdjustmentUnits);

    if (!SetSystemTimeAdjustmentPrecise(ullCurrentAdjustment + dwNewAdjustmentUnits, FALSE))
    {
        printf("Failed to set the system time adjustment. hr:0x%08x\n",
        HRESULT_FROM_WIN32(GetLastError()));
    }

    PrintCurrentClockAdjustments();

    printf("Restoring system clock adjustment settings\n");

    if (!SetSystemTimeAdjustmentPrecise(ullCurrentAdjustment, FALSE))
    {
        printf("Failed to set the system time adjustment. hr:0x%08x\n",
        HRESULT_FROM_WIN32(GetLastError()));
    }

    PrintCurrentClockAdjustments();

    printf("Adjusting the system clock by -%d PPM (-%d new units)\n",
    dwPPMAdjustment, dwNewAdjustmentUnits);

    if (!SetSystemTimeAdjustmentPrecise(ullCurrentAdjustment - dwNewAdjustmentUnits, FALSE))
    {
        printf("Failed to set the system time adjustment. hr:0x%08x\n",
        HRESULT_FROM_WIN32(GetLastError()));
    }

    PrintCurrentClockAdjustments();

    printf("Restoring system clock adjustment settings\n");

    if (!SetSystemTimeAdjustmentPrecise(ullCurrentAdjustment, FALSE))
    {
        printf("Failed to set the system time adjustment. hr:0x%08x\n",
        HRESULT_FROM_WIN32(GetLastError()));
    }

    PrintCurrentClockAdjustments();

    printf("Adjustment sequence complete\n\n");
}
</code>
    </remarks>
    <seealso cref="GetSystemTimeAdjustmentPrecise" />
  </member>
</doc>