<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AddDllDirectory">
    <summary>
      <para>Adds a directory to the process DLL search path.</para>
    </summary>
    <param name="NewDirectory">
      <para>An absolute path to the directory to add to the search path. For example, to add the directory
Dir2 to the process DLL search path, specify \Dir2. For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an opaque pointer that can be passed to
<see cref="RemoveDllDirectory" /> to remove the DLL from the
process DLL search path.</para>
      <para>If the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddDllDirectory</b> function can be used to add
any absolute path to the set of directories that are searched for a DLL. If
<see cref="SetDefaultDllDirectories" /> is first called with
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>, directories specified with
<b>AddDllDirectory</b> are added to the process DLL search
path. Otherwise, directories specified with the
<b>AddDllDirectory</b> function are used only for
<see cref="LoadLibraryEx" /> function calls that specify
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>.</para>
      <para>If <b>AddDllDirectory</b> is used to add more than one
directory to the process DLL search path, the order in which those directories are searched is unspecified.</para>
      <para>To remove a directory added with <b>AddDllDirectory</b>,
use the <see cref="RemoveDllDirectory" /> function.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>To use this function in an application, call
<see cref="GetProcAddress" /> to retrieve the function's address
from Kernel32.dll.
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> must be
installed on the target platform.</para>
    </remarks>
  </member>
  <member name="Windows.DisableThreadLibraryCalls">
    <summary>
      <para>Disables the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications for the specified dynamic-link library (DLL). This can reduce the size of the working set for some applications.</para>
    </summary>
    <param name="hLibModule">
      <para>A handle to the DLL module for which the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications are to be disabled. The
<see cref="LoadLibrary" />, <see cref="LoadLibraryEx" />,  or
<see cref="GetModuleHandle" /> function returns this handle. Note that you cannot call <b>GetModuleHandle</b> with NULL because this returns the base address of the executable image, not the DLL image.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. The
<b>DisableThreadLibraryCalls</b> function fails if the DLL specified by <i>hModule</i> has active static thread local storage, or if <i>hModule</i> is an invalid module handle. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DisableThreadLibraryCalls</b> function lets a DLL disable the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notification calls. This can be a useful optimization for multithreaded applications that have many DLLs, frequently create and delete threads, and whose DLLs do not need these thread-level notifications of attachment/detachment. A remote procedure call (RPC) server application is an example of such an application. In these sorts of applications, DLL initialization routines often remain in memory to service DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications. By disabling the notifications, the DLL initialization code is not paged in because a thread is created or deleted, thus reducing the size of the application's working code set. To implement the optimization, modify a DLL's DLL_PROCESS_ATTACH code to call
<b>DisableThreadLibraryCalls</b>.</para>
      <para>Do not call this function from a DLL that is linked to the static C run-time library (CRT). The static CRT requires DLL_THREAD_ATTACH and DLL_THREAD_DETATCH notifications to function properly.</para>
      <para>This function does not perform any optimizations if static <a href="https://docs.microsoft.com//windows/win32/procthread/thread-local-storage">Thread Local Storage (TLS)</a> is enabled. Static TLS is enabled when using <b>thread_local</b> variables, <b>__declspec( thread )</b> variables, or function-local <b>static</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-entry-point-function">Dynamic-Link Library Entry-Point Function</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibraryAndExitThread" />
  </member>
  <member name="Windows.EnumResourceLanguagesEx">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesExA">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesExW">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesEx">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesExA">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesExW">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a specified binary module. Extends <see cref="EnumResourceLanguages" /> by allowing more control over the enumeration.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more</para>
      <para>information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b> flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for language-specific resources in .mui files associated with the LN file specified by <i>hModule</i>. Alternately, if <i>LangId</i> is nonzero, the only .mui file searched will be the one matching the specified <i>LangId</i>. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_LN</b> flag, despite the name of the flag. See the Remarks section below for sequence of search.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restricts the .mui files search to system-installed MUI languages.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the .mui file. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files are included in the search. If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically an LN file, and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each such resource found, <b>EnumResourceLanguagesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing to the callback function the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found (as well as the various other parameters that were passed to <b>EnumResourceLanguagesEx</b>).</para>
      <para>The search can include both an LN file and its associated .mui files, or it can be limited either to a single binary module of any type, or to the .mui files associated with a single LN file. Also, by specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>The <b>EnumResourceLanguagesEx</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the languages enumerated include all languages whose resources reside either in the LN file or in any .mui files associated with it. If no .mui files are found, only languages from the LN file are returned.</para>
      <para>If <i>dwFlags</i> contains <b>RESOURCE_ENUM_MUI</b> or <b>NULL</b> and <i>LangId</i> is 0, then the enumeration first includes the languages associated with all system-installed .mui files, using languages retrieved from <see cref="EnumUILanguages" />.. Finally, if the <b>RESOURCE_ENUM_LN</b> flag is also set, the file designated by <i>hModule</i> is also searched.</para>
      <para>If the <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceLanguagesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://msdn.microsoft.com/58c1a42d-15d2-4157-8c57-f9b1d389b917">EnumResLangProc</seealso>
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNames">
    <summary>
      <para>Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is also possible for <i>hModule</i> to specify an .mui file, in which case only that file is searched for resources.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in the search.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>. For more information, see the <a href="https://docs.microsoft.com/#remarks">Remarks</a> section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name or ID. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The return value is <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For each resource found, <b>EnumResourceNames</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNames</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceNamesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>If a resource has an ID, the ID is passed to the callback function; otherwise the resource name is passed to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</a>.</para>
      <para>The <b>EnumResourceNames</b> function continues to enumerate resources until the callback function returns <b>FALSE</b> or all resources have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in a .mui file associated with it. If no .mui files are found, only resources from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. Once one appropriate .mui file is found, the .mui file search stops. Because all .mui files that correspond to a single LN file have the same resource types, only the resources in the found .mui file need to be enumerated.</para>
      <para>The enumeration never includes duplicates: if resources with the same name are contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources#creating-a-resource-list">Creating a Resource List</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Menus and Other Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesA">
    <summary>
      <para>Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is also possible for <i>hModule</i> to specify an .mui file, in which case only that file is searched for resources.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in the search.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>. For more information, see the <a href="https://docs.microsoft.com/#remarks">Remarks</a> section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name or ID. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The return value is <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For each resource found, <b>EnumResourceNames</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNames</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceNamesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>If a resource has an ID, the ID is passed to the callback function; otherwise the resource name is passed to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</a>.</para>
      <para>The <b>EnumResourceNames</b> function continues to enumerate resources until the callback function returns <b>FALSE</b> or all resources have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in a .mui file associated with it. If no .mui files are found, only resources from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. Once one appropriate .mui file is found, the .mui file search stops. Because all .mui files that correspond to a single LN file have the same resource types, only the resources in the found .mui file need to be enumerated.</para>
      <para>The enumeration never includes duplicates: if resources with the same name are contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources#creating-a-resource-list">Creating a Resource List</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">ENUMRESNAMEPROC</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Menus and Other Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesEx">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesExA">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesExW">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesEx">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesExA">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesExW">
    <summary>
      <para>Enumerates resources of a specified type that are associated with a specified binary module. The search can include both an LN file and its associated .mui files, or it can be limited in several ways.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to search. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files are included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://msdn.microsoft.com/8d27f79a-8165-4565-a975-f25b2344efdc">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to search. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resources in .mui files associated with the LN file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the specified .mui file will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches the file specified by <i>hModule</i>, regardless of whether the file is an LN file, another type of LN file, or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each name that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The localization language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The function <b>TRUE</b> if successful, or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the</para>
      <para>integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>The enumeration search can include both an LN file and its associated .mui files. It can be limited to a single binary module of any type. It can also be limited to the .mui files associated with a single LN file. By specifying an LN file for the <i>hModule</i> parameter and a nonzero <i>LangId</i> parameter, the search can be limited to the unique .mui file associated with that LN file and language.</para>
      <para>For each resource found, <b>EnumResourceNamesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNamesEx</b>.</para>
      <para>If a resource has an ID, the ID is returned to the callback function; otherwise the resource name is returned to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</a>.</para>
      <para>The <b>EnumResourceNamesEx</b> function continues to enumerate resource names until the callback function returns <b>FALSE</b> or all resource names for this type have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the names enumerated correspond to resources residing either in that LN file or  the .mui files associated with it. If no .mui files are found, only names from the LN file are returned. After one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource names.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceNames" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that Language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the name will only be enumerated once.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameproca">EnumResNameProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNames">
    <summary>
      <para>Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is also possible for <i>hModule</i> to specify an .mui file, in which case only that file is searched for resources.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in the search.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>. For more information, see the <a href="https://docs.microsoft.com/#remarks">Remarks</a> section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name or ID. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The return value is <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For each resource found, <b>EnumResourceNames</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNames</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceNamesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>If a resource has an ID, the ID is passed to the callback function; otherwise the resource name is passed to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</a>.</para>
      <para>The <b>EnumResourceNames</b> function continues to enumerate resources until the callback function returns <b>FALSE</b> or all resources have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in a .mui file associated with it. If no .mui files are found, only resources from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. Once one appropriate .mui file is found, the .mui file search stops. Because all .mui files that correspond to a single LN file have the same resource types, only the resources in the found .mui file need to be enumerated.</para>
      <para>The enumeration never includes duplicates: if resources with the same name are contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h3>Examples</h3>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources#creating-a-resource-list">Creating a Resource List</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Menus and Other Resources</seealso>
  </member>
  <member name="Windows.EnumResourceNamesW">
    <summary>
      <para>Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is also possible for <i>hModule</i> to specify an .mui file, in which case only that file is searched for resources.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui files (if any exist) are included in the search.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of the resource for which the name is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>. For more information, see the <a href="https://docs.microsoft.com/#remarks">Remarks</a> section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESNAMEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource name or ID. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>The return value is <b>TRUE</b> if the function succeeds or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpszType</i>) is <b>TRUE</b>, then <i>lpszType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For each resource found, <b>EnumResourceNames</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the name or the ID of each resource it finds, as well as the various other parameters that were passed to <b>EnumResourceNames</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceNamesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>If a resource has an ID, the ID is passed to the callback function; otherwise the resource name is passed to the callback function. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</a>.</para>
      <para>The <b>EnumResourceNames</b> function continues to enumerate resources until the callback function returns <b>FALSE</b> or all resources have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in a .mui file associated with it. If no .mui files are found, only resources from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. Once one appropriate .mui file is found, the .mui file search stops. Because all .mui files that correspond to a single LN file have the same resource types, only the resources in the found .mui file need to be enumerated.</para>
      <para>The enumeration never includes duplicates: if resources with the same name are contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h3>Examples</h3>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources#creating-a-resource-list">Creating a Resource List</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumresnameprocw">ENUMRESNAMEPROC</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Menus and Other Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesEx">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesExA">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesExW">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesEx">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesExA">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesExW">
    <summary>
      <para>Enumerates resource types associated with a specified binary module. The search can include both a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> file (LN file) and its associated .mui files. Alternately, it can be limited to a single binary module of any type, or to the .mui files associated with a single LN file. The search can also be limited to a single associated .mui file that contains resources for a specific language.</para>
      <para>For each resource type found, <b>EnumResourceTypesEx</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypesEx</b>.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Typically this is an LN file, and if flag <b>RESOURCE_ENUM_MUI</b> is set, then appropriate .mui files can be included in the search. Alternately, this can be a handle to an .mui file or other LN file.</para>
      <para>If this parameter is <b>NULL</b>, it is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see <a href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The type of file to be searched. The following values are supported. Note that if <i>dwFlags</i> is zero, then the <b>RESOURCE_ENUM_LN</b> and <b>RESOURCE_ENUM_MUI</b>  flags are assumed to be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_MUI</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Search for resource types in one of the .mui files associated with the file specified by <i>hModule</i> and with the current language preferences, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). Alternately, if <i>LangId</i> is nonzero, then only the .mui file of the language as specified by <i>LangId</i> will be searched. Typically this flag should be used only if <i>hModule</i> references an LN file. If <i>hModule</i> references an .mui file, then that file is actually covered by the <b>RESOURCE_ENUM_LN</b> flag, despite the name of the flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_LN</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Searches only the file specified by <i>hModule</i>, regardless of whether the file is an LN file or an .mui file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESOURCE_ENUM_VALIDATE</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs extra validation on the resource section and its reference in the PE header while doing the enumeration to ensure that resources are properly formatted. The validation sets a maximum limit of 260 characters for each type that is enumerated.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="LangId">
      <para>Type: <b>LANGID</b></para>
      <para>The language used to filter the search in the MUI module. This parameter is used only when the <b>RESOURCE_ENUM_MUI</b> flag is set in <i>dwFlags</i>. If zero is specified, then all .mui files that match current language preferences are included in the search, following the usual Resource Loader strategy (see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a>). If a nonzero <i>LangId</i> is specified, then the only .mui file searched will be the one matching the specified <i>LangId</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> if the function does not find a resource of the type specified, or if the function fails for another reason. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EnumResourceTypesEx</b> function continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>If <i>hModule</i> specifies an LN file, and both flags are selected, the types enumerated correspond to resources residing either in the LN file or in the .mui files associated with it. If no .mui files are found, only types from the LN file are returned. Once one appropriate .mui file is found the search will not continue further, because all .mui files corresponding to a single LN file have the same resource types.</para>
      <para>If <i>dwFlags</i> and <i>LangId</i> are both zero, then the function behaves like <see cref="EnumResourceTypes" />.</para>
      <para>If <i>LangId</i> is nonzero, then only the .mui file corresponding to that language identifier will be searched. Language fallbacks will not be used. If an .mui file for that language does not exist, the enumeration will be empty (unless resources for that language exist in the LN file, and the flag is set to search the LN file as well).</para>
      <para>The enumeration never includes duplicates: if resources for a particular language are contained in both the LN file and in an .mui file, the type will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows-hardware/drivers/wdf/creating-a-resource-requirements-list">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines EnumResourceTypesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/api/libloaderapi/nc-libloaderapi-enumrestypeproca">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNamesEx" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.FindResourceEx">
    <summary>
      <para>Determines the location of the resource with the specified type, name, and language in the specified module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpType</i> or <i>lpName</i>, x specifies the integer identifier of the type or name of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResourceEx</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResourceEx</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.FindResourceExW">
    <summary>
      <para>Determines the location of the resource with the specified type, name, and language in the specified module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpType</i> or <i>lpName</i>, x specifies the integer identifier of the type or name of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResourceEx</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResourceEx</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.FindResource">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpName</i> or <i>lpType</i>, x specifies the integer identifier of the name or type of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResource</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResource</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h3>Examples</h3>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResourceEx" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.FindResourceW">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpName</i> or <i>lpType</i>, x specifies the integer identifier of the name or type of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResource</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResource</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h3>Examples</h3>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResourceEx" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.FindStringOrdinal">
    <summary>
      <para>Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.</para>
    </summary>
    <param name="dwFindStringOrdinalFlags">
      <para>Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_FROMSTART</b>
          </description>
          <description>
            <para>Search the string, starting with the first character of the string.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FIND_FROMEND</b>
          </description>
          <description>
            <para>Search the string in the reverse direction, starting with the last character of the string.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FIND_STARTSWITH</b>
          </description>
          <description>
            <para>Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FIND_ENDSWITH</b>
          </description>
          <description>
            <para>Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpStringSource">
      <para>Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.</para>
    </param>
    <param name="cchSource">
      <para>Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically.</para>
    </param>
    <param name="lpStringValue">
      <para>Pointer to the search string for which the function searches in the source string.</para>
    </param>
    <param name="cchValue">
      <para>Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically.</para>
    </param>
    <param name="bIgnoreCase">
      <para>
        <b>TRUE</b> if the function is to perform a case-insensitive comparison, and <b>FALSE</b> otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English.</para>
    </param>
    <returns>
      <para>Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. If the function succeeds, the found string is the same size as the value of <i>lpStringValue</i>. A return value of 0 indicates that the function found a match at the beginning of the source string.</para>
      <para>The function returns -1 if it does not succeed or if it does not find the search string. To get extended error information, the application can call <see cref="GetLastError" />, which can return one of the following error codes:</para>
      <list type="bullet">
        <item>
          <description>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</description>
        </item>
        <item>
          <description>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</description>
        </item>
        <item>
          <description>ERROR_SUCCESS. The action completed successfully but yielded no results.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Since <b>FindStringOrdinal</b> provides a binary comparison, it does not return linguistically appropriate results. The ordinal comparison might be mistaken for English sorting behavior. However, it does not find matches when characters vary by linguistically insignificant amounts. See <a href="https://docs.microsoft.com//windows/desktop/Intl/sorting">Sorting</a> for information about choosing an appropriate sorting function.</para>
      <para>In contrast to NLS functions that return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns.</para>
      <para>This function is one of the few NLS functions that calls <see cref="SetLastError" /> even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by <see cref="GetLastError" />.</para>
      <para>
        <b>Starting with Windows 8: </b>
        <b>FindStringOrdinal</b>  is declared in Libloaderapi.h. Before Windows 8, it was declared in Winnls.h.</para>
    </remarks>
    <seealso cref="FindNLSString" />
    <seealso cref="FindNLSStringEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support-functions">National Language Support Functions</seealso>
  </member>
  <member name="Windows.FreeLibrary">
    <summary>
      <para>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the reference count reaches zero, the module is unloaded from the address space of the calling process and the handle is no longer valid.</para>
    </summary>
    <param name="hLibModule">
      <para>A handle to the loaded library module. The
<see cref="LoadLibrary" />, <see cref="LoadLibraryEx" />,
<see cref="GetModuleHandle" />, or <see cref="GetModuleHandleEx" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to
<see cref="LoadLibrary" />. The reference count is also incremented by a call to <see cref="LoadLibraryEx" /> unless the  module  is being loaded for the first time and is being loaded as   a data or image file.</para>
      <para>The reference count is decremented each time
the <b>FreeLibrary</b> or <see cref="FreeLibraryAndExitThread" /> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process.</para>
      <para>It is not safe to call
<b>FreeLibrary</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>.</para>
      <para>Calling
<b>FreeLibrary</b> does not affect other processes that are using the same module.</para>
      <para>Use caution when calling <b>FreeLibrary</b> with a handle returned by <see cref="GetModuleHandle" />. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely.</para>
      <para>A thread that must unload the DLL in which it is executing and then terminate itself should call <see cref="FreeLibraryAndExitThread" /> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <see cref="FreeLibraryAndExitThread" />.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibraryAndExitThread" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
  </member>
  <member name="Windows.FreeLibraryAndExitThread">
    <summary>
      <para>Decrements the reference count of a loaded dynamic-link library (DLL) by one, then calls
<see cref="ExitThread" /> to terminate the calling thread. The function does not return.</para>
    </summary>
    <param name="hLibModule">
      <para>A handle to the DLL module whose reference count the function decrements. The
<see cref="LoadLibrary" /> or
<see cref="GetModuleHandleEx" /> function returns this handle.</para>
      <para>Do not call this function with a handle returned by either the <b>GetModuleHandleEx</b> function (with the GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT flag) or the <see cref="GetModuleHandle" /> function, as they do not maintain a reference count for the module.</para>
    </param>
    <param name="dwExitCode">
      <para>The exit code for the calling thread.</para>
    </param>
    <remarks>
      <para>The
<b>FreeLibraryAndExitThread</b> function allows threads that are executing within a DLL to safely free the DLL in which they are executing and terminate themselves. If they were to call
<see cref="FreeLibrary" /> and
<see cref="ExitThread" /> separately, a race condition would exist. The library could be unloaded before
<b>ExitThread</b> is called.</para>
    </remarks>
    <seealso cref="DisableThreadLibraryCalls" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="ExitThread" />
    <seealso cref="FreeLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
  </member>
  <member name="Windows.GetModuleFileName">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix <code>\\?\</code>. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleFileNameA">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix <code>\\?\</code>. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleFileNameW">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix <code>\\?\</code>. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleFileName">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\?". For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleFileNameA">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\?". For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleFileNameW">
    <summary>
      <para>Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.</para>
      <para>To locate the file for a module that was loaded by another process, use the
<see cref="GetModuleFileNameEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
<b>GetModuleFileName</b> retrieves the path of the executable file of the current process.</para>
      <para>The <b>GetModuleFileName</b> function does not retrieve the path for modules  that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpFilename">
      <para>A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a null-terminated string.</para>
      <para>If the length of the path exceeds the size that  the <i>nSize</i> parameter specifies, the function succeeds and the string is truncated to <i>nSize</i>  characters including the terminating null character.</para>
      <para>
        <b>Windows XP:  </b>The string is truncated to <i>nSize</i> characters and is not null-terminated.</para>
      <para>The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\?". For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to <i>nSize</i> characters including the terminating null character, the function returns <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
      <para>
        <b>Windows XP:  </b>If the buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a DLL is loaded in two processes, its file name in one process may differ in case from its file name in the other process.</para>
      <para>The global variable <code>_pgmptr</code> is automatically initialized to the full path of the executable file, and can be used to retrieve the full path name of an executable file.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Services/installing-a-service">Installing a Service</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandle">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleA">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleW">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleEx">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleExA">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleExW">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleEx">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h5>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h5>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h5>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleExA">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h5>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h5>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h5>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleExW">
    <summary>
      <para>Retrieves a module handle for the specified module and increments the module's reference count unless GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter can be zero or one or more of the following values. If the module's reference count is incremented, the caller must use the <see cref="FreeLibrary" /> function to decrement the reference count when the module handle is no longer needed.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h4>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h4>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h4>GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h4>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS).</para>
      <para>For a module name, if the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL, the function returns a handle to the file used to create the calling process (.exe file).</para>
    </param>
    <param name="phModule">
      <para>A handle to the specified module. If the function fails, this parameter is NULL.</para>
      <para>The <b>GetModuleHandleEx</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)</h5>
      <para>The <i>lpModuleName</i> parameter is an address in the module.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)</h5>
      <para>The module stays loaded until the process is terminated, no matter how many times
<see cref="FreeLibrary" /> is called.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT.</para>
      <h5>- dwFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)</h5>
      <para>The reference count for the module is not incremented. This option is equivalent to the behavior of
<see cref="GetModuleHandle" />. Do not pass the retrieved module handle to the <see cref="FreeLibrary" /> function; doing so can cause the DLL to be unmapped prematurely. For more information, see Remarks.</para>
      <para>This option cannot be used with GET_MODULE_HANDLE_EX_FLAG_PIN.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, see
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or specify a memory location rather than a DLL name in the <i>lpModuleName</i> parameter.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, the <b>GetModuleHandleEx</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandleEx</b> with GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT to the
<see cref="FreeLibrary" /> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>If <i>dwFlags</i> contains GET_MODULE_HANDLE_EX_UNCHANGED_REFCOUNT, this function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, first thread would have a handle to a module different than the one intended.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandleEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandle">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleA">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetModuleHandleW">
    <summary>
      <para>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</para>
      <para>To avoid the race conditions described in the Remarks section, use the
<see cref="GetModuleHandleEx" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
      <para>If this parameter is NULL,
<b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file).</para>
      <para>The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process.</para>
      <para>If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com//windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <see cref="GetModuleHandleEx" /> to specify a memory location rather than a DLL name.</para>
      <para>The
<b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <see cref="FreeLibrary" /> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the
<b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely.</para>
      <para>This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/gdi/using-brushes">Using Brushes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines GetModuleHandle as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleFileName" />
    <seealso cref="GetModuleHandleEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.GetProcAddress">
    <summary>
      <para>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</para>
    </summary>
    <param name="hModule">
      <para>A handle to the DLL module that contains the function or variable. The
<see cref="LoadLibrary" />, <see cref="LoadLibraryEx" />, <see cref="LoadPackagedLibrary" />, or
<see cref="GetModuleHandle" /> function returns this handle.</para>
      <para>The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <see cref="LoadLibraryEx" />.</para>
    </param>
    <param name="lpProcName">
      <para>The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the address of the exported function or variable.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The spelling and case of a function name pointed to by <i>lpProcName</i> must be identical to that in the <b>EXPORTS</b> statement of the source DLL's module-definition (.def) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      <para>The <i>lpProcName</i> parameter can identify the DLL function by specifying an ordinal value associated with the function in the <b>EXPORTS</b> statement.
<b>GetProcAddress</b> verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the .def file. The function then uses the ordinal as an index to read the function's address from a function table.</para>
      <para>If the .def file does not number the functions consecutively from 1 to <i>N</i> (where <i>N</i> is the number of exported functions), an error can occur where
<b>GetProcAddress</b> returns an invalid, non-NULL address, even though there is no function with the specified ordinal.</para>
      <para>If the function might not exist in the DLL module—for example, if the function  is available only on Windows Vista but the application  might be running on Windows XP—specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available, as shown in the following code fragment.</para>
      <code>
typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);

// Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.

   PGNSI pGNSI;
   SYSTEM_INFO si;

   ZeroMemory(&amp;amp;amp;amp;amp;amp;si, sizeof(SYSTEM_INFO));

   pGNSI = (PGNSI) GetProcAddress(
      GetModuleHandle(TEXT("kernel32.dll")),
      "GetNativeSystemInfo");
   if(NULL != pGNSI)
   {
      pGNSI(&amp;amp;amp;amp;amp;amp;si);
   }
   else
   {
       GetSystemInfo(&amp;amp;amp;amp;amp;amp;si);
   }


</code>
      <para>For the complete example that contains this code fragment, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FreeLibrary" />
    <seealso cref="GetModuleHandle" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadPackagedLibrary" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
  </member>
  <member name="Windows.LoadLibrary">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryA">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryW">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryEx">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>The following code example demonstrates a call to <b>LoadLibraryExA</b>.</para><code>//Load the FMAPI DLL
hLib = .LoadLibraryEx(L"fmapi.dll", NULL, NULL);
if ( !hLib )
{
      wprintf(L"Could not load fmapi.dll, Error #%d.\n", GetLastError());
      return;
}
</code><para>For an additional example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryExA">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>The following code example demonstrates a call to <b>LoadLibraryExA</b>.</para><code>//Load the FMAPI DLL
hLib = .LoadLibraryEx(L"fmapi.dll", NULL, NULL);
if ( !hLib )
{
      wprintf(L"Could not load fmapi.dll, Error #%d.\n", GetLastError());
      return;
}
</code><para>For an additional example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryExW">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>The following code example demonstrates a call to <b>LoadLibraryExA</b>.</para><code>//Load the FMAPI DLL
hLib = .LoadLibraryEx(L"fmapi.dll", NULL, NULL);
if ( !hLib )
{
      wprintf(L"Could not load fmapi.dll, Error #%d.\n", GetLastError());
      return;
}
</code><para>For an additional example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryEx">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, and the module name does
not contain any point character (.), then the function appends the default library extension .dll to the module name.
To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module
name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryExA">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, and the module name does
not contain any point character (.), then the function appends the default library extension .dll to the module name.
To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module
name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryExW">
    <summary>
      <para>Loads the specified module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
    </summary>
    <param name="lpLibFileName">
      <para>A string that specifies the file name of the module to load. This name is not related to the name stored in a
library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition
(.def) file.</para>
      <para>The module can be a library module (a .dll file) or an executable module (an .exe file). If the
specified module is an executable module, static imports are not loaded; instead, the module is loaded as if
<b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i></para>
      <para>parameter for more information.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, and the module name does
not contain any point character (.), then the function appends the default library extension .dll to the module name.
To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module
name string.</para>
      <para>If the string specifies a fully qualified path, the function searches only that path for the module. When
specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the string specifies a module name without a path and more than one loaded module has the same base name
and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If the string specifies a module name without a path and a module of the same name is not already loaded, or
if the string specifies a module name with a relative path, the function searches for the specified module. The
function also searches for modules if loading the specified module causes the system to load other associated
modules (that is, if the module has dependencies). The directories that are searched and the order in which
they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
information, see Remarks.</para>
      <para>If the function cannot find the  module or one of its dependencies, the function fails.</para>
    </param>
    <param name="hFile">
      <para>This parameter is reserved for future use. It must be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The action to be taken when loading the module. If no flags are specified, the behavior of this function is
identical to that of the <see cref="LoadLibrary" /> function. This
parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DONT_RESOLVE_DLL_REFERENCES</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, and the executable module is a DLL, the system does not call
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> for process and thread initialization and
termination. Also, the system does not load additional executable modules that are referenced by the
specified module.</para>
            <para>
              <b>Note</b>  Do not use this value; it is provided only for backward compatibility. If you are planning to access
only data or resources in the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both. Otherwise, load the library as a DLL or
executable module using the <see cref="LoadLibrary" /></para>
            <para>function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system does not check
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)">AppLocker</a> rules or apply
<a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc779607(v=ws.10)">Software Restriction Policies</a></para>
            <para>for the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is
recommended for use in setup programs that must run extracted DLLs during installation.</para>
            <para>
              <b>Windows Server 2008 R2 and Windows 7:  </b>On systems with KB2532445 installed, the caller must be running as "LocalSystem" or
"TrustedInstaller"; otherwise the system ignores this flag. For more information, see
"You can circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server 2008 R2"
in the Help and Support Knowledge Base at
<a href="https://support.microsoft.com/kb/2532445">https://support.microsoft.com/kb/2532445</a>.</para>
            <para>
              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>AppLocker was introduced in Windows 7 and Windows Server 2008 R2.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the calling process's virtual address space as if it
were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot
call functions like <see cref="GetModuleFileName" />,
<see cref="GetModuleHandle" /> or
<see cref="GetProcAddress" /> with this DLL. Using this value
causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL
only to extract messages or resources from it.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL file is opened with
exclusive write access for the calling process. Other processes cannot open the DLL file for write access
while it is in use. However, the DLL can still be opened by other processes.</para>
            <para>This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information,
see Remarks.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the system maps the file into the process's virtual address space as an image file.
However, the loader does not load the static imports or perform the other usual initialization steps. Use
this flag when you want to load a DLL only to extract messages or resources from it.</para>
            <para>Unless the application depends on the file having the in-memory layout of an image, this value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported  until Windows Vista.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched for the DLL and its
dependencies. Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not
searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the directory that contains the DLL is temporarily added to the beginning of the
list of directories that are searched for the DLL's dependencies.  Directories in the standard search path
are not searched.</para>
            <para>The <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot
be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
Lib1.dll  with this value causes the system to search for Lib2.dll only in
C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories
in the DLL search path, combine this value with <b>LOAD_LIBRARY_DEFAULT_DIRS</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
Directories in the standard search path are not searched. This value cannot be combined with
<b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, directories added using the
<see cref="AddDllDirectory" /> or the
<see cref="SetDllDirectory" /> function are searched for the DLL
and its dependencies. If more than one directory has been added, the order in which the directories are
searched is unspecified. Directories in the standard search path are not searched. This value cannot be
combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>.</para>
            <para>
              <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>This value requires
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> to be
installed.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used and <i>lpFileName</i> specifies an absolute path, the system uses
the alternate file search strategy discussed in the Remarks section to find associated executable modules
that the specified module causes to be loaded. If this value is used and <i>lpFileName</i></para>
            <para>specifies a relative path, the behavior is undefined.</para>
            <para>If this value is not used, or if <i>lpFileName</i> does not specify a path, the system
uses the standard search strategy discussed in the Remarks section to find associated executable modules that
the specified module causes to be loaded.</para>
            <para>This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the digital signature of the binary image must be checked at load time.</para>
            <para>This value requires Windows 8.1, Windows 10 or later.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, loading a DLL for execution from the current directory is only allowed if it is under a directory in the Safe load list.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LoadLibraryEx</b> function is very similar to the
<see cref="LoadLibrary" /> function. The differences consist of a set of
optional behaviors that <b>LoadLibraryEx</b> provides:</para>
      <list type="bullet">
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a DLL module without
calling the <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function of the DLL.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can load a module in a way that is
optimized for the case where the module will never be executed, loading the module as if it were a data
file.</description>
        </item>
        <item>
          <description>
            <b>LoadLibraryEx</b> can find modules and their
associated modules by using  either of two search strategies or it can search a process-specific set of
directories.</description>
        </item>
      </list>
      <para>You select these optional behaviors by setting the <i>dwFlags</i> parameter; if
<i>dwFlags</i> is zero,
<b>LoadLibraryEx</b> behaves identically to
<see cref="LoadLibrary" />.</para>
      <para>The calling process can use the handle returned by
<b>LoadLibraryEx</b> to identify the module in calls to the
<see cref="GetProcAddress" />,
<see cref="FindResource" />, and
<see cref="LoadResource" /> functions.</para>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>It is not safe to call <b>LoadLibraryEx</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>
        <b>Visual C++:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibraryEx</b> on versions of
Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread
local storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>.</para>
      <h3>Loading a DLL as a Data File or Image Resource</h3>
      <para>The <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, and
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> values affect the per-process reference count and the
loading of the specified module. If any of these values is specified for the <i>dwFlags</i></para>
      <para>parameter, the loader checks whether the module was already loaded by the process as an executable DLL. If so,
this means that the module is already mapped into the virtual address space of the calling process. In this
case, <b>LoadLibraryEx</b> returns a handle to the DLL and
increments the DLL reference count. If the DLL module was not already loaded as a DLL, the system maps the
module as a data or image file and not as an executable DLL. In this case,
<b>LoadLibraryEx</b> returns a handle to the loaded data or
image file but does not increment the reference count for the module and does not make the module visible to functions such as <see cref="CreateToolhelp32Snapshot" /> or <see cref="EnumProcessModules" />.</para>
      <para>If <b>LoadLibraryEx</b> is called twice for the same file
with <b>LOAD_LIBRARY_AS_DATAFILE</b>,
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>, or
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>, two separate mappings are created for the file.</para>
      <para>When the <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value is used, the module is loaded as an
image using portable executable (PE) section alignment expansion. Relative virtual addresses (RVA) do not have
to be mapped to disk addresses, so resources can be more quickly retrieved from the module. Specifying
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> prevents other processes from modifying the module
while it is loaded.</para>
      <para>Unless an application depends on specific image mapping characteristics, the
<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> value should be used with either
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE</b>. This allows the loader to choose whether to load the module
as an image resource or a data file, selecting whichever option enables the system to share pages more
effectively. Resource  functions such as
<see cref="FindResource" /> can use either mapping.</para>
      <para>To determine how a module was loaded, use one of the  following macros to test the handle returned by
<b>LoadLibraryEx</b>.</para>
      <code>#define LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp;  (ULONG_PTR)1)
#define LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp;amp;amp;amp;amp;amp; (ULONG_PTR)2)
#define LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))

</code>
      <para>The following table describes these macros.</para>
      <list type="table">
        <listheader>
          <description>Macro</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <b>LDR_IS_DATAFILE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as a data file
(<b>LOAD_LIBRARY_AS_DATAFILE</b> or
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_IMAGEMAPPING</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as an image file
(<b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>).</description>
        </item>
        <item>
          <description>
            <b>LDR_IS_RESOURCE</b>(<i>handle</i>)</description>
          <description>If this macro returns <b>TRUE</b>, the module was loaded as either a data file or an
image file.</description>
        </item>
      </list>
      <para>Use the <see cref="FreeLibrary" /> function to free a loaded module,
whether or not loading the module caused its reference count to be incremented. If the module was loaded as a
data or image file, the mapping is destroyed but the reference count is not decremented. Otherwise, the DLL
reference count is decremented. Therefore, it is safe to call
<b>FreeLibrary</b> with any handle returned by
<b>LoadLibraryEx</b>.</para>
      <h3>Searching for DLLs and Dependencies</h3>
      <para>The search path is the set of directories that are searched for a DLL. The
<b>LoadLibraryEx</b> function can search for a DLL using a
standard search path or an altered search path, or it can use a process-specific search path established with
the <see cref="SetDefaultDllDirectories" /> and
<see cref="AddDllDirectory" /> functions. For a list of directories
and the order in which they are searched, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The <b>LoadLibraryEx</b> function uses the standard search
path in the following cases:</para>
      <list type="bullet">
        <item>
          <description>The file name is specified without a path and the base file name does not match the base file name of a
loaded module, and none of the <b>LOAD_LIBRARY_SEARCH</b> flags are used.</description>
        </item>
        <item>
          <description>A path is specified but <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> is not used.</description>
        </item>
        <item>
          <description>The application has not specified a default DLL search path for the process using
<see cref="SetDefaultDllDirectories" />.</description>
        </item>
      </list>
      <para>If <i>lpFileName</i> specifies a relative path, the entire relative path is appended to
every token in the DLL search path. To load a module from a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibraryEx</b> with the nonrelative path. If the module
is being loaded as a datafile and the relative path starts with  "." or
"..", the relative path is treated as an absolute path.</para>
      <para>If <i>lpFileName</i> specifies an absolute path and <i>dwFlags</i> is
set to <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>,
<b>LoadLibraryEx</b> uses the altered search path.
The behavior is undefined when <b>LOAD_WITH_ALTERED_SEARCH_PATH</b> flag is set, and <i>lpFileName</i> specifies a relative path.</para>
      <para>The <see cref="SetDllDirectory" /> function can be used to modify
the search path. This solution is better than using
<see cref="SetCurrentDirectory" /> or hard-coding the full path
to the DLL. However, be aware that using
<b>SetDllDirectory</b> effectively disables safe DLL search
mode while the specified directory is in the search path and it is not thread safe. If possible, it is best to
use <see cref="AddDllDirectory" /> to modify a default process
search path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>An application can specify the directories to search for a single
<b>LoadLibraryEx</b> call by using the
<b>LOAD_LIBRARY_SEARCH_*</b> flags. If more than one
<b>LOAD_LIBRARY_SEARCH</b> flag is specified, the directories are searched in the following
order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL to be loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path
has been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System32 directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>The <b>LOAD_LIBRARY_SEARCH_*</b> flags are available on systems that have
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a></para>
      <para>installed. To determine whether the flags are available, use
<see cref="GetProcAddress" /> to get the address of the
<see cref="AddDllDirectory" />,
<see cref="RemoveDllDirectory" />, or
<see cref="SetDefaultDllDirectories" /> function. If
<b>GetProcAddress</b> succeeds, the
<b>LOAD_LIBRARY_SEARCH_*</b> flags can be used with
<b>LoadLibraryEx</b>.</para>
      <para>If the application has used the
<see cref="SetDefaultDllDirectories" /> function to
establish a DLL search path for the process and none of the <b>LOAD_LIBRARY_SEARCH_*</b></para>
      <para>flags are used, the <b>LoadLibraryEx</b> function uses the
process DLL search path instead of the standard search path.</para>
      <para>If a path is specified and there is a redirection file associated with the application, the
<b>LoadLibraryEx</b> function searches for the module in the
application directory. If the module exists in the application directory,
<b>LoadLibraryEx</b> ignores the path specification and
loads the module from the application directory. If the module does not exist in the application directory, the
function loads the module from the specified directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibraryEx</b> with the name of an
assembly without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <h3>Security Remarks</h3>
      <b>LOAD_LIBRARY_AS_DATAFILE</b> does not prevent other processes from modifying the module
while it is loaded. Because this can make your application less secure, you should use
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> instead of
<b>LOAD_LIBRARY_AS_DATAFILE</b> when loading a module as a data file, unless you
specifically need to use <b>LOAD_LIBRARY_AS_DATAFILE</b>. Specifying
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> prevents other processes from modifying the module
while it is loaded. Do not specify  <b>LOAD_LIBRARY_AS_DATAFILE</b> and
<b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> in the same call.
<para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibraryEx</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibraryEx</b> and it does not use safe process search
mode unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the
current working directory, the path retrieved by
<b>SearchPath</b> will point to the malicious DLL, which
<b>LoadLibraryEx</b> will then load.</para><para>Do not make assumptions about the operating system version based on a
<b>LoadLibraryEx</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para><para>For a general discussion of DLL security issues, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</a>.</para><h4>Examples</h4><para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/NetMgmt/looking-up-text-for-error-code-numbers">Looking Up Text for Error Code Numbers</a>.</para><blockquote><para>[!NOTE]
The libloaderapi.h header defines LoadLibraryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadResource" />
    <seealso cref="OpenFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SearchPath" />
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibrary">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryA">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadLibraryW">
    <summary>
      <para>Loads the specified  module into the address space of the calling process. The specified
module may cause other modules to be loaded.</para>
      <para>For additional load options, use the
<see cref="LoadLibraryEx" /> function.</para>
    </summary>
    <param name="lpLibFileName">
      <para>The name of the module. This can be either a library module (a .dll file) or an executable
module (an .exe file). The name specified is the file name of the module and is not related to the
name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in
the module-definition (.def) file.</para>
      <para>If the string specifies a full path, the function searches only that path for the module.</para>
      <para>If the string specifies a relative path or a module name without a path, the function uses a standard search
strategy to find the module; for more information, see the Remarks.</para>
      <para>If the function cannot find the  module, the function fails. When specifying a path, be sure to use
backslashes (\), not forward slashes (/). For more information about paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>.</para>
      <para>If the string specifies a module name without a path and the file name extension is omitted, the function
appends the default library extension .dll to the module name. To prevent the function from appending
.dll to the module name, include a trailing point character (.) in the module name string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the module.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To enable or disable error messages displayed by the loader during DLL loads, use the
<see cref="SetErrorMode" /> function.</para>
      <para>
        <b>LoadLibrary</b> can be used to load a library module into
the address space of the process and return a handle that can be used in
<see cref="GetProcAddress" /> to get the address of a DLL function.
<b>LoadLibrary</b> can also be used to load other executable
modules. For example, the function can specify an .exe file to get a handle that can be used in
<see cref="FindResource" /> or
<see cref="LoadResource" />. However, do not use
<b>LoadLibrary</b> to run an .exe file. Instead, use
the <see cref="CreateProcess" /> function.</para>
      <para>If the specified module is a DLL that is not already loaded for the calling process, the system calls the
DLL's <a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a> function with the
<b>DLL_PROCESS_ATTACH</b> value. If
<b>DllMain</b> returns <b>TRUE</b>,
<b>LoadLibrary</b> returns a handle to the module. If
<b>DllMain</b> returns <b>FALSE</b>,
the system unloads the DLL from the process address space and
<b>LoadLibrary</b> returns <b>NULL</b>. It is
not safe to call <b>LoadLibrary</b> from
<b>DllMain</b>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <para>Module handles are not global or inheritable. A call to
<b>LoadLibrary</b> by one process does not produce a handle that
another process can use — for example, in calling
<see cref="GetProcAddress" />. The other process must make its own
call to <b>LoadLibrary</b> for the module before calling
<b>GetProcAddress</b>.</para>
      <para>If <i>lpFileName</i> does not include a path and there is more than one loaded module with
the same base name and extension, the function returns a handle to the module that was loaded first.</para>
      <para>If no file name extension is specified in the <i>lpFileName</i> parameter, the default
library extension .dll is appended. However, the file name string can include a trailing point character (.) to
indicate that the module name has no extension. When no path is specified, the function searches for loaded
modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds.
Otherwise, the function searches for the file.</para>
      <para>The first directory searched is the directory containing the image file used to create the calling process
(for more information, see the
<see cref="CreateProcess" /> function). Doing this allows
private dynamic-link library (DLL) files associated with a process to be found without adding the process's
installed directory to the PATH environment variable. If a relative path is
specified, the entire relative path is appended to every token in the DLL search path list. To load a module from
a relative path without searching any other path, use
<see cref="GetFullPathName" /> to get a nonrelative path and call
<b>LoadLibrary</b> with the nonrelative path. For more
information on the DLL search order, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The search path can be altered using the
<see cref="SetDllDirectory" /> function. This solution is recommended
instead of using <see cref="SetCurrentDirectory" /> or
hard-coding the full path to the DLL.</para>
      <para>If a path is specified and there is a redirection file for the application, the function searches for the
module in the application's directory. If the module exists in the application's directory,
<b>LoadLibrary</b> ignores the specified path and loads the
module from the application's directory. If the module does not exist in the application's directory,
<b>LoadLibrary</b> loads the module from the specified
directory. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>.</para>
      <para>If you call <b>LoadLibrary</b> with the name of an assembly
without a path specification and the assembly is listed in the system compatible manifest, the call is
automatically redirected to the side-by-side assembly.</para>
      <para>The system maintains a per-process reference
count on all loaded modules. Calling <b>LoadLibrary</b></para>
      <para>increments the reference count. Calling the <see cref="FreeLibrary" /> or
<see cref="FreeLibraryAndExitThread" /> function decrements
the reference count. The system unloads a module when its reference count reaches zero or when the process
terminates (regardless of the reference count).</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables:
<b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the
DLL explicitly using <b>LoadLibrary</b> on versions of Windows
prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local
storage functions instead of <b>_declspec(thread)</b>. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage
in a Dynamic Link Library</a>.</para>
      <h3>Security Remarks</h3>
      <para>Do not use the <see cref="SearchPath" /> function to retrieve a path to
a DLL for a subsequent <b>LoadLibrary</b> call. The
<b>SearchPath</b> function uses a different search order than
<b>LoadLibrary</b> and it does not use safe process search mode
unless this is explicitly enabled by calling
<see cref="SetSearchPathMode" /> with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore,
<b>SearchPath</b> is likely to first search the user’s current
working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current
working directory, the path retrieved by <b>SearchPath</b> will
point to the malicious DLL, which <b>LoadLibrary</b> will then
load.</para>
      <para>Do not make assumptions about the operating system version based on a
<b>LoadLibrary</b> call that searches for a DLL. If the
application is running in an environment where the DLL is legitimately not present but a malicious version of
the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended
techniques described in
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/using-run-time-dynamic-linking">Using Run-Time Dynamic Linking</a>.</para>
      <blockquote>
        <para>[!NOTE]
The libloaderapi.h header defines LoadLibrary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="FindResource" />
    <seealso cref="FreeLibrary" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="LoadResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/run-time-dynamic-linking">Run-Time Dynamic Linking</seealso>
    <seealso cref="SetDllDirectory" />
    <seealso cref="SetErrorMode" />
  </member>
  <member name="Windows.LoadResource">
    <summary>
      <para>Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose executable file contains the resource. If <i>hModule</i> is <b>NULL</b>, the system loads the resource from the module that was used to create the current process.</para>
    </param>
    <param name="hResInfo">
      <para>Type: <b>HRSRC</b></para>
      <para>A handle to the resource to be loaded. This handle is returned by the <see cref="FindResource" /> or <see cref="FindResourceEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>HGLOBAL</b></para>
      <para>If the function succeeds, the return value is a handle to the data associated with the resource.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The return type of <b>LoadResource</b> is <b>HGLOBAL</b> for backward compatibility, not because the function returns a handle to a global memory block. Do not pass this handle to the <see cref="GlobalLock" /> or <see cref="GlobalFree" /> function. To obtain a pointer to the first byte of the resource data, call the <see cref="LockResource" /> function; to obtain the size of the resource, call <see cref="SizeofResource" />.</para>
      <para>To use a resource immediately, an application should use the following resource-specific functions to find and load the resource in one call.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
          <description>To remove resource</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry</description>
          <description>No action needed</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table</description>
          <description>
            <see cref="DestroyAcceleratorTable" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource</description>
          <description>
            <see cref="DeleteObject" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource</description>
          <description>
            <see cref="DestroyCursor" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource</description>
          <description>
            <see cref="DestroyIcon" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource</description>
          <description>
            <see cref="DestroyMenu" />
          </description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string resource</description>
          <description>No action needed</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen, followed by <see cref="DestroyIcon" /> when done.</para>
      <h4>Examples</h4>
      <para>For an example see <a href="https://docs.microsoft.com//windows/win32/menurc/using-resources#updating-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FindResourceEx" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadModule" />
    <seealso cref="LockResource" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
  <member name="Windows.LockResource">
    <summary>
      <para>Retrieves a pointer to the specified resource in memory.</para>
    </summary>
    <param name="hResData">
      <para>Type: <b>HGLOBAL</b></para>
      <para>A handle to the resource to be accessed. The <see cref="LoadResource function" /> returns this handle. Note that this parameter is listed as an <b>HGLOBAL</b> variable only for backward compatibility. Do not pass any value as a parameter other than a successful return value from the <b>LoadResource</b> function.</para>
    </param>
    <returns>
      <para>Type: <b>LPVOID</b></para>
      <para>If the loaded resource is available, the return value is a pointer to the first byte of the resource; otherwise, it is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The pointer returned by <b>LockResource</b> is valid until the module containing the resource is unloaded. It is not necessary to unlock resources because the system automatically deletes them when the process that created them terminates.</para>
      <para>Do not try to lock a resource by using the handle returned by the <see cref="FindResourceA function" /> or <see cref="FindResourceExA function" /> function. Such a handle points to random data.</para>
      <blockquote>
        <para>[!Note]
<b>LockResource</b> does not actually lock memory; it is just used to obtain a pointer to the memory containing the resource data. The name of the function comes from versions prior to Windows XP, when it was used to lock a global memory block allocated by <see cref="LoadResource" />.</para>
      </blockquote>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/win32/menurc/using-resources#updating-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/win32/menurc/resources">Resources</seealso>
    <seealso cref="FindResourceA function" />
    <seealso cref="FindResourceExA function" />
    <seealso cref="LoadResource function" />
  </member>
  <member name="Windows.RemoveDllDirectory">
    <summary>
      <para>Removes a directory that was added to the process DLL search path by using
<see cref="AddDllDirectory" />.</para>
    </summary>
    <param name="Cookie">
      <para>The cookie returned by <see cref="AddDllDirectory" /> when the
directory was added to the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value
is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After <b>RemoveDllDirectory</b> returns, the cookie is
no longer valid and should not be used.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>To call this function in an application, use the
<see cref="GetProcAddress" /> function to retrieve its address from
Kernel32.dll.
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> must be
installed on the target platform.</para>
    </remarks>
  </member>
  <member name="Windows.SetDefaultDllDirectories">
    <summary>
      <para>Specifies a default set of directories to search when the calling process loads a DLL. This search
path is used when <see cref="LoadLibraryEx" /> is called with no
<b>LOAD_LIBRARY_SEARCH</b> flags.</para>
    </summary>
    <param name="DirectoryFlags">
      <para>The directories to search. This parameter can be any combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, the application's installation directory is searched.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is a combination of <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>,
<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>.</para>
            <para>This value represents the recommended maximum number of directories an application should include in its
DLL search path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, %windows%\system32 is searched.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>
                </description>
              </item>
              <item>
                <description>0x00000400</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is used, any path explicitly added using the
<see cref="AddDllDirectory" /> or
<see cref="SetDllDirectory" /> function is searched. If more than
one directory has been added, the order in which those directories are searched is unspecified.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The DLL search path is the set of directories that are searched for a DLL when a full path is not specified in
a <see cref="LoadLibrary" /> or
<see cref="LoadLibraryEx" /> function call, or when a full path to the
DLL is specified but the system must search for dependent DLLs. For more information about the standard DLL search
path, see
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>.</para>
      <para>The standard DLL search path contains directories that can be vulnerable to a
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">DLL pre-loading attack</a>. An application can
use the <b>SetDefaultDllDirectories</b> function to
specify  a default DLL search path for the process that eliminates the most vulnerable directories and limits the
other directories that are searched. The process DLL search path applies only to the calling process and persists
for the life of the process.</para>
      <para>If the <i>DirectoryFlags</i> parameter specifies more than one flag, the directories are
searched in the following order:</para>
      <list type="bullet">
        <item>
          <description>The directory that contains the DLL (<b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b>). This
directory is searched only for dependencies of the DLL being loaded.</description>
        </item>
        <item>
          <description>The application directory (<b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>).</description>
        </item>
        <item>
          <description>Paths explicitly added to the application search path with the
<see cref="AddDllDirectory" /> function
(<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>) or the
<see cref="SetDllDirectory" /> function. If more than one path has
been added, the  order in which the paths are searched is unspecified.</description>
        </item>
        <item>
          <description>The System directory (<b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>).</description>
        </item>
      </list>
      <para>If <b>SetDefaultDllDirectories</b> does not
specify <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>, directories specified with the
<see cref="AddDllDirectory" /> function are used only for
<see cref="LoadLibraryEx" /> function calls that specify
<b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>.</para>
      <para>It is not possible to revert to the standard DLL search path or remove any directory specified with
<b>SetDefaultDllDirectories</b> from the search
path. However, the process DLL search path can be overridden by calling
<see cref="LoadLibraryEx" /> with one or more
<b>LOAD_LIBRARY_SEARCH</b> flags, and directories added with
<see cref="AddDllDirectory" /> can be removed by calling
<see cref="RemoveDllDirectory" />.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:  </b>To call this function in an application, use the
<see cref="GetProcAddress" /> function to retrieve its address from
Kernel32.dll.
<a href="https://support.microsoft.com/kb/2533623">KB2533623</a> must be
installed on the target platform.</para>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-security">Dynamic-Link Library Security</seealso>
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
    <seealso cref="RemoveDllDirectory" />
  </member>
  <member name="Windows.SizeofResource">
    <summary>
      <para>Retrieves the size, in bytes, of the specified resource.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose executable file contains the resource. Default is the module used to create the current process.</para>
    </param>
    <param name="hResInfo">
      <para>Type: <b>HRSRC</b></para>
      <para>A handle to the resource. This handle must be created by using the <see cref="FindResource" /> or <see cref="FindResourceEx" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>If the function succeeds, the return value is the number of bytes in the resource.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="FindResource" />
    <seealso cref="FindResourceEx" />
    <seealso href="https://msdn.microsoft.com/ff321356-c999-4021-a537-fbe863996e24">Resources</seealso>
  </member>
</doc>