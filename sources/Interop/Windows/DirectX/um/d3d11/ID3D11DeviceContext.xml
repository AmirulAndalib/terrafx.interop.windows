<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="ID3D11DeviceContext.Begin">
    <summary>
      <para>Mark the beginning of a series of commands.</para>
    </summary>
    <param name="pAsync">
      <para>Type: <b><see cref="ID3D11Asynchronous" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Asynchronous" /> interface.</para>
    </param>
    <remarks>
      <para>Use <see cref="ID3D11DeviceContext.End" /> to mark the ending of the series of commands.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ClearDepthStencilView">
    <summary>
      <para>Clears the depth-stencil resource.</para>
    </summary>
    <param name="pDepthStencilView">
      <para>Type: <b><see cref="ID3D11DepthStencilView" />*</b></para>
      <para>Pointer to the depth stencil to be cleared.</para>
    </param>
    <param name="ClearFlags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Identify the type of data to clear (see <see cref="D3D11_CLEAR_FLAG" />).</para>
    </param>
    <param name="Depth">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">FLOAT</a></b></para>
      <para>Clear the depth buffer with this value. This value will be clamped between 0 and 1.</para>
    </param>
    <param name="Stencil">
      <para>Type: <b>UINT8</b></para>
      <para>Clear the stencil buffer with this value.</para>
    </param>
    <remarks>
      <list type="table">
        <listheader>
          <description>
            <para>Differences between Direct3D 9 and Direct3D 11/10:</para>
            <para>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</para>
          </description>
        </listheader>
      </list>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ClearRenderTargetView">
    <summary>
      <para>Set all the elements in a render target to one value.</para>
    </summary>
    <param name="pRenderTargetView">
      <para>Type: <b><see cref="ID3D11RenderTargetView" />*</b></para>
      <para>Pointer to the render target.</para>
    </param>
    <param name="ColorRGBA">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">FLOAT</a>[4]</b></para>
      <para>A 4-component array that represents the color to fill the render target with.</para>
    </param>
    <remarks>
      <para>Applications that wish to clear a render target to a specific integer value bit pattern should render a screen-aligned quad instead of using this method.  The reason for this is because this method accepts as input a floating point value, which may not have the same bit pattern as the original integer.</para>
      <list type="table">
        <listheader>
          <description>
            <para>Differences between Direct3D 9 and Direct3D 11/10:</para>
            <para>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</para>
          </description>
        </listheader>
      </list>
      <para>When using <see cref="D3D_FEATURE_LEVEL_9_x" />, <see cref="ClearRenderTargetView" /> only clears the first array slice in the render target view. This can impact (for example) cube map rendering scenarios. Applications should create a render target view for each face or array slice, then clear each view individually.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ClearState">
    <summary>
      <para>Restore all default settings.</para>
    </summary>
    <remarks>
      <para>This method resets any device context to the default settings. This sets all input/output resource slots, shaders, input layouts, predications, scissor rectangles, depth-stencil state, rasterizer state, blend state, sampler state, and viewports to <b>NULL</b>. The primitive topology is set to UNDEFINED.</para>
      <para>For a scenario where you would like to clear a list of commands recorded so far, call <see cref="ID3D11DeviceContext.FinishCommandList" /> and throw away the resulting <see cref="ID3D11CommandList" />.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ClearUnorderedAccessViewFloat">
    <summary>
      <para>Clears an <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-cs-resources">unordered access</a> resource with a float value.</para>
    </summary>
    <param name="pUnorderedAccessView">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />*</b></para>
      <para>The <see cref="ID3D11UnorderedAccessView" /> to clear.</para>
    </param>
    <param name="Values">
      <para>Type: <b>const FLOAT[4]</b></para>
      <para>Values to copy to corresponding channels, see remarks.</para>
    </param>
    <remarks>
      <para>This API works on FLOAT, UNORM, and SNORM unordered access views (UAVs), with format conversion from FLOAT to *NORM where appropriate. On other UAVs, the operation is invalid and the call will not reach the driver.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ClearUnorderedAccessViewUint">
    <summary>
      <para>Clears an <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-cs-resources">unordered access</a> resource with bit-precise values.</para>
    </summary>
    <param name="pUnorderedAccessView">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />*</b></para>
      <para>The <see cref="ID3D11UnorderedAccessView" /> to clear.</para>
    </param>
    <param name="Values">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>[4]</b></para>
      <para>Values to copy to corresponding channels, see remarks.</para>
    </param>
    <remarks>
      <para>This API copies the lower n<sub>i</sub> bits from each array element i to the corresponding channel, where n<sub>i</sub> is the number of bits in
the ith channel of the resource format (for example, R8G8B8_FLOAT has 8 bits for the first 3 channels). This works on any UAV with no format conversion.
For a raw or structured buffer view, only the first array element value is used.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CopyResource">
    <summary>
      <para>Copy the entire contents of the source resource to the destination resource using the GPU.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D11Resource" /> interface that represents the destination resource.</para>
    </param>
    <param name="pSrcResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D11Resource" /> interface that represents the source resource.</para>
    </param>
    <remarks>
      <para>This method is unusual in that it causes the GPU to perform the copy operation (similar to a memcpy by the CPU). As a result, it has a few restrictions designed for improving performance. For instance, the source and destination resources:</para>
      <list type="bullet">
        <item>
          <description>Must be different resources.</description>
        </item>
        <item>
          <description>Must be the same type.</description>
        </item>
        <item>
          <description>Must have identical dimensions (including width, height, depth, and size as appropriate).</description>
        </item>
        <item>
          <description>Must have compatible <see cref="DXGI formats" />, which means the formats must be identical or at least from the same type group. For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <see cref="CopyResource" /> can copy between a few format types. For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">Format Conversion using Direct3D 10.1</a>.</description>
        </item>
        <item>
          <description>Can't be currently mapped.</description>
        </item>
      </list>
      <b>CopyResource</b> only supports copy; it doesn't support any stretch, color key, or blend. <see cref="CopyResource" /> can reinterpret the resource data between a few format types. For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">Format Conversion using Direct3D 10.1</a>.
<para>You can't use an <see cref="Immutable" /> resource as a destination. You can use a   <see cref="depth-stencil" /> resource as either a source or a destination provided that the feature level is D3D_FEATURE_LEVEL_10_1 or greater. For feature levels 9_x, resources created with the D3D11_BIND_DEPTH_STENCIL flag can only be used as a source for <see cref="CopyResource" />.  Resources created with multisampling capability (see <see cref="DXGI_SAMPLE_DESC" />) can be used as source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if one is multisampled and the other is not multisampled, the call to <b>ID3D11DeviceContext.CopyResource</b> fails. Use <see cref="ID3D11DeviceContext.ResolveSubresource" /> to resolve a multisampled resource to a resource that is not multisampled.</para><para>The method is an asynchronous call, which may be added to the command-buffer queue. This attempts to remove pipeline stalls that may occur when copying data. For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-mapping">performance considerations</a>.</para><para>We recommend to use <see cref="ID3D11DeviceContext.CopySubresourceRegion" /> instead if you only need to copy a portion of the data in a resource.</para></remarks>
    <seealso cref="ID3D11DeviceContext" />
    <seealso cref="ID3D11Resource" />
  </member>
  <member name="ID3D11DeviceContext.CopyStructureCount">
    <summary>
      <para>Copies data from a buffer holding variable length data.</para>
    </summary>
    <param name="pDstBuffer">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Pointer to <see cref="ID3D11Buffer" />.  This can be any buffer resource that other copy commands,
such as <see cref="ID3D11DeviceContext.CopyResource" /> or <see cref="ID3D11DeviceContext.CopySubresourceRegion" />, are able to write to.</para>
    </param>
    <param name="DstAlignedByteOffset">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Offset from the start of <i>pDstBuffer</i> to write 32-bit UINT structure (vertex) count from <i>pSrcView</i>.</para>
    </param>
    <param name="pSrcView">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />*</b></para>
      <para>Pointer to an <see cref="ID3D11UnorderedAccessView" /> of a Structured Buffer resource created with either
<see cref="D3D11_BUFFER_UAV_FLAG_APPEND" /> or <b>D3D11_BUFFER_UAV_FLAG_COUNTER</b> specified
when the UAV was created.   These types of resources have hidden counters tracking "how many" records have
been written.</para>
    </param>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CopySubresourceRegion">
    <summary>
      <para>Copy a region from a source resource to a destination resource.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the destination resource (see <see cref="ID3D11Resource" />).</para>
    </param>
    <param name="DstSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Destination subresource index.</para>
    </param>
    <param name="DstX">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The x-coordinate of the upper left corner of the destination region.</para>
    </param>
    <param name="DstY">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</para>
    </param>
    <param name="DstZ">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
    </param>
    <param name="pSrcResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the source resource (see <see cref="ID3D11Resource" />).</para>
    </param>
    <param name="SrcSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Source subresource index.</para>
    </param>
    <param name="pSrcBox">
      <para>Type: <b>const <see cref="D3D11_BOX" />*</b></para>
      <para>A pointer to a 3D box (see <see cref="D3D11_BOX" />) that defines the source subresource that can be copied. If <b>NULL</b>, the entire source subresource is copied. The box must fit within the source resource.</para>
      <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>CopySubresourceRegion</b> doesn't perform a copy operation.</para>
    </param>
    <remarks>
      <para>The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the source resource, the behavior of <b>CopySubresourceRegion</b> is undefined. If you created a device that supports the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-layers">debug layer</a>, the debug output reports an error on this invalid <b>CopySubresourceRegion</b> call. Invalid parameters to <b>CopySubresourceRegion</b> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the removal of the rendering device.</para>
      <para>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. <see cref="D3D11CalcSubresource" /> is a helper function for calculating subresource indexes.</para>
      <para>
        <b>CopySubresourceRegion</b> performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources:</para>
      <list type="bullet">
        <item>
          <description>Must be different subresources (although they can be from the same resource).</description>
        </item>
        <item>
          <description>Must be the same type.</description>
        </item>
        <item>
          <description>Must have compatible DXGI formats (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopySubresourceRegion</b> can copy between a few format types. For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">Format Conversion using Direct3D 10.1</a>.</description>
        </item>
        <item>
          <description>May not be currently mapped.</description>
        </item>
      </list>
      <para>
        <b>CopySubresourceRegion</b> only supports copy; it doesn't support any stretch, color key, or blend. <b>CopySubresourceRegion</b> can reinterpret the resource data between a few format types. For more info, see <a href="https://docs.microsoft.com//windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-block-compression#format-conversion-using-direct3d-101">Format conversion using Direct3D 10.1</a>.</para>
      <para>If your app needs to copy an entire resource, we recommend to use <see cref="ID3D11DeviceContext.CopyResource" /> instead.</para>
      <para>
        <b>CopySubresourceRegion</b> is an asynchronous call, which may be added to the command-buffer queue, this attempts to remove pipeline stalls that may occur when copying data. For more information about pipeline stalls, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-mapping">performance considerations</a>.</para>
      <para>
        <b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <see cref="ID3D11DeviceContext.UpdateSubresource" /> or <b>CopySubresourceRegion</b> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.</para>
      <para>
        <b>Note</b>  <b>Applies only to feature level 9_x hardware</b> You can't use <b>CopySubresourceRegion</b> to copy mipmapped volume textures.</para>
      <para>
        <b>Note</b>  <b>Applies only to feature levels 9_x</b> Subresources created with the D3D11_BIND_DEPTH_STENCIL flag can only be used as a source for <b>CopySubresourceRegion</b>.</para>
      <para>
        <b>Note</b>  If you use <b>CopySubresourceRegion</b> with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. In this situation, you must pass 0 to the <i>DstX</i>, <i>DstY</i>, and <i>DstZ</i> parameters and <b>NULL</b> to the <i>pSrcBox</i> parameter. In addition, source and destination resources, which are represented by the <i>pSrcResource</i> and <i>pDstResource</i> parameters, should have identical sample count values.</para>
      <h3>Example</h3>
      <para>The following code snippet copies a box (located at (120,100),(200,220)) from a source texture into a region (10,20),(90,140) in a destination texture.</para>
      <code>D3D11_BOX sourceRegion;
sourceRegion.left = 120;
sourceRegion.right = 200;
sourceRegion.top = 100;
sourceRegion.bottom = 220;
sourceRegion.front = 0;
sourceRegion.back = 1;

pd3dDeviceContext-&gt;CopySubresourceRegion( pDestTexture, 0, 10, 20, 0, pSourceTexture, 0, &amp;amp;amp;amp;amp;amp;sourceRegion );

</code>
      <para>Notice, that for a 2D texture, front and back are set to 0 and 1 respectively.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
    <seealso cref="ID3D11Resource" />
  </member>
  <member name="ID3D11DeviceContext.CSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the compute-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSGetSamplers">
    <summary>
      <para>Get an array of sampler state interfaces from the compute-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />).</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSGetShader">
    <summary>
      <para>Get the compute shader currently set on the device.</para>
    </summary>
    <param name="ppComputeShader">
      <para>Type: <b><see cref="ID3D11ComputeShader" />**</b></para>
      <para>Address of a pointer to a Compute shader (see <see cref="ID3D11ComputeShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSGetShaderResources">
    <summary>
      <para>Get the compute-shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSGetUnorderedAccessViews">
    <summary>
      <para>Gets an array of views for an unordered resource.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index of the first element in the zero-based array to return (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumUAVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of views to get (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppUnorderedAccessViews">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />**</b></para>
      <para>A pointer to an array of interface pointers (see <see cref="ID3D11UnorderedAccessView" />) to get.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call <b>IUnknown.Release</b> on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSSetConstantBuffers">
    <summary>
      <para>Sets the constant buffers used by the compute-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The Direct3D 11.1 runtime, which is available starting with Windows 8, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants – 4<i>32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4</i>32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>If the application wants the shader to access other parts of the buffer, it must call the <see cref="CSSetConstantBuffers1" /> method instead.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the compute-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <code>//Default sampler state:
D3D11_SAMPLER_DESC SamplerDesc;
SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.MipLODBias = 0;
SamplerDesc.MaxAnisotropy = 1;
SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
SamplerDesc.BorderColor[0] = 1.0f;
SamplerDesc.BorderColor[1] = 1.0f;
SamplerDesc.BorderColor[2] = 1.0f;
SamplerDesc.BorderColor[3] = 1.0f;
SamplerDesc.MinLOD = -FLT_MAX;
SamplerDesc.MaxLOD = FLT_MAX;

</code>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSSetShader">
    <summary>
      <para>Set a compute shader to the device.</para>
    </summary>
    <param name="pComputeShader">
      <para>Type: <b><see cref="ID3D11ComputeShader" />*</b></para>
      <para>Pointer to a compute shader (see <see cref="ID3D11ComputeShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the compute-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.CSSetUnorderedAccessViews">
    <summary>
      <para>Sets an array of views for an unordered resource.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index of the first element in the zero-based array to begin setting  (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - 1). D3D11_1_UAV_SLOT_COUNT is defined as 64.</para>
    </param>
    <param name="NumUAVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of views to set (ranges from 0 to D3D11_1_UAV_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppUnorderedAccessViews">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />*</b></para>
      <para>A pointer to an array of <see cref="ID3D11UnorderedAccessView" /> pointers to be set by the method.</para>
    </param>
    <param name="pUAVInitialCounts">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array of append and consume buffer offsets. A value of -1 indicates to keep the current offset. Any other values set the hidden counter
for that appendable and consumable UAV. <i>pUAVInitialCounts</i> is only relevant for UAVs that were created with either
<see cref="D3D11_BUFFER_UAV_FLAG_APPEND" /> or <b>D3D11_BUFFER_UAV_FLAG_COUNTER</b> specified
when the UAV was created; otherwise, the argument is ignored.</para>
    </param>
    <remarks>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.Dispatch">
    <summary>
      <para>Execute a command list from a thread group.</para>
    </summary>
    <param name="ThreadGroupCountX">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the x direction. <i>ThreadGroupCountX</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).</para>
    </param>
    <param name="ThreadGroupCountY">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the y direction. <i>ThreadGroupCountY</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).</para>
    </param>
    <param name="ThreadGroupCountZ">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the z direction.  <i>ThreadGroupCountZ</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
In feature level 10 the value for <i>ThreadGroupCountZ</i> must be 1.</para>
    </param>
    <remarks>
      <para>You call the <b>Dispatch</b> method to execute commands in a <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-compute-shader">compute shader</a>. A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector
given by (x,y,z).</para>
      <para>In the following illustration, assume a thread group with 50 threads where the size of the group is given by (5,5,2). A single thread is identified from a
thread group with 50 threads in it, using the vector (4,1,1).</para>
      <para>
        <img alt="Illustration of a single thread within a thread group of 50 threads" src="https://docs.microsoft.com/windows/win32/api/d3d11mages/d3d11_thread_group_1.png" />
      </para>
      <para>The following illustration shows the relationship between the parameters passed to <b>ID3D11DeviceContext.Dispatch</b>, Dispatch(5,3,2), the values specified in the <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/sm5-attributes-numthreads">numthreads</a> attribute, numthreads(10,8,3), and values that will passed to the compute shader for the thread-related system values
(<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff471569(v=vs.85)">SV_GroupIndex</a>,<a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/sv-dispatchthreadid">SV_DispatchThreadID</a>,<a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/sv-groupthreadid">SV_GroupThreadID</a>,<a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/sv-groupid">SV_GroupID</a>).</para>
      <para>
        <img alt="Illustration of the relationship between Dispatch, thread groups, and threads" src="https://docs.microsoft.com/windows/win32/api/d3d11mages/ThreadGroupIDs.png" />
      </para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DispatchIndirect">
    <summary>
      <para>Execute a command list over one or more thread groups.</para>
    </summary>
    <param name="pBufferForArgs">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Buffer" />, which must be loaded with data that matches the argument list for <see cref="ID3D11DeviceContext.Dispatch" />.</para>
    </param>
    <param name="AlignedByteOffsetForArgs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A byte-aligned offset between the start of the buffer and the arguments.</para>
    </param>
    <remarks>
      <para>You call the <b>DispatchIndirect</b> method to execute commands in a <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-compute-shader">compute shader</a>.</para>
      <para>When an application creates a buffer that is associated with the <see cref="ID3D11Buffer" /> interface that  <i>pBufferForArgs</i> points to, the application must set the <see cref="D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS" /> flag in the <b>MiscFlags</b> member of the <see cref="D3D11_BUFFER_DESC" /> structure that describes the buffer. To create the buffer, the application calls the <see cref="ID3D11Device.CreateBuffer" /> method and in this call passes a pointer to <b>D3D11_BUFFER_DESC</b> in the <i>pDesc</i> parameter.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.Draw">
    <summary>
      <para>Draw non-indexed, non-instanced primitives.</para>
    </summary>
    <param name="VertexCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of vertices to draw.</para>
    </param>
    <param name="StartVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index of the first vertex, which is usually an offset in a vertex buffer.</para>
    </param>
    <remarks>
      <para>
        <b>Draw</b> submits work to the rendering pipeline.</para>
      <para>The vertex data for a draw call normally comes from a vertex buffer that is bound to the pipeline.</para>
      <para>Even without any vertex buffer bound to the pipeline, you can generate your own vertex data in your vertex shader by using the <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics">SV_VertexID</a> system-value semantic to determine the current vertex that the runtime is processing.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawAuto">
    <summary>
      <para>Draw geometry of an unknown size.</para>
    </summary>
    <remarks>
      <para>A draw API submits work to the rendering pipeline. This API submits work of an unknown size that was processed by the input assembler, vertex shader, and stream-output stages;  the work may or may not have gone through the geometry-shader stage.</para>
      <para>After data has been streamed out to stream-output stage buffers, those buffers can be again bound to the Input Assembler stage at input slot 0 and DrawAuto will draw them without the application needing to know the amount of data that was written to the buffers. A measurement of the amount of data written to the SO stage buffers is maintained internally when the data is streamed out. This means that the CPU does not need to fetch the measurement before re-binding the data that was streamed as input data. Although this amount is tracked internally, it is still the responsibility of applications to use input layouts to describe the format of the data in the SO stage buffers so that the layouts are available when the buffers are again bound to the input assembler.</para>
      <para>The following diagram shows the DrawAuto process.</para>
      <para>
        <img alt="Diagram of DrawAuto as data moves through several stages to a buffer and then back to the Input Assembler stage" src="https://docs.microsoft.com/windows/win32/api/d3d11mages/d3d11_pipeline_stages_drawauto.png" />
      </para>
      <para>Calling DrawAuto does not change the state of the streaming-output buffers that were bound again as inputs.</para>
      <para>DrawAuto only works when drawing with one input buffer bound as an input to the IA stage at slot 0. Applications must create the SO buffer resource with both binding flags, <see cref="D3D11_BIND_VERTEX_BUFFER" /> and <b>D3D11_BIND_STREAM_OUTPUT</b>.</para>
      <para>This API does not support indexing or instancing.</para>
      <para>If an application needs to retrieve the size of the streaming-output buffer, it can query for statistics on streaming output by using <see cref="D3D11_QUERY_SO_STATISTICS" />.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawIndexed">
    <summary>
      <para>Draw indexed, non-instanced primitives.</para>
    </summary>
    <param name="IndexCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of indices to draw.</para>
    </param>
    <param name="StartIndexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The location of the first index read by the GPU from the index buffer.</para>
    </param>
    <param name="BaseVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">INT</a></b></para>
      <para>A value added to each index before reading a vertex from the vertex buffer.</para>
    </param>
    <remarks>
      <para>A draw API submits work to the rendering pipeline.</para>
      <para>If the sum of both indices is negative, the result of the function call is undefined.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawIndexedInstanced">
    <summary>
      <para>Draw indexed, instanced primitives.</para>
    </summary>
    <param name="IndexCountPerInstance">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/winprog/windows-data-types">UINT</a></b></para>
      <para>Number of indices read from the index buffer for each instance.</para>
    </param>
    <param name="InstanceCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/winprog/windows-data-types">UINT</a></b></para>
      <para>Number of instances to draw.</para>
    </param>
    <param name="StartIndexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/winprog/windows-data-types">UINT</a></b></para>
      <para>The location of the first index read by the GPU from the index buffer.</para>
    </param>
    <param name="BaseVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/winprog/windows-data-types">INT</a></b></para>
      <para>A value added to each index before reading a vertex from the vertex buffer.</para>
    </param>
    <param name="StartInstanceLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/winprog/windows-data-types">UINT</a></b></para>
      <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
    </param>
    <remarks>
      <para>A draw API submits work to the rendering pipeline.</para>
      <para>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one for per-vertex data and a second buffer for per-instance data.</para>
      <para>The second buffer is needed only if the input layout that you use has elements that use <see cref="D3D11_INPUT_PER_INSTANCE_DATA" /> as the input element classification buffer for per-instance data.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawIndexedInstancedIndirect">
    <summary>
      <para>Draw indexed, instanced, GPU-generated primitives.</para>
    </summary>
    <param name="pBufferForArgs">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Buffer" />, which is a buffer containing the GPU generated primitives.</para>
    </param>
    <param name="AlignedByteOffsetForArgs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Offset in <i>pBufferForArgs</i> to the start of the GPU generated primitives.</para>
    </param>
    <remarks>
      <para>When an application creates a buffer that is associated with the <see cref="ID3D11Buffer" /> interface that  <i>pBufferForArgs</i> points to, the application must set the <see cref="D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS" /> flag in the <b>MiscFlags</b> member of the <see cref="D3D11_BUFFER_DESC" /> structure that describes the buffer. To create the buffer, the application calls the <see cref="ID3D11Device.CreateBuffer" /> method and in this call passes a pointer to <b>D3D11_BUFFER_DESC</b> in the <i>pDesc</i> parameter.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawInstanced">
    <summary>
      <para>Draw non-indexed, instanced primitives.</para>
    </summary>
    <param name="VertexCountPerInstance">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of vertices to draw.</para>
    </param>
    <param name="InstanceCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of instances to draw.</para>
    </param>
    <param name="StartVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index of the first vertex.</para>
    </param>
    <param name="StartInstanceLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
    </param>
    <remarks>
      <para>A draw API submits work to the rendering pipeline.</para>
      <para>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be
to draw the same object with different positions and colors.</para>
      <para>The vertex data for an instanced draw call normally comes from a vertex buffer that is bound to the pipeline.
However, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DrawInstancedIndirect">
    <summary>
      <para>Draw instanced, GPU-generated primitives.</para>
    </summary>
    <param name="pBufferForArgs">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Buffer" />, which is a buffer containing the GPU generated primitives.</para>
    </param>
    <param name="AlignedByteOffsetForArgs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Offset in <i>pBufferForArgs</i> to the start of the GPU generated primitives.</para>
    </param>
    <remarks>
      <para>When an application creates a buffer that is associated with the <see cref="ID3D11Buffer" /> interface that  <i>pBufferForArgs</i> points to, the application must set the <see cref="D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS" /> flag in the <b>MiscFlags</b> member of the <see cref="D3D11_BUFFER_DESC" /> structure that describes the buffer. To create the buffer, the application calls the <see cref="ID3D11Device.CreateBuffer" /> method and in this call passes a pointer to <b>D3D11_BUFFER_DESC</b> in the <i>pDesc</i> parameter.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the domain-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSGetSamplers">
    <summary>
      <para>Get an array of sampler state interfaces from the domain-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />).</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSGetShader">
    <summary>
      <para>Get the domain shader currently set on the device.</para>
    </summary>
    <param name="ppDomainShader">
      <para>Type: <b><see cref="ID3D11DomainShader" />**</b></para>
      <para>Address of a pointer to a domain shader (see <see cref="ID3D11DomainShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSGetShaderResources">
    <summary>
      <para>Get the domain-shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSSetConstantBuffers">
    <summary>
      <para>Sets the constant buffers used by the domain-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The Direct3D 11.1 runtime, which is available starting with Windows 8, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants – 4<i>32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4</i>32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>If the application wants the shader to access other parts of the buffer, it must call the <see cref="DSSetConstantBuffers1" /> method instead.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the domain-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <code>
//Default sampler state:
D3D11_SAMPLER_DESC SamplerDesc;
SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.MipLODBias = 0;
SamplerDesc.MaxAnisotropy = 1;
SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
SamplerDesc.BorderColor[0] = 1.0f;
SamplerDesc.BorderColor[1] = 1.0f;
SamplerDesc.BorderColor[2] = 1.0f;
SamplerDesc.BorderColor[3] = 1.0f;
SamplerDesc.MinLOD = -FLT_MAX;
SamplerDesc.MaxLOD = FLT_MAX;

</code>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSSetShader">
    <summary>
      <para>Set a domain shader to the device.</para>
    </summary>
    <param name="pDomainShader">
      <para>Type: <b><see cref="ID3D11DomainShader" />*</b></para>
      <para>Pointer to a domain shader (see <see cref="ID3D11DomainShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.DSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the domain-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.End">
    <summary>
      <para>Mark the end of a series of commands.</para>
    </summary>
    <param name="pAsync">
      <para>Type: <b><see cref="ID3D11Asynchronous" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Asynchronous" /> interface.</para>
    </param>
    <remarks>
      <para>Use <see cref="ID3D11DeviceContext.Begin" /> to mark the beginning of the series of commands.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ExecuteCommandList">
    <summary>
      <para>Queues commands from a command list onto a device.</para>
    </summary>
    <param name="pCommandList">
      <para>Type: <b><see cref="ID3D11CommandList" />*</b></para>
      <para>A pointer to an <see cref="ID3D11CommandList" /> interface that encapsulates a command list.</para>
    </param>
    <param name="RestoreContextState">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
      <para>A Boolean flag that determines whether the target context state is saved prior to and restored after the execution of a command list. Use <b>TRUE</b> to indicate that the runtime needs to save and restore the state. Use <b>FALSE</b> to indicate that no state shall be saved or restored, which causes the target context to  return to its default state after the command list executes. Applications should typically use <b>FALSE</b> unless they will restore the state to be nearly equivalent to the state that the runtime would restore if <b>TRUE</b> were passed. When applications use <b>FALSE</b>, they can avoid unnecessary and inefficient state transitions.</para>
    </param>
    <remarks>
      <para>Use this method to play back a command list that was recorded by a deferred context on any thread.</para>
      <para>A call to <b>ExecuteCommandList</b> of a command list from a deferred context onto the immediate context is required for the recorded commands to be executed on the graphics processing unit (GPU). A call to <b>ExecuteCommandList</b> of a command list from a deferred context onto another deferred context can be used to merge recorded lists. But to run the commands from the merged deferred command list on the GPU, you need to execute them on the immediate context.</para>
      <para>This method performs some runtime validation related to queries. Queries that are begun in a device context cannot be manipulated indirectly by executing a command list (that is, Begin or End was invoked against the same query by the deferred context which generated the command list). If such a condition occurs, the ExecuteCommandList method does not execute the command list. However, the state of the device context is still maintained, as would be expected (<see cref="ID3D11DeviceContext.ClearState" /> is performed, unless the application indicates to preserve the device context state).</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.FinishCommandList">
    <summary>
      <para>Create a command list and record graphics commands into it.</para>
    </summary>
    <param name="RestoreDeferredContextState">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
      <para>A Boolean flag that determines whether the runtime saves deferred context state before it executes  <b>FinishCommandList</b> and restores it afterwards. Use <b>TRUE</b> to indicate that the runtime needs to save and restore the state. Use <b>FALSE</b> to indicate that the runtime will not save or restore any state. In this case, the deferred context will  return to its default state after the call to  <b>FinishCommandList</b> completes. For information about default state, see <see cref="ID3D11DeviceContext.ClearState" />. Typically, use <b>FALSE</b> unless you restore the state to be nearly equivalent to the state that the runtime would restore if you passed <b>TRUE</b>. When you use <b>FALSE</b>, you can avoid unnecessary and inefficient state transitions.</para>
      <para>
        <b>Note</b>  This parameter does not affect the command list that the current call to <b>FinishCommandList</b> returns. However, this parameter affects the command list of the next call to <b>FinishCommandList</b> on the same deferred context.</para>
    </param>
    <param name="ppCommandList">
      <para>Type: <b><see cref="ID3D11CommandList" />**</b></para>
      <para>Upon completion of the method, the passed pointer to an <see cref="ID3D11CommandList" /> interface pointer is initialized with the recorded command list information. The resulting <b>ID3D11CommandList</b> object is immutable and can only be used with <see cref="ID3D11DeviceContext.ExecuteCommandList" />.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns S_OK if successful; otherwise, returns one of the following:</para>
      <list type="bullet">
        <item>
          <description>Returns DXGI_ERROR_DEVICE_REMOVED if the video card has been physically removed from the system, or a driver upgrade for the video card has occurred. If this error occurs, you should destroy and recreate the device.</description>
        </item>
        <item>
          <description>Returns DXGI_ERROR_INVALID_CALL if <b>FinishCommandList</b> cannot be called from the current context. See remarks.
</description>
        </item>
        <item>
          <description>Returns E_OUTOFMEMORY if the application has exhausted available memory.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Create a command list from a deferred context and record commands into it by calling <b>FinishCommandList</b>. Play back a command list with an immediate context by calling <see cref="ID3D11DeviceContext.ExecuteCommandList" />.</para>
      <para>Immediate context state is cleared before and after a command list is executed. A command list has no concept of inheritance. Each call to <b>FinishCommandList</b> will record only the state set since any previous call to  <b>FinishCommandList</b>.</para>
      <para>For example, the state of a <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-intro">device context</a> is its render state or pipeline state. To retrieve device context state, an application can call  <see cref="ID3D11DeviceContext.GetData" /> or  <see cref="ID3D11DeviceContext.GetPredication" />.</para>
      <para>For more information about how to use <b>FinishCommandList</b>, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list-record">How to: Record a Command List</a>.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.Flush">
    <summary>
      <para>Sends queued-up commands in the command buffer to the graphics processing unit (GPU).</para>
    </summary>
    <remarks>
      <para>Most applications don't need to call this method. If an application calls this method when not necessary, it incurs a performance penalty.
Each call to <b>Flush</b> incurs a significant amount of overhead.</para>
      <para>When Microsoft Direct3D state-setting, present, or draw commands are called by an application, those commands are queued into an internal command buffer.
<b>Flush</b> sends those commands to the GPU for processing. Typically, the Direct3D runtime sends these commands to the GPU automatically whenever the runtime determines that
they need to be sent, such as when the command buffer is full or when an application maps a resource. <b>Flush</b> sends the commands manually.</para>
      <para>We recommend that you use <b>Flush</b> when the CPU waits for an arbitrary amount of time (such as when
you call the <see cref="Sleep" /> function).</para>
      <para>Because <b>Flush</b> operates asynchronously,  it can return either before or after the GPU finishes executing the queued graphics commands. However, the graphics commands eventually always complete. You can call the <see cref="ID3D11Device.CreateQuery" /> method with the <see cref="D3D11_QUERY_EVENT" /> value to create an event query; you can then use that event query in a call to the <see cref="ID3D11DeviceContext.GetData" /> method to determine when the GPU is finished processing the graphics commands.</para>
      <para>Microsoft Direct3D 11 defers the destruction of objects. Therefore, an application can't rely upon objects immediately being destroyed. By calling <b>Flush</b>, you destroy any
objects whose destruction was deferred.  If an application requires synchronous destruction of an object, we recommend that the application release all its
references, call <see cref="ID3D11DeviceContext.ClearState" />, and then call <b>Flush</b>.</para>
      <h3>Deferred Destruction Issues with Flip Presentation Swap Chains</h3>
      <para>Direct3D 11 defers the destruction of objects like views and resources until it can efficiently destroy them. This deferred destruction can cause problems with flip presentation model swap chains. Flip presentation model swap chains have the <see cref="DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL" /> flag set. When you create a flip presentation model swap chain, you can associate only one swap chain at a time with an <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">HWND</a>, <b>IWindow</b>, or composition surface. If an application attempts to destroy a flip presentation model swap chain and replace it with another swap chain, the original swap chain is not destroyed when the application immediately frees all of the original swap chain's references.</para>
      <para>Most applications typically use the <see cref="IDXGISwapChain.ResizeBuffers" /> method for the majority of scenarios where they replace new swap chain buffers for old swap chain buffers. However, if an application must actually destroy an old swap chain and create a new swap chain, the application must force the destruction of all objects that the application freed. To force the destruction, call <see cref="ID3D11DeviceContext.ClearState" /> (or otherwise ensure no views are bound to pipeline state), and then call <b>Flush</b> on the immediate context. You must force destruction before you call <see cref="IDXGIFactory2.CreateSwapChainForHwnd" />, <see cref="IDXGIFactory2.CreateSwapChainForCoreWindow" />, or <see cref="IDXGIFactory2.CreateSwapChainForComposition" /> again to create a new swap chain.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GenerateMips">
    <summary>
      <para>Generates mipmaps for the given shader resource.</para>
    </summary>
    <param name="pShaderResourceView">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>A pointer to an <see cref="ID3D11ShaderResourceView" /> interface that represents the shader resource.</para>
    </param>
    <remarks>
      <para>You can call <b>GenerateMips</b> on any shader-resource view to generate the lower mipmap levels for the shader resource. <b>GenerateMips</b> uses the largest mipmap level of the view to recursively generate the lower levels of the mip and stops with the smallest level that is specified by the view. If the base resource wasn't created with <see cref="D3D11_BIND_RENDER_TARGET" />, <see cref="D3D11_BIND_SHADER_RESOURCE" />, and <see cref="D3D11_RESOURCE_MISC_GENERATE_MIPS" />, the call to <b>GenerateMips</b> has no effect.</para>
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">Feature levels</a> 9.1, 9.2, and 9.3 can't support automatic generation of mipmaps for 3D (volume) textures.</para>
      <para>Video adapters that support <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1 and higher support generating mipmaps if you use any of these formats:</para>
      <code>
DXGI_FORMAT_R8G8B8A8_UNORM
DXGI_FORMAT_R8G8B8A8_UNORM_SRGB
DXGI_FORMAT_B5G6R5_UNORM
DXGI_FORMAT_B8G8R8A8_UNORM
DXGI_FORMAT_B8G8R8A8_UNORM_SRGB
DXGI_FORMAT_B8G8R8X8_UNORM
DXGI_FORMAT_B8G8R8X8_UNORM_SRGB

</code>
      <para>Video adapters that support <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.2 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature level 9.1:</para>
      <code>
DXGI_FORMAT_R16G16B16A16_FLOAT
DXGI_FORMAT_R16G16B16A16_UNORM
DXGI_FORMAT_R16G16_FLOAT
DXGI_FORMAT_R16G16_UNORM
DXGI_FORMAT_R32_FLOAT

</code>
      <para>Video adapters that support <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.3 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1 and 9.2:</para>
      <code>
DXGI_FORMAT_R32G32B32A32_FLOAT
DXGI_FORMAT_B4G4R4A4 (optional)

</code>
      <para>Video adapters that support <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 10 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1, 9.2, and 9.3:</para>
      <code>
DXGI_FORMAT_R32G32B32_FLOAT (optional)
DXGI_FORMAT_R16G16B16A16_SNORM
DXGI_FORMAT_R32G32_FLOAT
DXGI_FORMAT_R10G10B10A2_UNORM
DXGI_FORMAT_R11G11B10_FLOAT
DXGI_FORMAT_R8G8B8A8_SNORM
DXGI_FORMAT_R16G16_SNORM
DXGI_FORMAT_R8G8_UNORM
DXGI_FORMAT_R8G8_SNORM
DXGI_FORMAT_R16_FLOAT
DXGI_FORMAT_R16_UNORM
DXGI_FORMAT_R16_SNORM
DXGI_FORMAT_R8_UNORM
DXGI_FORMAT_R8_SNORM
DXGI_FORMAT_A8_UNORM
DXGI_FORMAT_B5G5R5A1_UNORM (optional)

</code>
      <para>For all other unsupported formats, <b>GenerateMips</b> will silently fail.</para>
    </remarks>
    <seealso cref="DXGI_FORMAT" />
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GetContextFlags">
    <summary>
      <para>Gets the initialization flags associated with the current deferred context.</para>
    </summary>
    <remarks>
      <para>The GetContextFlags method gets the flags that were supplied to the <i>ContextFlags</i> parameter of <see cref="ID3D11Device.CreateDeferredContext" />; however, the context flag is reserved for future use.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GetData">
    <summary>
      <para>Get data from the graphics processing unit (GPU) asynchronously.</para>
    </summary>
    <param name="pAsync">
      <para>Type: <b><see cref="ID3D11Asynchronous" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Asynchronous" /> interface for the object about which <b>GetData</b> retrieves data.</para>
    </param>
    <param name="pData">
      <para>Type: <b>void*</b></para>
      <para>Address of memory that will receive the data. If <b>NULL</b>, <b>GetData</b> will be used only to check status. The type of data output depends on the type of asynchronous interface.</para>
    </param>
    <param name="DataSize">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Size of the data to retrieve or 0. Must be 0 when <i>pData</i> is <b>NULL</b>.</para>
    </param>
    <param name="GetDataFlags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Optional flags. Can be 0 or any combination of the flags enumerated by <see cref="D3D11_ASYNC_GETDATA_FLAG" />.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-graphics-reference-returnvalues">Direct3D 11 Return Codes</a>. A return value of S_OK indicates that the data at <i>pData</i> is available for the calling application to access. A return value of S_FALSE indicates that the data is not yet available. If the data is not yet available, the application must call <b>GetData</b> until the data is available.</para>
    </returns>
    <remarks>
      <para>Queries in a deferred context are limited to predicated drawing. That is, you cannot call <b>ID3D11DeviceContext.GetData</b> on a deferred context to get data about a query; you can only call <b>GetData</b> on the immediate context to get data about a query. For predicated drawing, the results of a predication-type query are used by the GPU and not returned to an application. For more information about predication and predicated drawing, see <see cref="D3D11DeviceContext.SetPredication" />.</para>
      <para>
        <b>GetData</b> retrieves the data that the runtime collected between calls to <see cref="ID3D11DeviceContext.Begin" /> and <see cref="ID3D11DeviceContext.End" />.  Certain queries only require a call to <b>ID3D11DeviceContext.End</b> in which case the data returned by <b>GetData</b> is accurate up to the last call to <b>ID3D11DeviceContext.End</b>. For information about the queries that only require a call to <b>ID3D11DeviceContext.End</b> and about the type of data that <b>GetData</b> retrieves for each query, see <see cref="D3D11_QUERY" />.</para>
      <para>If <i>DataSize</i> is 0, <b>GetData</b> is only used to check status.</para>
      <para>An application gathers counter data by calling <see cref="ID3D11DeviceContext.Begin" />, issuing some graphics commands, calling <see cref="ID3D11DeviceContext.End" />, and then calling <b>ID3D11DeviceContext.GetData</b> to get data about what happened in between the <b>Begin</b> and <b>End</b> calls. For information about performance counter types, see <see cref="D3D11_COUNTER" />.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GetPredication">
    <summary>
      <para>Get the rendering predicate state.</para>
    </summary>
    <param name="ppPredicate">
      <para>Type: <b><see cref="ID3D11Predicate" />**</b></para>
      <para>Address of a pointer to a predicate (see <see cref="ID3D11Predicate" />). Value stored here will be <b>NULL</b> upon device creation.</para>
    </param>
    <param name="pPredicateValue">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">BOOL</a>*</b></para>
      <para>Address of a boolean to fill with the predicate comparison value. <b>FALSE</b> upon device creation.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GetResourceMinLOD">
    <summary>
      <para>Gets the minimum level-of-detail (LOD).</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Resource" /> which represents the resource.</para>
    </param>
    <returns>
      <para>Type: <b>FLOAT</b></para>
      <para>Returns the minimum LOD.</para>
    </returns>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GetType">
    <summary>
      <para>Gets the type of <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-intro">device context</a>.</para>
    </summary>
    <returns>
      <para>Type: <b><see cref="D3D11_DEVICE_CONTEXT_TYPE" /></b></para>
      <para>A member of <see cref="D3D11_DEVICE_CONTEXT_TYPE" /> that indicates the type of device context.</para>
    </returns>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the geometry shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSGetSamplers">
    <summary>
      <para>Get an array of sampler state interfaces from the geometry shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />).</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSGetShader">
    <summary>
      <para>Get the geometry shader currently set on the device.</para>
    </summary>
    <param name="ppGeometryShader">
      <para>Type: <b><see cref="ID3D11GeometryShader" />**</b></para>
      <para>Address of a pointer to a geometry shader (see <see cref="ID3D11GeometryShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSGetShaderResources">
    <summary>
      <para>Get the geometry shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSSetConstantBuffers">
    <summary>
      <para>Sets the constant buffers used by the geometry shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>You can't use the <see cref="ID3D11ShaderReflectionConstantBuffer" /> interface to get information about what is currently bound to the pipeline in the device context. But you can use <b>ID3D11ShaderReflectionConstantBuffer</b> to get information from a compiled shader. For example, you can use <b>ID3D11ShaderReflectionConstantBuffer</b> and <see cref="ID3D11ShaderReflectionVariable" /> to determine the slot in which a geometry shader expects a constant buffer. You can then pass this slot number to <b>GSSetConstantBuffers</b> to set the constant buffer. You can call the <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/d3d11reflect">D3D11Reflect</a> function to retrieve the address of a pointer to the <see cref="ID3D11ShaderReflection" /> interface and then call <see cref="ID3D11ShaderReflection.GetConstantBufferByName" /> to get a pointer to <b>ID3D11ShaderReflectionConstantBuffer</b>.</para>
      <para>The Direct3D 11.1 runtime, which is available starting with Windows 8, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants – 4<i>32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4</i>32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>If the application wants the shader to access other parts of the buffer, it must call the <see cref="GSSetConstantBuffers1" /> method instead.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the geometry shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <code>
//Default sampler state:
D3D11_SAMPLER_DESC SamplerDesc;
SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.MipLODBias = 0;
SamplerDesc.MaxAnisotropy = 1;
SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
SamplerDesc.BorderColor[0] = 1.0f;
SamplerDesc.BorderColor[1] = 1.0f;
SamplerDesc.BorderColor[2] = 1.0f;
SamplerDesc.BorderColor[3] = 1.0f;
SamplerDesc.MinLOD = -FLT_MAX;
SamplerDesc.MaxLOD = FLT_MAX;

</code>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSSetShader">
    <summary>
      <para>Set a geometry shader to the device.</para>
    </summary>
    <param name="pShader">
      <para>Type: <b><see cref="ID3D11GeometryShader" />*</b></para>
      <para>Pointer to a geometry shader (see <see cref="ID3D11GeometryShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.GSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the geometry shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSGetSamplers">
    <summary>
      <para>Get an array of sampler state interfaces from the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />).</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSGetShader">
    <summary>
      <para>Get the hull shader currently set on the device.</para>
    </summary>
    <param name="ppHullShader">
      <para>Type: <b><see cref="ID3D11HullShader" />**</b></para>
      <para>Address of a pointer to a hull shader (see <see cref="ID3D11HullShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSGetShaderResources">
    <summary>
      <para>Get the hull-shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSSetConstantBuffers">
    <summary>
      <para>Set the constant buffers used by the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The Direct3D 11.1 runtime, which is available starting with Windows 8, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants – 4<i>32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4</i>32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>If the application wants the shader to access other parts of the buffer, it must call the <see cref="HSSetConstantBuffers1" /> method instead.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <code>
//Default sampler state:
D3D11_SAMPLER_DESC SamplerDesc;
SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.MipLODBias = 0;
SamplerDesc.MaxAnisotropy = 1;
SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
SamplerDesc.BorderColor[0] = 1.0f;
SamplerDesc.BorderColor[1] = 1.0f;
SamplerDesc.BorderColor[2] = 1.0f;
SamplerDesc.BorderColor[3] = 1.0f;
SamplerDesc.MinLOD = -FLT_MAX;
SamplerDesc.MaxLOD = FLT_MAX;

</code>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSSetShader">
    <summary>
      <para>Set a hull shader to the device.</para>
    </summary>
    <param name="pHullShader">
      <para>Type: <b><see cref="ID3D11HullShader" />*</b></para>
      <para>Pointer to a hull shader (see <see cref="ID3D11HullShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.HSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources(ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a render target, then the method will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IAGetIndexBuffer">
    <summary>
      <para>Get a pointer to the index buffer that is bound to the input-assembler stage.</para>
    </summary>
    <param name="pIndexBuffer">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>A pointer to an index buffer returned by the method (see <see cref="ID3D11Buffer" />).</para>
    </param>
    <param name="Format">
      <para>Type: <b><see cref="DXGI_FORMAT" />*</b></para>
      <para>Specifies format of the data in the index buffer (see <see cref="DXGI_FORMAT" />). These formats provide the size and type of
the data in the buffer. The only formats allowed for index buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT)
integers.</para>
    </param>
    <param name="Offset">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Offset (in bytes) from the start of the index buffer, to the first index to use.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces
when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IAGetInputLayout">
    <summary>
      <para>Get a pointer to the input-layout object that is bound to the input-assembler stage.</para>
    </summary>
    <param name="ppInputLayout">
      <para>Type: <b><see cref="ID3D11InputLayout" />**</b></para>
      <para>A pointer to the input-layout object (see <see cref="ID3D11InputLayout" />), which describes the input buffers that will be read by the IA stage.</para>
    </param>
    <remarks>
      <para>For information about creating an input-layout object, see Creating the Input-Layout Object.</para>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IAGetPrimitiveTopology">
    <summary>
      <para>Get information about the primitive type, and data order that describes input data for the input assembler stage.</para>
    </summary>
    <param name="pTopology">
      <para>Type: <b><a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff476189(v=vs.85)">D3D11_PRIMITIVE_TOPOLOGY</a>*</b></para>
      <para>A pointer to the type of primitive, and ordering of the primitive data (see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff476189(v=vs.85)">D3D11_PRIMITIVE_TOPOLOGY</a>).</para>
    </param>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IAGetVertexBuffers">
    <summary>
      <para>Get the vertex buffers bound to the input-assembler stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The input slot of the first vertex buffer to get. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. The maximum of 16 or 32 input slots (ranges from 0 to D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - 1) are available; the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">maximum number of input slots depends on the feature level</a>.</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of vertex buffers to get starting at the offset. The number of buffers (plus the starting slot) cannot exceed the total number of IA-stage input slots.</para>
    </param>
    <param name="ppVertexBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>A pointer to an array of vertex buffers returned by the method (see <see cref="ID3D11Buffer" />).</para>
    </param>
    <param name="pStrides">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to an array of stride values returned by the method; one stride value for each buffer in the vertex-buffer array. Each stride value is the size (in bytes) of the elements that are to be used from that vertex buffer.</para>
    </param>
    <param name="pOffsets">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to an array of offset values returned by the method; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IASetIndexBuffer">
    <summary>
      <para>Bind an index buffer to the input-assembler stage.</para>
    </summary>
    <param name="pIndexBuffer">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Buffer" /> object, that contains indices. The index buffer must have been created with
the <see cref="D3D11_BIND_INDEX_BUFFER" /> flag.</para>
    </param>
    <param name="Format">
      <para>Type: <b><see cref="DXGI_FORMAT" /></b></para>
      <para>A <see cref="DXGI_FORMAT" /> that specifies the format of the data in the index buffer. The only formats allowed for index
buffer data are 16-bit (DXGI_FORMAT_R16_UINT) and 32-bit (DXGI_FORMAT_R32_UINT) integers.</para>
    </param>
    <param name="Offset">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Offset (in bytes) from the start of the index buffer to the first index to use.</para>
    </param>
    <remarks>
      <para>For information about creating index buffers, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-buffers-index-how-to">How to: Create an Index Buffer</a>.</para>
      <para>Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind
<b>NULL</b> instead because a buffer cannot be bound as both an input and an output at the same time.</para>
      <para>The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will
not prevent invalid data from being used by the runtime.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IASetInputLayout">
    <summary>
      <para>Bind an input-layout object to the input-assembler stage.</para>
    </summary>
    <param name="pInputLayout">
      <para>Type: <b><see cref="ID3D11InputLayout" />*</b></para>
      <para>A pointer to the input-layout object (see <see cref="ID3D11InputLayout" />), which describes the input buffers that will be read by the IA stage.</para>
    </param>
    <remarks>
      <para>Input-layout objects describe how vertex buffer data is streamed into the IA pipeline stage. To create an input-layout object, call <see cref="ID3D11Device.CreateInputLayout" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IASetPrimitiveTopology">
    <summary>
      <para>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</para>
    </summary>
    <param name="Topology">
      <para>Type: <b><a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff476189(v=vs.85)">D3D11_PRIMITIVE_TOPOLOGY</a></b></para>
      <para>The type of primitive and ordering of the primitive data (see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ff476189(v=vs.85)">D3D11_PRIMITIVE_TOPOLOGY</a>).</para>
    </param>
    <remarks>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.IASetVertexBuffers">
    <summary>
      <para>Bind an array of vertex buffers to the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d10-graphics-programming-guide-input-assembler-stage">input-assembler stage</a>.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The first input slot for binding. The first vertex buffer is explicitly bound to the start slot; this causes each additional vertex buffer in the array to be implicitly bound to each subsequent input slot. The maximum of 16 or 32 input slots (ranges from 0 to D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - 1) are available; the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">maximum number of input slots depends on the feature level</a>.</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of vertex buffers in the array. The number of buffers (plus the starting slot) can't exceed the total number of IA-stage input slots (ranges from 0 to D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppVertexBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>A pointer to an array of vertex buffers (see <see cref="ID3D11Buffer" />). The vertex buffers must have been created with the <see cref="D3D11_BIND_VERTEX_BUFFER" /> flag.</para>
    </param>
    <param name="pStrides">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to an array of stride values; one stride value for each buffer in the vertex-buffer array. Each stride is the size (in bytes) of the elements that are to be used from that vertex buffer.</para>
    </param>
    <param name="pOffsets">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to an array of offset values; one offset value for each buffer in the vertex-buffer array. Each offset is the number of bytes between the first element of a vertex buffer and the first element that will be used.</para>
    </param>
    <remarks>
      <para>For info about creating vertex buffers, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-buffers-vertex-how-to">How to: Create a Vertex Buffer</a>.</para>
      <para>Calling this method using a buffer that is currently bound for writing (that is, bound to the stream output pipeline stage) will effectively bind <b>NULL</b> instead because a buffer can't be bound as both an input and an output at the same time.</para>
      <para>The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMGetBlendState">
    <summary>
      <para>Get the blend state of the output-merger stage.</para>
    </summary>
    <param name="ppBlendState">
      <para>Type: <b><see cref="ID3D11BlendState" />**</b></para>
      <para>Address of a pointer to a blend-state interface (see <see cref="ID3D11BlendState" />).</para>
    </param>
    <param name="BlendFactor">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">FLOAT</a>[4]</b></para>
      <para>Array of blend factors, one for each RGBA component.</para>
    </param>
    <param name="pSampleMask">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to a <see cref="sample mask" />.</para>
    </param>
    <remarks>
      <para>The reference count of the returned interface will be incremented by one when the blend state is retrieved. Applications must release returned pointer(s) when they are no longer needed, or else there will be a memory leak.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMGetDepthStencilState">
    <summary>
      <para>Gets the depth-stencil state of the output-merger stage.</para>
    </summary>
    <param name="ppDepthStencilState">
      <para>Type: <b><see cref="ID3D11DepthStencilState" />**</b></para>
      <para>Address of a pointer to a depth-stencil state interface (see <see cref="ID3D11DepthStencilState" />) to be filled with information from the device.</para>
    </param>
    <param name="pStencilRef">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>Pointer to the stencil reference value used in the depth-stencil test.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMGetRenderTargets">
    <summary>
      <para>Get pointers to the resources bound to the output-merger stage.</para>
    </summary>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of render targets to retrieve.</para>
    </param>
    <param name="ppRenderTargetViews">
      <para>Type: <b><see cref="ID3D11RenderTargetView" />**</b></para>
      <para>Pointer to an array of <see cref="ID3D11RenderTargetView" />s which represent render target views. Specify <b>NULL</b> for this parameter when retrieval of a render target is not needed.</para>
    </param>
    <param name="ppDepthStencilView">
      <para>Type: <b><see cref="ID3D11DepthStencilView" />**</b></para>
      <para>Pointer to a <see cref="ID3D11DepthStencilView" />, which represents a depth-stencil view. Specify <b>NULL</b> for this parameter when retrieval of the depth-stencil view is not needed.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMGetRenderTargetsAndUnorderedAccessViews">
    <summary>
      <para>Get pointers to the resources bound to the output-merger stage.</para>
    </summary>
    <param name="NumRTVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of render-target views to retrieve.</para>
    </param>
    <param name="ppRenderTargetViews">
      <para>Type: <b><see cref="ID3D11RenderTargetView" />**</b></para>
      <para>Pointer to an array of <see cref="ID3D11RenderTargetView" />s, which represent render-target views. Specify <b>NULL</b> for this parameter when retrieval of render-target views is not required.</para>
    </param>
    <param name="ppDepthStencilView">
      <para>Type: <b><see cref="ID3D11DepthStencilView" />**</b></para>
      <para>Pointer to a <see cref="ID3D11DepthStencilView" />, which represents a depth-stencil view. Specify <b>NULL</b> for this parameter when retrieval of the depth-stencil view is not required.</para>
    </param>
    <param name="UAVStartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin retrieving unordered-access views (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - 1).
For pixel shaders <i>UAVStartSlot</i> should be equal to the number of render-target views that are bound.</para>
    </param>
    <param name="NumUAVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of unordered-access views to return in <i>ppUnorderedAccessViews</i>. This number ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - <i>UAVStartSlot</i>.</para>
    </param>
    <param name="ppUnorderedAccessViews">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />**</b></para>
      <para>Pointer to an array of <see cref="ID3D11UnorderedAccessView" />s, which represent unordered-access views that are retrieved. Specify <b>NULL</b> for this parameter when retrieval of unordered-access views is not required.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call <see cref="IUnknown.Release" /> on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMSetBlendState">
    <summary>
      <para>Set the blend state of the output-merger stage.</para>
    </summary>
    <param name="pBlendState">
      <para>Type: <b><see cref="ID3D11BlendState" />*</b></para>
      <para>Pointer to a blend-state interface (see <see cref="ID3D11BlendState" />). Pass <b>NULL</b> for a default blend state. For more info about default blend state, see Remarks.</para>
    </param>
    <param name="BlendFactor">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">FLOAT</a>[4]</b></para>
      <para>Array of blend factors, one for each RGBA component. The blend factors modulate values for the pixel shader, render target, or both. If you created  the blend-state object with <see cref="D3D11_BLEND_BLEND_FACTOR" /> or <see cref="D3D11_BLEND_INV_BLEND_FACTOR" />, the blending stage uses the non-NULL array of blend factors. If you didn't create the blend-state object with <b>D3D11_BLEND_BLEND_FACTOR</b> or <b>D3D11_BLEND_INV_BLEND_FACTOR</b>, the blending stage does not use the non-NULL array of blend factors; the runtime stores the blend factors, and you can later call <see cref="ID3D11DeviceContext.OMGetBlendState" /> to retrieve the blend factors. If you pass <b>NULL</b>, the runtime uses or stores a blend factor equal to { 1, 1, 1, 1 }.</para>
    </param>
    <param name="SampleMask">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>32-bit sample coverage. The default value is 0xffffffff. See remarks.</para>
    </param>
    <remarks>
      <para>Blend state is used by the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d10-graphics-programming-guide-output-merger-stage">output-merger stage</a> to determine how to blend together two RGB pixel values and two alpha values. The two RGB pixel values and two alpha values are the RGB pixel value and alpha value that the pixel shader outputs and the RGB pixel value and alpha value already in the output render target. The <see cref="blend option" /> controls the data source that the blending stage uses to modulate values for the pixel shader, render target, or both. The <see cref="blend operation" /> controls how the blending stage mathematically combines these modulated values.</para>
      <para>To create a blend-state interface, call <see cref="ID3D11Device.CreateBlendState" />.</para>
      <para>Passing in <b>NULL</b> for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.</para>
      <list type="table">
        <listheader>
          <description>State</description>
          <description>Default Value</description>
        </listheader>
        <item>
          <description>AlphaToCoverageEnable</description>
          <description>
            <b>FALSE</b>
          </description>
        </item>
        <item>
          <description>IndependentBlendEnable</description>
          <description>
            <b>FALSE</b>
          </description>
        </item>
        <item>
          <description>RenderTarget[0].BlendEnable</description>
          <description>
            <b>FALSE</b>
          </description>
        </item>
        <item>
          <description>RenderTarget[0].SrcBlend</description>
          <description>D3D11_BLEND_ONE</description>
        </item>
        <item>
          <description>RenderTarget[0].DestBlend</description>
          <description>D3D11_BLEND_ZERO</description>
        </item>
        <item>
          <description>RenderTarget[0].BlendOp</description>
          <description>D3D11_BLEND_OP_ADD</description>
        </item>
        <item>
          <description>RenderTarget[0].SrcBlendAlpha</description>
          <description>D3D11_BLEND_ONE</description>
        </item>
        <item>
          <description>RenderTarget[0].DestBlendAlpha</description>
          <description>D3D11_BLEND_ZERO</description>
        </item>
        <item>
          <description>RenderTarget[0].BlendOpAlpha</description>
          <description>D3D11_BLEND_OP_ADD</description>
        </item>
        <item>
          <description>RenderTarget[0].RenderTargetWriteMask</description>
          <description>D3D11_COLOR_WRITE_ENABLE_ALL</description>
        </item>
      </list>
      <para>A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMSetDepthStencilState">
    <summary>
      <para>Sets the depth-stencil state of the output-merger stage.</para>
    </summary>
    <param name="pDepthStencilState">
      <para>Type: <b><see cref="ID3D11DepthStencilState" />*</b></para>
      <para>Pointer to a depth-stencil state interface (see <see cref="ID3D11DepthStencilState" />) to bind to the device. Set this to <b>NULL</b> to use the default state listed in <see cref="D3D11_DEPTH_STENCIL_DESC" />.</para>
    </param>
    <param name="StencilRef">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Reference value to perform against when doing a depth-stencil test. See remarks.</para>
    </param>
    <remarks>
      <para>To create a depth-stencil state interface, call <see cref="ID3D11Device.CreateDepthStencilState" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMSetRenderTargets">
    <summary>
      <para>Bind one or more render targets atomically and the depth-stencil buffer to the <a href="https://docs.microsoft.com//windows/win32/direct3d11/d3d10-graphics-programming-guide-output-merger-stage">output-merger stage</a>.</para>
    </summary>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of render targets to bind (ranges between 0 and <b>D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which <i>ppRenderTargetViews</i> points must equal the number in this parameter.</para>
    </param>
    <param name="ppRenderTargetViews">
      <para>Type: <b><see cref="ID3D11RenderTargetView" />*</b></para>
      <para>Pointer to an array of <see cref="ID3D11RenderTargetView" /> that represent the render targets to bind to the device.
If this parameter is <b>NULL</b> and <i>NumViews</i> is 0, no render targets are bound.</para>
    </param>
    <param name="pDepthStencilView">
      <para>Type: <b><see cref="ID3D11DepthStencilView" />*</b></para>
      <para>Pointer to a <see cref="ID3D11DepthStencilView" /> that represents the depth-stencil view to bind to the device.
If this parameter is <b>NULL</b>, the depth-stencil view is not bound.</para>
    </param>
    <remarks>
      <para>The maximum number of active render targets a device can have active at any given time is set by a #define in D3D11.h called
<b>D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT</b>. It is invalid to try to set the same subresource to multiple render target slots.
Any render targets not defined by this call are set to <b>NULL</b>.</para>
      <para>If any subresources are also currently bound for reading in a different stage or writing (perhaps in a different part of the pipeline),
those bind points will be set to <b>NULL</b>, in order to prevent the same subresource from being read and written simultaneously in a single rendering operation.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>If the render-target views were created from an array resource type, all of the render-target views must have the same array size.
This restriction also applies to the depth-stencil view, its array size must match that of the render-target views being bound.</para>
      <para>The pixel shader must be able to simultaneously render to at least eight separate render targets. All of these render targets must access the same type of resource: <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-buffer">Buffer</a>, <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-texture1d">Texture1D</a>, <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-texture1darray">Texture1DArray</a>, <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-texture2d">Texture2D</a>, <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-texture2darray">Texture2DArray</a>, <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/sm5-object-texture3d">Texture3D</a>, or <a href="https://docs.microsoft.com//windows/win32/direct3dhlsl/dx-graphics-hlsl-to-type">TextureCube</a>. All render targets must have the same size in all dimensions (width and height, and depth for 3D or array size for *Array types). If render targets use multisample anti-aliasing, all bound render targets and depth buffer must be the same form of multisample resource (that is, the sample counts must be the same). Each render target can have a different data format. These render target formats are not required to have identical bit-per-element counts.</para>
      <para>Any combination of the eight slots for render targets can have a render target set or not set.</para>
      <para>The same resource view cannot be bound to multiple render target slots simultaneously. However, you can set multiple non-overlapping resource views of a single resource as simultaneous multiple render targets.</para>
      <para>Note that unlike some other resource methods in Direct3D, all currently bound render targets will be unbound by calling <code>OMSetRenderTargets(0, nullptr, nullptr);</code>.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.OMSetRenderTargetsAndUnorderedAccessViews">
    <summary>
      <para>Binds resources to the output-merger stage.</para>
    </summary>
    <param name="NumRTVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of render targets to bind (ranges between 0 and <b>D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which <i>ppRenderTargetViews</i> points must equal the number in this parameter. If you set <i>NumRTVs</i> to D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL (0xffffffff), this method does not modify the currently bound render-target views (RTVs) and also does not modify depth-stencil view (DSV).</para>
    </param>
    <param name="ppRenderTargetViews">
      <para>Type: <b><see cref="ID3D11RenderTargetView" />*</b></para>
      <para>Pointer to an array of <see cref="ID3D11RenderTargetView" />s that represent the render targets to bind to the device.
If this parameter is <b>NULL</b> and <i>NumRTVs</i> is 0, no render targets are bound.</para>
    </param>
    <param name="pDepthStencilView">
      <para>Type: <b><see cref="ID3D11DepthStencilView" />*</b></para>
      <para>Pointer to a <see cref="ID3D11DepthStencilView" /> that represents the depth-stencil view to bind to the device.
If this parameter is <b>NULL</b>, the depth-stencil view is not bound.</para>
    </param>
    <param name="UAVStartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin setting unordered-access views (ranges from 0 to D3D11_PS_CS_UAV_REGISTER_COUNT - 1).</para>
      <para>For the Direct3D 11.1 runtime, which is available starting with Windows 8, this value can range from 0 to D3D11_1_UAV_SLOT_COUNT - 1. D3D11_1_UAV_SLOT_COUNT is defined as 64.</para>
      <para>For pixel shaders, <i>UAVStartSlot</i> should be equal to the number of render-target views being bound.</para>
    </param>
    <param name="NumUAVs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of unordered-access views (UAVs) in <i>ppUnorderedAccessViews</i>. If you set <i>NumUAVs</i> to D3D11_KEEP_UNORDERED_ACCESS_VIEWS (0xffffffff), this method does not modify the currently bound unordered-access views.</para>
      <para>For the Direct3D 11.1 runtime, which is available starting with Windows 8, this value can range from 0 to D3D11_1_UAV_SLOT_COUNT - <i>UAVStartSlot</i>.</para>
    </param>
    <param name="ppUnorderedAccessViews">
      <para>Type: <b><see cref="ID3D11UnorderedAccessView" />*</b></para>
      <para>Pointer to an array of <see cref="ID3D11UnorderedAccessView" />s that represent the unordered-access views to bind to the device.
If this parameter is <b>NULL</b> and <i>NumUAVs</i> is 0, no unordered-access views are bound.</para>
    </param>
    <param name="pUAVInitialCounts">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array of append and consume buffer offsets. A value of -1 indicates to keep the current offset. Any other values set the hidden counter
for that appendable and consumable UAV. <i>pUAVInitialCounts</i> is  relevant only for UAVs that were created with either
<see cref="D3D11_BUFFER_UAV_FLAG_APPEND" /> or <b>D3D11_BUFFER_UAV_FLAG_COUNTER</b> specified
when the UAV was created; otherwise, the argument is ignored.</para>
    </param>
    <remarks>
      <para>For pixel shaders, the render targets and unordered-access views share the same resource slots when being written out. This means that UAVs must be
given an offset so that they are placed in the slots after the render target views that are being bound.</para>
      <para>
        <b>Note</b>  RTVs, DSV, and UAVs cannot be set independently; they all need to be set at the same time.</para>
      <para>Two RTVs conflict if they share a subresource (and therefore share the same resource).</para>
      <para>Two UAVs conflict if they share a subresource (and therefore share the same resource).</para>
      <para>An RTV conflicts with a UAV if they share a subresource or share a bind point.</para>
      <para>
        <b>OMSetRenderTargetsAndUnorderedAccessViews</b> operates properly in the following situations:</para>
      <list type="number">
        <item>
          <description>
            <i>NumRTVs</i> != D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL and <i>NumUAVs</i> != D3D11_KEEP_UNORDERED_ACCESS_VIEWS
<para>The following conditions must be true for <b>OMSetRenderTargetsAndUnorderedAccessViews</b> to succeed and for the runtime to pass the bind information to the driver:</para><list type="bullet"><item><description><i>NumRTVs</i> &lt;= 8
</description></item><item><description><i>UAVStartSlot</i> &gt;= <i>NumRTVs</i></description></item><item><description><i>UAVStartSlot</i> + <i>NumUAVs</i> &lt;= 8
</description></item><item><description>There must be no conflicts in the set of all <i>ppRenderTargetViews</i> and <i>ppUnorderedAccessViews</i>.
</description></item><item><description><i>ppDepthStencilView</i> must match the render-target views. For more information about resource views, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-intro">Introduction to a Resource in Direct3D 11</a>.
</description></item></list><b>OMSetRenderTargetsAndUnorderedAccessViews</b> performs the following tasks:
<list type="bullet"><item><description>Unbinds all currently bound conflicting resources (stream-output target resources (SOTargets), compute shader (CS) UAVs, shader-resource views (SRVs)).</description></item><item><description>Binds <i>ppRenderTargetViews</i>, <i>ppDepthStencilView</i>, and <i>ppUnorderedAccessViews</i>.
</description></item></list></description>
        </item>
        <item>
          <description>
            <i>NumRTVs</i> == D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL
<para>In this situation, <b>OMSetRenderTargetsAndUnorderedAccessViews</b> binds only UAVs.</para><para>The following conditions must be true for <b>OMSetRenderTargetsAndUnorderedAccessViews</b> to succeed and for the runtime to pass the bind information to the driver:</para><list type="bullet"><item><description><i>UAVStartSlot</i> + <i>NumUAVs</i> &lt;= 8
</description></item><item><description>There must be no conflicts in <i>ppUnorderedAccessViews</i>.
</description></item></list><b>OMSetRenderTargetsAndUnorderedAccessViews</b> unbinds the following items:
<list type="bullet"><item><description>All RTVs in slots &gt;= <i>UAVStartSlot</i></description></item><item><description>All RTVs that conflict with any UAVs in <i>ppUnorderedAccessViews</i></description></item><item><description>All currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with <i>ppUnorderedAccessViews</i></description></item></list><b>OMSetRenderTargetsAndUnorderedAccessViews</b> binds <i>ppUnorderedAccessViews</i>.
<para><b>OMSetRenderTargetsAndUnorderedAccessViews</b> ignores <i>ppDepthStencilView</i>, and the current depth-stencil view remains bound.</para></description>
        </item>
        <item>
          <description>
            <i>NumUAVs</i> == D3D11_KEEP_UNORDERED_ACCESS_VIEWS
<para>In this situation, <b>OMSetRenderTargetsAndUnorderedAccessViews</b> binds only RTVs and DSV.</para><para>The following conditions must be true for <b>OMSetRenderTargetsAndUnorderedAccessViews</b> to succeed and for the runtime to pass the bind information to the driver:</para><list type="bullet"><item><description><i>NumRTVs</i> &lt;= 8
</description></item><item><description>There must be no conflicts in <i>ppRenderTargetViews</i>.
</description></item><item><description><i>ppDepthStencilView</i> must match the render-target views. For more information about resource views, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-intro">Introduction to a Resource in Direct3D 11</a>.
</description></item></list><b>OMSetRenderTargetsAndUnorderedAccessViews</b> unbinds the following items:
<list type="bullet"><item><description>All UAVs in slots &lt; <i>NumRTVs</i></description></item><item><description>All UAVs that conflict with any RTVs in <i>ppRenderTargetViews</i></description></item><item><description>All currently bound resources (SOTargets, CS UAVs, SRVs) that conflict with <i>ppRenderTargetViews</i></description></item></list><b>OMSetRenderTargetsAndUnorderedAccessViews</b> binds <i>ppRenderTargetViews</i> and <i>ppDepthStencilView</i>.
<para><b>OMSetRenderTargetsAndUnorderedAccessViews</b> ignores <i>UAVStartSlot</i>.</para></description>
        </item>
      </list>
      <b>Windows Phone 8:
</b> This API is supported.
</remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the pixel shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSGetSamplers">
    <summary>
      <para>Get an array of sampler states from the pixel shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Array of sampler-state interface pointers (see <see cref="ID3D11SamplerState" />) to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSGetShader">
    <summary>
      <para>Get the pixel shader currently set on the device.</para>
    </summary>
    <param name="ppPixelShader">
      <para>Type: <b><see cref="ID3D11PixelShader" />**</b></para>
      <para>Address of a pointer to a pixel shader (see <see cref="ID3D11PixelShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed, to avoid memory leaks.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSGetShaderResources">
    <summary>
      <para>Get the pixel shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSSetConstantBuffers">
    <summary>
      <para>Sets the constant buffers used by the pixel shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The Direct3D 11.1 runtime, which is available on Windows 8 and later operating systems, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader
than the maximum constant buffer size that is supported by shaders (4096 constants – 4<i>32-bit components each).
When you bind such a large buffer, the shader can access only the first 4096 4</i>32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>To enable the shader to access other parts of the buffer, call
<see cref="PSSetConstantBuffers1" /> instead of <b>PSSetConstantBuffers</b>.
<b>PSSetConstantBuffers1</b> has additional parameters <i>pFirstConstant</i> and <i>pNumConstants</i>.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the pixel shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <list type="table">
        <listheader>
          <description>State</description>
          <description>Default Value</description>
        </listheader>
        <item>
          <description>Filter</description>
          <description>D3D11_FILTER_MIN_MAG_MIP_LINEAR</description>
        </item>
        <item>
          <description>AddressU</description>
          <description>D3D11_TEXTURE_ADDRESS_CLAMP</description>
        </item>
        <item>
          <description>AddressV</description>
          <description>D3D11_TEXTURE_ADDRESS_CLAMP</description>
        </item>
        <item>
          <description>AddressW</description>
          <description>D3D11_TEXTURE_ADDRESS_CLAMP</description>
        </item>
        <item>
          <description>MipLODBias</description>
          <description>0</description>
        </item>
        <item>
          <description>MaxAnisotropy</description>
          <description>1</description>
        </item>
        <item>
          <description>ComparisonFunc</description>
          <description>D3D11_COMPARISON_NEVER</description>
        </item>
        <item>
          <description>BorderColor[0]</description>
          <description>1.0f</description>
        </item>
        <item>
          <description>BorderColor[1]</description>
          <description>1.0f</description>
        </item>
        <item>
          <description>BorderColor[2]</description>
          <description>1.0f</description>
        </item>
        <item>
          <description>BorderColor[3]</description>
          <description>1.0f</description>
        </item>
        <item>
          <description>MinLOD</description>
          <description>-FLT_MAX</description>
        </item>
        <item>
          <description>MaxLOD</description>
          <description>FLT_MAX</description>
        </item>
      </list>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSSetShader">
    <summary>
      <para>Sets a pixel shader to the device.</para>
    </summary>
    <param name="pPixelShader">
      <para>Type: <b><see cref="ID3D11PixelShader" />*</b></para>
      <para>Pointer to a pixel shader (see <see cref="ID3D11PixelShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
      <para>Set ppClassInstances to <b>NULL</b> if no interfaces are used in the shader. If it is not <b>NULL</b>, the number of class instances must match the number of interfaces used in the shader. Furthermore, each interface pointer must have a corresponding class instance or the assigned shader will be disabled.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.PSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the pixel shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.ResolveSubresource">
    <summary>
      <para>Copy a multisampled resource into a non-multisampled resource.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>Destination resource. Must be a created with the <see cref="D3D11_USAGE_DEFAULT" /> flag and be single-sampled. See <see cref="ID3D11Resource" />.</para>
    </param>
    <param name="DstSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A zero-based index, that identifies the destination subresource. Use <see cref="D3D11CalcSubresource" /> to calculate the index.</para>
    </param>
    <param name="pSrcResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>Source resource. Must be multisampled.</para>
    </param>
    <param name="SrcSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The source subresource of the source resource.</para>
    </param>
    <param name="Format">
      <para>Type: <b><see cref="DXGI_FORMAT" /></b></para>
      <para>A <see cref="DXGI_FORMAT" /> that indicates how the multisampled resource will be resolved to a single-sampled resource.
See remarks.</para>
    </param>
    <remarks>
      <para>This API is most useful when re-using the resulting rendertarget of one render pass as an input to a second render pass.</para>
      <para>The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have compatible formats. There are three scenarios for this:</para>
      <list type="table">
        <listheader>
          <description>Scenario</description>
          <description>Requirements</description>
        </listheader>
        <item>
          <description>Source and destination are prestructured and typed</description>
          <description>Both the source and destination must have identical formats and that format must be specified in the Format parameter.</description>
        </item>
        <item>
          <description>One resource is prestructured and typed and the other is prestructured and typeless</description>
          <description>The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified in the Format parameter.</description>
        </item>
        <item>
          <description>Source and destination are prestructured and typeless</description>
          <description>Both the source and destination must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter).
<para>For example, given the DXGI_FORMAT_R16G16B16A16_TYPELESS format:</para><list type="bullet"><item><description>The source (or dest) format could be DXGI_FORMAT_R16G16B16A16_UNORM</description></item><item><description>The dest (or source) format could be DXGI_FORMAT_R16G16B16A16_FLOAT</description></item></list></description>
        </item>
      </list>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSGetScissorRects">
    <summary>
      <para>Get the array of scissor rectangles bound to the rasterizer stage.</para>
    </summary>
    <param name="pNumRects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of scissor rectangles (ranges between 0 and D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE) bound; set <i>pRects</i> to <b>NULL</b> to use <i>pNumRects</i> to see how many rectangles would be returned.</para>
    </param>
    <param name="pRects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>*</b></para>
      <para>An array of scissor rectangles (see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>). If NumRects is greater than the number of scissor rects currently bound, then unused members of the array will contain 0.</para>
    </param>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSGetState">
    <summary>
      <para>Get the <see cref="rasterizer state" /> from the rasterizer stage of the pipeline.</para>
    </summary>
    <param name="ppRasterizerState">
      <para>Type: <b><see cref="ID3D11RasterizerState" />**</b></para>
      <para>Address of a pointer to a rasterizer-state interface (see <see cref="ID3D11RasterizerState" />) to fill with information from the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSGetViewports">
    <summary>
      <para>Gets the array of viewports bound to the rasterizer stage.</para>
    </summary>
    <param name="pNumViewports">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>A pointer to a variable that, on input, specifies the number of viewports (ranges from 0 to <b>D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE</b>)
in the <i>pViewports</i> array; on output, the variable contains the actual number of viewports that are bound to the rasterizer stage.
If <i>pViewports</i> is <b>NULL</b>, <b>RSGetViewports</b> fills the variable with the number of viewports currently bound.</para>
      <para>
        <b>Note</b>  In some versions of the Windows SDK, a <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-layers">debug device</a> will raise an exception if the input value in the variable to which <i>pNumViewports</i> points is greater than <b>D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE</b> even if <i>pViewports</i> is <b>NULL</b>.  The regular runtime ignores the value in the variable to which <i>pNumViewports</i> points when <i>pViewports</i> is <b>NULL</b>.  This behavior of a debug device might be corrected in a future release of the Windows SDK.</para>
    </param>
    <param name="pViewports">
      <para>Type: <b><see cref="D3D11_VIEWPORT" />*</b></para>
      <para>An array of <see cref="D3D11_VIEWPORT" /> structures for the viewports that are bound to the rasterizer stage. If the number of viewports (in the variable to which <i>pNumViewports</i> points) is
greater than the actual number of viewports currently bound, unused elements of the array contain 0.
For info about how the viewport size depends on the device <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a>, which has changed between Direct3D 11
and Direct3D 10, see <b>D3D11_VIEWPORT</b>.</para>
    </param>
    <remarks>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSSetScissorRects">
    <summary>
      <para>Bind an array of scissor rectangles to the rasterizer stage.</para>
    </summary>
    <param name="NumRects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of scissor rectangles to bind.</para>
    </param>
    <param name="pRects">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>*</b></para>
      <para>An array of scissor rectangles (see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>).</para>
    </param>
    <remarks>
      <para>All scissor rects must be set atomically as one operation. Any scissor rects not defined by the call are disabled.</para>
      <para>The scissor rectangles will only be used if ScissorEnable is set to true in the rasterizer state (see <see cref="D3D11_RASTERIZER_DESC" />).</para>
      <para>Which scissor rectangle to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first scissor rectangle in the array.</para>
      <para>Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <see cref="ID3D11DeviceContext.RSSetViewports" />).</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSSetState">
    <summary>
      <para>Set the <see cref="rasterizer state" /> for the rasterizer stage of the pipeline.</para>
    </summary>
    <param name="pRasterizerState">
      <para>Type: <b><see cref="ID3D11RasterizerState" />*</b></para>
      <para>Pointer to a rasterizer-state interface (see <see cref="ID3D11RasterizerState" />) to bind to the pipeline.</para>
    </param>
    <remarks>
      <para>To create a rasterizer state interface, call <see cref="ID3D11Device.CreateRasterizerState" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.RSSetViewports">
    <summary>
      <para>Bind an array of viewports to the rasterizer stage of the pipeline.</para>
    </summary>
    <param name="NumViewports">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of viewports to bind.</para>
    </param>
    <param name="pViewports">
      <para>Type: <b>const <see cref="D3D11_VIEWPORT" />*</b></para>
      <para>An array of <see cref="D3D11_VIEWPORT" /> structures to bind to the device. See the structure page for details about how the viewport size is dependent on the device feature level which has changed between Direct3D 11 and Direct3D 10.</para>
    </param>
    <remarks>
      <para>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</para>
      <para>Which viewport to use is determined by the <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics">SV_ViewportArrayIndex</a> semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array.</para>
      <para>
        <b>Note</b>  Even though you specify float values to the members of the <see cref="D3D11_VIEWPORT" /> structure for the <i>pViewports</i> array in a call to  <b>ID3D11DeviceContext.RSSetViewports</b> for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature levels</a> 9_x, <b>RSSetViewports</b> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <b>RSSetViewports</b> for feature levels 9_x fails. This failure occurs because <b>RSSetViewports</b> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.SetPredication">
    <summary>
      <para>Set a rendering predicate.</para>
    </summary>
    <param name="pPredicate">
      <para>Type: <b><see cref="ID3D11Predicate" />*</b></para>
      <para>A pointer to the <see cref="ID3D11Predicate" /> interface that represents the rendering predicate. A <b>NULL</b> value indicates "no" predication; in this case, the value of <i>PredicateValue</i> is irrelevant but will be preserved for <see cref="ID3D11DeviceContext.GetPredication" />.</para>
    </param>
    <param name="PredicateValue">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">BOOL</a></b></para>
      <para>If <b>TRUE</b>, rendering will be affected by when the predicate's conditions are met. If <b>FALSE</b>, rendering will be affected when the conditions are not met.</para>
    </param>
    <remarks>
      <para>The predicate must be in the "issued" or "signaled" state to be used for predication. While the predicate is set for predication, calls to <see cref="ID3D11DeviceContext.Begin" /> and <see cref="ID3D11DeviceContext.End" /> are invalid.</para>
      <para>Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting predicate data of the predicate is equal to the <i>PredicateValue</i>. However, some predicates are only hints, so they may not actually prevent operations from being performed.</para>
      <para>The primary usefulness of predication is to allow an application to issue rendering and resource manipulation commands without taking the performance hit of spinning, waiting for <see cref="ID3D11DeviceContext.GetData" /> to return. So, predication can occur while <b>ID3D11DeviceContext.GetData</b> returns <b>S_FALSE</b>. Another way to think of it: an application can also use predication as a fallback, if it is possible that <b>ID3D11DeviceContext.GetData</b> returns <b>S_FALSE</b>. If <b>ID3D11DeviceContext.GetData</b> returns <b>S_OK</b>, the application can skip calling the rendering and resource manipulation commands manually with its own application logic.</para>
      <para>Rendering and resource manipulation commands for Direct3D 11 include these Draw, Dispatch, Copy, Update, Clear, Generate, and Resolve operations.</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="Draw" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawAuto" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawIndexed" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawIndexedInstanced" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawIndexedInstancedIndirect" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawInstanced" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DrawInstancedIndirect" />
          </description>
        </item>
        <item>
          <description>
            <see cref="Dispatch" />
          </description>
        </item>
        <item>
          <description>
            <see cref="DispatchIndirect" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopyResource" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopyStructureCount" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopySubresourceRegion" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopySubresourceRegion1" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopyTiles" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CopyTileMappings" />
          </description>
        </item>
        <item>
          <description>
            <see cref="UpdateSubresource" />
          </description>
        </item>
        <item>
          <description>
            <see cref="UpdateSubresource1" />
          </description>
        </item>
        <item>
          <description>
            <see cref="UpdateTiles" />
          </description>
        </item>
        <item>
          <description>
            <see cref="UpdateTileMappings" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ClearRenderTargetView" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ClearUnorderedAccessViewFloat" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ClearUnorderedAccessViewUint" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ClearView" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ClearDepthStencilView" />
          </description>
        </item>
        <item>
          <description>
            <see cref="GenerateMips" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ResolveSubresource" />
          </description>
        </item>
      </list>
      <para>You can set a rendering predicate on an immediate or a deferred context. For info about immediate and deferred contexts, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render">Immediate and Deferred Rendering</a>.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.SetResourceMinLOD">
    <summary>
      <para>Sets the minimum level-of-detail (LOD) for a resource.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to an <see cref="ID3D11Resource" /> that represents the resource.</para>
    </param>
    <param name="MinLOD">
      <para>Type: <b>FLOAT</b></para>
      <para>The level-of-detail, which ranges between 0 and the maximum number of mipmap levels of the resource. For example, the maximum number of mipmap levels of a 1D texture is specified in the  <b>MipLevels</b> member of the  <see cref="D3D11_TEXTURE1D_DESC" /> structure.</para>
    </param>
    <remarks>
      <para>To use a resource with <b>SetResourceMinLOD</b>, you must set the <see cref="D3D11_RESOURCE_MISC_RESOURCE_CLAMP" /> flag when you create that resource.</para>
      <para>For Direct3D 10 and Direct3D 10.1, when sampling from a texture resource in a shader, the sampler can define a minimum LOD clamp to force sampling from less detailed mip levels.  For Direct3D 11, this functionality is extended from the sampler to the entire resource. Therefore, the application can specify the highest-resolution mip level of a resource that is available for access. This restricts the set of mip levels that are required to be resident in GPU memory, thereby saving memory.</para>
      <para>The set of mip levels resident per-resource in GPU memory can be specified by the user.</para>
      <para>Minimum LOD affects all of the resident mip levels. Therefore, only the resident mip levels can be updated and read from.</para>
      <para>All methods that access texture resources must adhere to minimum LOD clamps.</para>
      <para>Empty-set accesses are handled as out-of-bounds cases.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.SOGetTargets">
    <summary>
      <para>Get the target output buffers for the stream-output stage of the pipeline.</para>
    </summary>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to get.</para>
    </param>
    <param name="ppSOTargets">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>An array of output buffers (see <see cref="ID3D11Buffer" />) to be retrieved from the device.</para>
    </param>
    <remarks>
      <para>A maximum of four output buffers can be retrieved.</para>
      <para>The offsets to the output buffers pointed to in the returned <i>ppSOTargets</i> array may be assumed to be -1 (append), as defined for use in <see cref="ID3D11DeviceContext.SOSetTargets" />.</para>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.SOSetTargets">
    <summary>
      <para>Set the target output buffers for the stream-output stage of the pipeline.</para>
    </summary>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">UINT</a></b></para>
      <para>The number of buffer to bind to the device. A maximum of four output buffers can be set. If less than four are defined by the call, the remaining buffer slots are set to <b>NULL</b>. See Remarks.</para>
    </param>
    <param name="ppSOTargets">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>The array of output buffers (see <see cref="ID3D11Buffer" />) to bind to the device. The buffers must have been created with the <see cref="D3D11_BIND_STREAM_OUTPUT" /> flag.</para>
    </param>
    <param name="pOffsets">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/win32/winprog/windows-data-types">UINT</a>*</b></para>
      <para>Array of offsets to the output buffers from <i>ppSOTargets</i>, one offset for each buffer. The offset values must be in bytes.</para>
    </param>
    <remarks>
      <para>An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.</para>
      <para>Calling this method using a buffer that is currently bound for writing will effectively bind <b>NULL</b> instead because a buffer cannot be bound as both an input and an output at the same time.</para>
      <para>The debug layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>Note that unlike some other resource methods in Direct3D, all currently bound targets will be unbound by calling <code>SOSetTargets(0, nullptr, nullptr);</code>.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.Unmap">
    <summary>
      <para>Invalidate the pointer to a resource and reenable the GPU's access to that resource.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to a <see cref="ID3D11Resource" /> interface.</para>
    </param>
    <param name="Subresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A subresource to be unmapped.</para>
    </param>
    <remarks>
      <para>For info about how to use <b>Unmap</b>, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/how-to--use-dynamic-resources">How to: Use dynamic resources</a>.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.UpdateSubresource">
    <summary>
      <para>See the <a href="https://github.com/microsoft/windows-classic-samples/tree/master/samples/basichologram">Basic hologram sample</a>.</para>
      <para>The CPU copies data from memory to a subresource created in non-mappable memory.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the destination resource (see <see cref="ID3D11Resource" />).</para>
    </param>
    <param name="DstSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A zero-based index, that identifies the destination subresource. See <see cref="D3D11CalcSubresource" /> for more details.</para>
    </param>
    <param name="pDstBox">
      <para>Type: <b>const <see cref="D3D11_BOX" />*</b></para>
      <para>A pointer to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If <b>NULL</b>, the data is written to the destination subresource with no offset. The dimensions of the source must fit the destination (see <see cref="D3D11_BOX" />).</para>
      <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>UpdateSubresource</b> doesn't perform an update operation.</para>
    </param>
    <param name="pSrcData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the source data in memory.</para>
    </param>
    <param name="SrcRowPitch">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The size of one row of the source data.</para>
    </param>
    <param name="SrcDepthPitch">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The size of one depth slice of source data.</para>
    </param>
    <remarks>
      <para>For a shader-constant buffer; set <i>pDstBox</i> to <b>NULL</b>. It is not possible to use this method to partially update a shader-constant buffer.</para>
      <para>A resource cannot be used as a destination if:</para>
      <list type="bullet">
        <item>
          <description>the resource is created with <see cref="immutable" /> or <see cref="dynamic" /> usage.</description>
        </item>
        <item>
          <description>the resource is created as a depth-stencil resource.</description>
        </item>
        <item>
          <description>the resource is created with multisampling capability (see <see cref="DXGI_SAMPLE_DESC" />).</description>
        </item>
      </list>
      <para>When <b>UpdateSubresource</b> returns, the application is free to change or even free the data pointed to by <i>pSrcData</i> because the method has already copied/snapped away the original contents.</para>
      <para>The performance of <b>UpdateSubresource</b> depends on whether or not there is contention for the destination resource. For example, contention for a vertex buffer resource occurs when the application executes a <b>Draw</b> call and later calls <b>UpdateSubresource</b> on the same vertex buffer before the <b>Draw</b> call is actually executed by the GPU.</para>
      <list type="bullet">
        <item>
          <description>When there is contention for the resource, <b>UpdateSubresource</b> will perform 2 copies of the source data. First, the data is copied by the CPU to a temporary storage space accessible by the command buffer. This copy happens before the method returns.  A second copy is then performed by the GPU to copy the source data into non-mappable memory. This second copy happens asynchronously because it is executed by GPU when the command buffer is flushed.</description>
        </item>
        <item>
          <description>When there is no resource contention, the behavior of <b>UpdateSubresource</b> is dependent on which is faster (from the CPU's perspective): copying the data to the command buffer and then having a second copy execute when the command buffer is flushed, or having the CPU copy the data to the final resource location. This is dependent on the architecture of the underlying system.</description>
        </item>
      </list>
      <b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <b>UpdateSubresource</b> or <see cref="ID3D11DeviceContext.CopySubresourceRegion" /> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.
<para>To better understand the source row pitch and source depth pitch parameters, the following illustration shows a 3D volume texture.</para><para><img alt="Illustration of a 3D volume texture" src="https://docs.microsoft.com/windows/win32/api/d3d11mages/D3D10_pitches_conceptual.png" /></para><para>Each block in this visual represents an element of data, and the size of each element is dependent on the resource's format. For example, if the resource format is DXGI_FORMAT_R32G32B32A32_FLOAT, the size of each element would be 128 bits, or 16 bytes. This 3D volume texture has a width of two, a height of three, and a depth of four.</para><para>To calculate the source row pitch and source depth pitch for a given resource, use the following formulas:</para><list type="bullet"><item><description>Source Row Pitch = [size of one element in bytes] * [number of elements in one row]</description></item><item><description>Source Depth Pitch = [Source Row Pitch] * [number of rows (height)]</description></item></list><para>In the case of this example 3D volume texture where the size of each element is 16 bytes, the formulas are as follows:</para><list type="bullet"><item><description>Source Row Pitch = 16 * 2 = 32</description></item><item><description>Source Depth Pitch = 16 * 2 * 3 = 96</description></item></list><para>The following illustration shows the resource as it is laid out in memory.</para><para><img alt="Illustration of a 3D volume texture laid out in memory" src="https://docs.microsoft.com/windows/win32/api/d3d11mages/D3D10_pitches.png" /></para><para>For example, the following code snippet shows how to specify a destination region in a 2D texture. Assume the destination texture is 512x512 and the operation will copy the data pointed to by <i>pData</i> to  [(120,100)..(200,220)] in the destination texture. Also assume that <i>rowPitch</i> has been initialized with the proper value (as explained above). <b>front</b> and <b>back</b> are set to 0 and 1 respectively, because by having <b>front</b> equal to <b>back</b>, the box is technically empty.</para><code>
D3D11_BOX destRegion;
destRegion.left = 120;
destRegion.right = 200;
destRegion.top = 100;
destRegion.bottom = 220;
destRegion.front = 0;
destRegion.back = 1;

pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;amp;amp;amp;amp;amp;destRegion, pData, rowPitch, 0 );

</code><para>The 1D case is similar. The following snippet shows how to specify a destination region in a 1D texture. Use the same assumptions as above, except that the texture is 512 in length.</para><code>
D3D11_BOX destRegion;
destRegion.left = 120;
destRegion.right = 200;
destRegion.top = 0;
destRegion.bottom = 1;
destRegion.front = 0;
destRegion.back = 1;

pd3dDeviceContext-&gt;UpdateSubresource( pDestTexture, 0, &amp;amp;amp;amp;amp;amp;destRegion, pData, rowPitch, 0 );

</code><para>For info about various resource types and how <b>UpdateSubresource</b> might work with each resource type, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-intro">Introduction to a Resource in Direct3D 11</a>.</para><h3>Calling UpdateSubresource on a Deferred Context</h3><para>If your application calls <b>UpdateSubresource</b> on a deferred context with a destination box—to which <i>pDstBox</i> points—that has a non-(0,0,0) offset, and if the driver does not support command lists, <b>UpdateSubresource</b> inappropriately applies that destination-box offset to the <i>pSrcData</i> parameter. To work around this behavior, use the following code:</para><code>
HRESULT UpdateSubresource_Workaround(
  ID3D11Device *pDevice,
  ID3D11DeviceContext *pDeviceContext,
  ID3D11Resource *pDstResource,
  UINT dstSubresource,
  const D3D11_BOX *pDstBox,
  const void *pSrcData,
  UINT srcBytesPerElement,
  UINT srcRowPitch,
  UINT srcDepthPitch,
  bool* pDidWorkAround )
{
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( pDstBox &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; (D3D11_DEVICE_CONTEXT_DEFERRED == contextType) )
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) )
          {
               if( !threadingCaps.DriverCommandLists )
               {
                    needWorkaround = true;
               }
          }
     }

     const void* pAdjustedSrcData = pSrcData;

     if( needWorkaround )
     {
          D3D11_BOX alignedBox = *pDstBox;

          // convert from pixels to blocks
          if( m_bBC )
          {
               alignedBox.left     /= 4;
               alignedBox.right    /= 4;
               alignedBox.top      /= 4;
               alignedBox.bottom   /= 4;
          }

          pAdjustedSrcData = ((const BYTE*)pSrcData) - (alignedBox.front * srcDepthPitch) - (alignedBox.top * srcRowPitch) - (alignedBox.left * srcBytesPerElement);
     }

     pDeviceContext-&gt;UpdateSubresource( pDstResource, dstSubresource, pDstBox, pAdjustedSrcData, srcRowPitch, srcDepthPitch );

     if( pDidWorkAround )
     {
          *pDidWorkAround = needWorkaround;
     }

     return hr;
}

</code></remarks>
    <seealso cref="ID3D11DeviceContext" />
    <seealso cref="ID3D11Resource" />
    <seealso href="https://github.com/microsoft/windows-classic-samples/tree/master/samples/basichologram">Basic hologram sample</seealso>
  </member>
  <member name="ID3D11DeviceContext.VSGetConstantBuffers">
    <summary>
      <para>Get the constant buffers used by the vertex shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />**</b></para>
      <para>Array of constant buffer interface pointers (see <see cref="ID3D11Buffer" />) to be returned by the method.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSGetSamplers">
    <summary>
      <para>Get an array of sampler states from the vertex shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into a zero-based array to begin getting samplers from (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers to get from a device context. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />**</b></para>
      <para>Array of sampler-state interface pointers (see <see cref="ID3D11SamplerState" />) to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSGetShader">
    <summary>
      <para>Get the vertex shader currently set on the device.</para>
    </summary>
    <param name="ppVertexShader">
      <para>Type: <b><see cref="ID3D11VertexShader" />**</b></para>
      <para>Address of a pointer to a vertex shader (see <see cref="ID3D11VertexShader" />) to be returned by the method.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />**</b></para>
      <para>Pointer to an array of class instance interfaces (see <see cref="ID3D11ClassInstance" />).</para>
    </param>
    <param name="pNumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>The number of class-instance elements in the array.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSGetShaderResources">
    <summary>
      <para>Get the vertex shader resources.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin getting shader resources from (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources (ranges from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />**</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to be returned by the device.</para>
    </param>
    <remarks>
      <para>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown.Release on the returned interfaces when they are no longer needed to avoid memory leaks.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSSetConstantBuffers">
    <summary>
      <para>Sets the constant buffers used by the vertex shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to <b>D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT</b> - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The Direct3D 11.1 runtime, which is available starting with Windows 8, can bind a larger number of <see cref="ID3D11Buffer" /> resources to the shader than the maximum constant buffer size that is supported by shaders (4096 constants – 4*32-bit components each).  When you bind such a large buffer, the shader can access only the first 4096 4*32-bit component constants in the buffer, as if 4096 constants is the full size of the buffer.</para>
      <para>If the application wants the shader to access other parts of the buffer, it must call the <see cref="VSSetConstantBuffers1" /> method instead.</para>
      <para>
        <b>Windows Phone 8:
</b> This API is supported.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSSetSamplers">
    <summary>
      <para>Set an array of sampler states to the vertex shader pipeline stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting samplers to (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumSamplers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of samplers in the array. Each pipeline stage has a total of 16 sampler slots available (ranges from 0 to D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppSamplers">
      <para>Type: <b><see cref="ID3D11SamplerState" />*</b></para>
      <para>Pointer to an array of sampler-state interfaces (see <see cref="ID3D11SamplerState" />). See Remarks.</para>
    </param>
    <remarks>
      <para>Any sampler may be set to <b>NULL</b>; this invokes the default state, which is defined to be the following.</para>
      <code>
//Default sampler state:
D3D11_SAMPLER_DESC SamplerDesc;
SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
SamplerDesc.MipLODBias = 0;
SamplerDesc.MaxAnisotropy = 1;
SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
SamplerDesc.BorderColor[0] = 1.0f;
SamplerDesc.BorderColor[1] = 1.0f;
SamplerDesc.BorderColor[2] = 1.0f;
SamplerDesc.BorderColor[3] = 1.0f;
SamplerDesc.MinLOD = -FLT_MAX;
SamplerDesc.MaxLOD = FLT_MAX;

</code>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSSetShader">
    <summary>
      <para>Set a vertex shader to the device.</para>
    </summary>
    <param name="pVertexShader">
      <para>Type: <b><see cref="ID3D11VertexShader" />*</b></para>
      <para>Pointer to a vertex shader (see <see cref="ID3D11VertexShader" />). Passing in <b>NULL</b> disables the shader for this pipeline stage.</para>
    </param>
    <param name="ppClassInstances">
      <para>Type: <b><see cref="ID3D11ClassInstance" />*</b></para>
      <para>A pointer to an array of class-instance interfaces (see <see cref="ID3D11ClassInstance" />). Each interface used by a shader must have a corresponding class instance or the shader will get disabled. Set ppClassInstances to <b>NULL</b> if the shader does not use any interfaces.</para>
    </param>
    <param name="NumClassInstances">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of class-instance interfaces in the array.</para>
    </param>
    <remarks>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>The maximum number of instances a shader can have is 256.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext.VSSetShaderResources">
    <summary>
      <para>Bind an array of shader resources to the vertex-shader stage.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting shader resources to (range is from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumViews">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of shader resources to set. Up to a maximum of 128 slots are available for shader resources (range is from 0 to D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot).</para>
    </param>
    <param name="ppShaderResourceViews">
      <para>Type: <b><see cref="ID3D11ShaderResourceView" />*</b></para>
      <para>Array of <see cref="shader resource view" /> interfaces to set to the device.</para>
    </param>
    <remarks>
      <para>If an overlapping resource view is already bound to an output slot, such as a rendertarget, then this API will fill the destination shader resource slot with <b>NULL</b>.</para>
      <para>For information about creating shader-resource views, see <see cref="ID3D11Device.CreateShaderResourceView" />.</para>
      <para>The method will hold a reference to the interfaces passed in.
This differs from the device state behavior in Direct3D 10.</para>
      <para>In order to unbind resource slots, you must pass an array containing null values. For example, to clear the first 4 slots, use:</para>
      <code>ID3D11ShaderResourceView* nullsrv[] = { nullptr, nullptr, nullptr, nullptr };
context-&gt;VSSetShaderResources(0, 4, nullsrv);
</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext" />
  </member>
  <member name="ID3D11DeviceContext">
    <summary>
      <para>The <b>ID3D11DeviceContext</b> interface represents a device context which generates rendering commands.
<b>Note</b>  The latest version of this interface is <see cref="ID3D11DeviceContext4" /> introduced in the Windows 10 Creators Update. Applications targetting Windows 10 Creators Update should use the <b>ID3D11DeviceContext4</b> interface instead of <b>ID3D11DeviceContext</b>.</para>
    </summary>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-graphics-reference-d3d11-core-interfaces">Core Interfaces</seealso>
    <seealso cref="ID3D11DeviceChild" />
  </member>
</doc>