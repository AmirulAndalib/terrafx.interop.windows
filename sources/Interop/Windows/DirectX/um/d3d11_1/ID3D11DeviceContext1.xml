<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="ID3D11DeviceContext1.ClearView">
    <summary>
      <para>Sets all the elements in a resource view to one value.</para>
    </summary>
    <param name="pView">
      <para>A pointer to the <see cref="ID3D11View" /> interface that represents the resource view to clear.</para>
    </param>
    <param name="Color">
      <para>A 4-component array that represents the color to use to clear the resource view.</para>
    </param>
    <param name="pRect">
      <para>An array of <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearView</b> clears the entire surface.</para>
    </param>
    <param name="NumRects">
      <para>Number of rectangles in the array that the  <i>pRect</i> parameter specifies.</para>
    </param>
    <remarks>
      <para>
        <b>ClearView</b> works only on render-target views (RTVs), depth/stencil views (DSVs) on depth-only resources (resources with no stencil component), unordered-access views (UAVs), or any video view of a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/sm5-object-texture2d">Texture2D</a> surface. The runtime drops invalid calls. Empty rectangles in the <i>pRect</i> array are a no-op. A rectangle is empty if the top value equals the bottom value or the left value equals the right value.</para>
      <para>
        <b>ClearView</b> doesn’t support 3D textures.</para>
      <para>
        <b>ClearView</b> applies the same color value to all array slices in a view; all rectangles in the <i>pRect</i> array correspond to each array slice.  The <i>pRect</i> array of rectangles is a set of areas to clear on a single surface.  If the view is an array, <b>ClearView</b> clears all the rectangles on each array slice individually.</para>
      <para>When you apply rectangles to buffers, set the top value to 0 and the bottom value to 1 and set the left value and right value to describe the extent within the buffer. When the top value equals the bottom value or the left value equals the right value, the rectangle is empty and a no-op is achieved.</para>
      <para>The driver converts and clamps color values to the destination format as appropriate per Direct3D conversion rules.  For example, if the format of the view is <see cref="DXGI_FORMAT_R8G8B8A8_UNORM" />, the driver clamps inputs to 0.0f to 1.0f (+INF -&gt; 1.0f (0XFF)/NaN -&gt; 00f).</para>
      <para>If the format is integer, such as <see cref="DXGI_FORMAT_R8G8B8A8_UINT" />, the runtime interprets inputs as integral floats. Therefore, 235.0f maps to 235 (rounds to zero, out of range/INF values clamp to target range, and NaN to 0).</para>
      <para>Here are the color mappings:</para>
      <list type="bullet">
        <item>
          <description>Color[0]: R (or Y for video)</description>
        </item>
        <item>
          <description>Color[1]: G (or U/Cb for video)</description>
        </item>
        <item>
          <description>Color[2]: B (or V/Cr for video)</description>
        </item>
        <item>
          <description>Color[3]: A</description>
        </item>
      </list>
      <para>For video views with YUV or YCbBr formats, <b>ClearView</b> doesn't convert color values. In situations where the format name doesn’t indicate _UNORM,  _UINT, and so on, <b>ClearView</b> assumes _UINT. Therefore, 235.0f maps to 235 (rounds to zero, out of range/INF values clamp to target range, and NaN to 0).</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.CopySubresourceRegion1">
    <summary>
      <para>Copies a region from a source resource to a destination resource.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the destination resource.</para>
    </param>
    <param name="DstSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Destination subresource index.</para>
    </param>
    <param name="DstX">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The x-coordinate of the upper-left corner of the destination region.</para>
    </param>
    <param name="DstY">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The y-coordinate of the upper-left corner of the destination region. For a 1D subresource, this must be zero.</para>
    </param>
    <param name="DstZ">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The z-coordinate of the upper-left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
    </param>
    <param name="pSrcResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the source resource.</para>
    </param>
    <param name="SrcSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Source subresource index.</para>
    </param>
    <param name="pSrcBox">
      <para>Type: <b>const <see cref="D3D11_BOX" />*</b></para>
      <para>A pointer to a 3D box that defines the region of the source subresource that <b>CopySubresourceRegion1</b> can copy. If <b>NULL</b>, <b>CopySubresourceRegion1</b> copies the entire source subresource. The box must fit within the source resource.</para>
      <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>CopySubresourceRegion1</b> doesn't perform a copy operation.</para>
    </param>
    <param name="CopyFlags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A <see cref="D3D11_COPY_FLAGS" />-typed value that specifies how to perform the copy operation. If you specify zero for no copy option, <b>CopySubresourceRegion1</b> behaves like <see cref="ID3D11DeviceContext.CopySubresourceRegion" />. For existing display drivers that can't process these flags, the runtime doesn't use them.</para>
    </param>
    <remarks>
      <para>If the display driver supports overlapping, the source and destination subresources can be identical, and the source and destination regions can overlap each other.  For existing display drivers that don’t support overlapping, the runtime drops calls with identical source and destination subresources, regardless of whether the regions overlap.  To determine whether the display driver supports overlapping, check the <b>CopyWithOverlap</b> member of <see cref="D3D11_FEATURE_DATA_D3D11_OPTIONS" />. This overlapping support enables additional scroll functionality in a call to <see cref="IDXGISwapChain.Present" />.</para>
      <para>
        <b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <see cref="ID3D11DeviceContext1.UpdateSubresource1" /> or <b>CopySubresourceRegion1</b> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.CSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the compute-shader stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.CSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the compute-shader stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>The runtime drops the call to <b>CSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>CSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <see cref="CSSetConstantBuffers" /> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling CSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>CSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
      <para>
        <b>CSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
      <para>behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;CSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;CSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;CSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;CSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;CSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;CSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;CSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.DiscardResource">
    <summary>
      <para>Discards a resource from the device context.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D11Resource" /> interface for the resource to discard. The resource must have been created with usage <see cref="D3D11_USAGE_DEFAULT" /> or <see cref="D3D11_USAGE_DYNAMIC" />, otherwise the runtime drops the call to <b>DiscardResource</b>; if the debug layer is enabled, the runtime returns an error message.</para>
    </param>
    <remarks>
      <para>
        <b>DiscardResource</b> informs the graphics processing unit (GPU) that the existing content in the resource that <i>pResource</i> points to is no longer needed.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.DiscardView">
    <summary>
      <para>Discards a resource view from the device context.</para>
    </summary>
    <param name="pResourceView">
      <para>Type: <b><see cref="ID3D11View" />*</b></para>
      <para>A pointer to the <see cref="ID3D11View" /> interface for the resource view to discard. The resource that underlies the view must have been created with usage <see cref="D3D11_USAGE_DEFAULT" /> or <see cref="D3D11_USAGE_DYNAMIC" />, otherwise the runtime drops the call to <b>DiscardView</b>; if the debug layer is enabled, the runtime returns an error message.</para>
    </param>
    <remarks>
      <para>
        <b>DiscardView</b> informs the graphics processing unit (GPU) that the existing content in the resource view that <i>pResourceView</i> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <b>DiscardView</b> is a variation on the <see cref="DiscardResource" /> method.  <b>DiscardView</b> allows you to discard a subset of a resource that is in a view (such as a single miplevel).  More importantly, <b>DiscardView</b> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <b>DiscardResource</b> can do the job for any resource.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.DiscardView1">
    <summary>
      <para>Discards the specified elements in a resource view from the device context.</para>
    </summary>
    <param name="pResourceView">
      <para>Type: <b><see cref="ID3D11View" />*</b></para>
      <para>A pointer to the <see cref="ID3D11View" /> interface for the resource view to discard. The resource that underlies the view must have been created with usage <see cref="D3D11_USAGE_DEFAULT" /> or <see cref="D3D11_USAGE_DYNAMIC" />, otherwise the runtime drops the call to <b>DiscardView1</b>; if the debug layer is enabled, the runtime returns an error message.</para>
    </param>
    <param name="pRects">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a>*</b></para>
      <para>An array of <a href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-rect">D3D11_RECT</a> structures for the rectangles in the resource view to discard. If <b>NULL</b>, <b>DiscardView1</b> discards the entire view and behaves the same as <see cref="DiscardView" />.</para>
    </param>
    <param name="NumRects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of rectangles in the array that the  <i>pRects</i> parameter specifies.</para>
    </param>
    <remarks>
      <para>
        <b>DiscardView1</b> informs the graphics processing unit (GPU) that the existing content in the specified elements in the resource view that <i>pResourceView</i> points to is no longer needed.  The view can be an SRV, RTV, UAV, or DSV.  <b>DiscardView1</b> is a variation on the <see cref="DiscardResource" /> method.  <b>DiscardView1</b> allows you to discard elements of a subset of a resource that is in a view (such as elements of a single miplevel).  More importantly, <b>DiscardView1</b> provides a convenience because often views are what are being bound and unbound at the pipeline.  Some pipeline bindings do not have views, such as stream output.  In that situation, <b>DiscardResource</b> can do the job for any resource.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.DSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the domain-shader stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.DSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the domain-shader stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffers being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>The runtime drops the call to <b>DSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>DSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <see cref="DSSetConstantBuffers" /> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling DSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>DSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
      <para>
        <b>DSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
      <para>behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;DSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;DSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;DSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;DSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;DSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;DSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;DSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.GSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the geometry shader pipeline stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.GSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the geometry shader pipeline stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffers (see <see cref="ID3D11Buffer" />) being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>The runtime drops the call to <b>GSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>GSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <see cref="GSSetConstantBuffers" /> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling GSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>GSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
      <para>
        <b>GSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
      <para>behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;GSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;GSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;GSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;GSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;GSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;GSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;GSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.HSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a> uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.HSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/direct3d-11-advanced-stages-tessellation">hull-shader stage</a> of the pipeline uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffers being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>The runtime drops the call to <b>HSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>HSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If the <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <see cref="HSSetConstantBuffers" /> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling HSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>HSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
      <para>
        <b>HSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
      <para>behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;HSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;HSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;HSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;HSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;HSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;HSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;HSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.PSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the pixel shader pipeline stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.PSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the pixel shader pipeline stage uses, and enables the shader to access other parts of the buffer.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies.
Each offset specifies where, from the shader's point of view, each constant buffer starts.
Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).
Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer.
Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies.
Each number specifies the number of constants that are contained in the constant buffer that the shader uses.
Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array.
Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>To enable the shader to access other parts of the buffer, call
<b>PSSetConstantBuffers1</b> instead of <see cref="PSSetConstantBuffers" />.
<b>PSSetConstantBuffers1</b> has additional parameters <i>pFirstConstant</i> and <i>pNumConstants</i>.</para>
      <para>The runtime drops the call to <b>PSSetConstantBuffers1</b> if the numbers of constants to which <i>pNumConstants</i> points
is larger than the maximum constant buffer size that is supported by shaders.
The maximum constant buffer size that is supported by shaders holds 4096 constants, where each constant has four 32-bit components.</para>
      <para>The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer;
from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and
the following window (range):</para>
      <para>[value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]</para>
      <para>That is, the window is the range is from (value in an element of <i>pFirstConstant</i>) to (value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>).</para>
      <para>The runtime also drops the call to <b>PSSetConstantBuffers1</b> on existing drivers that do not support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.
This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.
You get this same result if you call the <see cref="PSSetConstantBuffers" /> method.
If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling PSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of
<b>PSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers.
This behavior occurs when <b>PSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update.
This section shows how to work around this behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;PSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;PSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;PSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;PSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;PSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;PSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;PSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.SwapDeviceContextState">
    <summary>
      <para>Activates the given context state object and changes the current device behavior to Direct3D 11, Direct3D 10.1, or Direct3D 10.</para>
    </summary>
    <param name="pState">
      <para>A pointer to the <see cref="ID3DDeviceContextState" /> interface for the context state object that was previously created through the <see cref="ID3D11Device1.CreateDeviceContextState" /> method. If <b>SwapDeviceContextState</b> is called with <i>pState</i> set to <b>NULL</b>, the call has no effect.</para>
    </param>
    <param name="ppPreviousState">
      <para>A pointer to a variable that receives a pointer to the <see cref="ID3DDeviceContextState" /> interface for the previously-activated context state object.</para>
    </param>
    <remarks>
      <para>
        <b>SwapDeviceContextState</b> changes device behavior. This device behavior depends on the emulated interface that you passed to the <i>EmulatedInterface</i> parameter of the  <see cref="ID3D11Device1.CreateDeviceContextState" /> method when you created the context state object.</para>
      <para>
        <b>SwapDeviceContextState</b> is not supported on a deferred context.</para>
      <para>
        <b>SwapDeviceContextState</b> disables the incompatible device interfaces <see cref="ID3D10Device" />, <see cref="ID3D10Device1" />, <see cref="ID3D11Device" />, and <see cref="ID3D11Device1" />. When a context state object is active, the runtime disables certain methods on the device and context interfaces. A context state object that is created with <code>__uuidof(ID3D11Device1)</code> or <code>__uuidof(ID3D11Device)</code> turns off most of the Direct3D 10 device interfaces. A context state object that is created with <code>__uuidof(ID3D10Device1)</code> or <code>__uuidof(ID3D10Device)</code> turns off most of the <see cref="ID3D11DeviceContext" /> methods.
For more information about this behavior, see <see cref="ID3D11Device1.CreateDeviceContextState" />.</para>
      <para>
        <b>SwapDeviceContextState</b> activates the context state object specified by <i>pState</i>. This means that the device behaviors that are associated with the context state object's feature level and compatible interface are activated on the Direct3D device until the next call to <b>SwapDeviceContextState</b>. In addition, any state that was saved when this context state object was last active is now reactivated, so that the previous state is replaced.</para>
      <para>
        <b>SwapDeviceContextState</b> sets <i>ppPreviousState</i> to the most recently activated context state object. The object allows the caller to save and then later restore the previous device state. This behavior is useful in a plug-in architecture such as Direct2D that shares a Direct3D device with its plug-ins. A Direct2D interface can use context state objects to save and restore the application's state.</para>
      <para>If the caller did not previously call the <see cref="ID3D11Device1.CreateDeviceContextState" /> method to create a previous context state object, <b>SwapDeviceContextState</b> sets <i>ppPreviousState</i> to the default context state object. In either case, usage of <b>SwapDeviceContextState</b> is the same.</para>
      <para>The feature level that is specified by the application, and that is chosen by the context state object from the acceptable list that the application supplies to <see cref="ID3D11Device1.CreateDeviceContextState" />, controls the feature level of the immediate context whenever the context state object is active. Because the Direct3D 11 device is free-threaded, the device methods cannot query the current immediate context feature level. Instead, the device runs at a feature level that is the maximum of all previously created context state objects' feature levels. This means that the device's feature level can increase dynamically.</para>
      <para>The feature level of the context state object controls the functionality available from the immediate context. However, to maintain the free-threaded contract of the Direct3D 11 device methods—the resource-creation methods in particular—the upper-bound feature level of all created context state objects controls the set of resources that the device creates.</para>
      <para>Because the context state object interface is published by the immediate context, the interface requires the same threading model as the immediate context. Specifically, <b>SwapDeviceContextState</b> is single-threaded with respect to the other immediate context methods and with respect to the equivalent methods of <see cref="ID3D10Device" />.</para>
      <para>Crucially, because only one of the Direct3D 10 or Direct3D 11 ref-count behaviors can be available at a time, one of the Direct3D 10 and Direct3D 11 interfaces must break its ref-count contract. To avoid this situation, the activation of a context state object turns off the incompatible version interface. Also, if you call a method of an incompatible version interface, the call silently fails if the method has  return type <b>void</b>, returns an <b>HRESULT</b> value of <b>E_INVALIDARG</b>, or sets any out parameter to <b>NULL</b>.</para>
      <para>When you switch from Direct3D 11 mode to either Direct3D 10 mode or Direct3D 10.1 mode, the binding behavior of the device changes. Specifically, the final release of a resource induces unbind in Direct3D 10 mode or Direct3D 10.1 mode. During final release an application releases all of the resource's references, including indirect references such as the linkage from view to resource, and the linkage from context state object to any of the context state object's bound resources. Any bound resource to which the application has no reference is unbound and destroyed, in order to maintain the Direct3D 10 behavior.</para>
      <para>
        <b>SwapDeviceContextState</b> does not affect any state that <see cref="ID3D11VideoContext" /> sets.</para>
      <para>Command lists that are generated by deferred contexts do not hold a reference to context state objects and are not affected by future updates to context state objects.</para>
      <para>No asynchronous objects are affected by <b>SwapDeviceContextState</b>. For example, if a query is active before a call to <b>SwapDeviceContextState</b>, it is still active after the call.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.UpdateSubresource1">
    <summary>
      <para>The CPU copies data from memory to a subresource created in non-mappable memory.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: <b><see cref="ID3D11Resource" />*</b></para>
      <para>A pointer to the destination resource.</para>
    </param>
    <param name="DstSubresource">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A zero-based index that identifies the destination subresource. See <see cref="D3D11CalcSubresource" /> for more details.</para>
    </param>
    <param name="pDstBox">
      <para>Type: <b>const <see cref="D3D11_BOX" />*</b></para>
      <para>A pointer to a box that defines the portion of the destination subresource to copy the resource data into. Coordinates are in bytes for buffers and in texels for textures. If <b>NULL</b>, <b>UpdateSubresource1</b> writes the data to the destination subresource with no offset. The dimensions of the source must fit the destination.</para>
      <para>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <b>UpdateSubresource1</b> doesn't perform an update operation.</para>
    </param>
    <param name="pSrcData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the source data in memory.</para>
    </param>
    <param name="SrcRowPitch">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The size of one row of the source data.</para>
    </param>
    <param name="SrcDepthPitch">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The size of one depth slice of source data.</para>
    </param>
    <param name="CopyFlags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A <see cref="D3D11_COPY_FLAGS" />-typed value that specifies how to perform the update operation. If you specify zero for no update option, <b>UpdateSubresource1</b> behaves like <see cref="ID3D11DeviceContext.UpdateSubresource" />. For existing display drivers that can't process these flags, the runtime doesn't use them.</para>
    </param>
    <remarks>
      <para>If you call <b>UpdateSubresource1</b> to update a constant buffer, pass any region, and the driver has not been implemented to Windows 8, the runtime drops the call (except <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3 where the runtime emulates support).  The runtime also drops the call if you update a constant buffer with a partial region whose extent is not aligned to 16-byte granularity (16 bytes being a full constant). When the runtime drops the call, the runtime doesn't call the corresponding device driver interface (DDI).</para>
      <para>When you record a call to <see cref="UpdateSubresource" /> with an offset <i>pDstBox</i> in a software command list, the offset in <i>pDstBox</i> is incorrectly applied to <i>pSrcData</i> when you play back the command list.  The new-for-Windows 8<b>UpdateSubresource1</b> fixes this issue. In a call to <b>UpdateSubresource1</b>, <i>pDstBox</i> does not affect <i>pSrcData</i>.</para>
      <para>For info about various resource types and how <b>UpdateSubresource1</b> might work with each resource type, see <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-resources-intro">Introduction to a Resource in Direct3D 11</a>.</para>
      <para>
        <b>Note</b>  <b>Applies only to feature level 9_x hardware</b> If you use <b>UpdateSubresource1</b> or <see cref="ID3D11DeviceContext1.CopySubresourceRegion1" /> to copy from a staging resource to a default resource, you can corrupt the destination contents. This occurs if you pass a <b>NULL</b> source box and if the source resource has different dimensions from those of the destination resource or if you use destination offsets, (x, y, and z). In this situation, always pass a source box that is the full size of the source resource.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.VSGetConstantBuffers1">
    <summary>
      <para>Gets the constant buffers that the vertex shader pipeline stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Index into the device's zero-based array to begin retrieving constant buffers from (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Number of buffers to retrieve (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Array of constant buffer interface pointers to be returned by the method.</para>
    </param>
    <param name="pFirstConstant">
      <para>A pointer to an array that receives the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 2 indicates that the start of the associated constant buffer is 32 bytes into the constant buffer. The runtime sets <i>pFirstConstant</i> to <b>NULL</b> if the buffers do not have offsets.</para>
    </param>
    <param name="pNumConstants">
      <para>A pointer to an array that receives the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. The runtime sets <i>pNumConstants</i> to <b>NULL</b> if it doesn't specify the numbers of constants in each buffer.</para>
    </param>
    <remarks>
      <para>If no buffer is bound at a slot, <i>pFirstConstant</i> and <i>pNumConstants</i> are <b>NULL</b> for that slot.</para>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1.VSSetConstantBuffers1">
    <summary>
      <para>Sets the constant buffers that the vertex shader pipeline stage uses.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index into the device's zero-based array to begin setting constant buffers to (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1).</para>
    </param>
    <param name="NumBuffers">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of buffers to set (ranges from 0 to D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - <i>StartSlot</i>).</para>
    </param>
    <param name="ppConstantBuffers">
      <para>Type: <b><see cref="ID3D11Buffer" />*</b></para>
      <para>Array of constant buffers being given to the device.</para>
    </param>
    <param name="pFirstConstant">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array that holds the offsets into the buffers that  <i>ppConstantBuffers</i> specifies. Each offset specifies where, from the shader's point of view, each constant buffer starts.  Each offset is measured in shader constants, which are 16 bytes (4*32-bit components).  Therefore, an offset of 16 indicates that the start of the associated constant buffer is 256 bytes into the constant buffer. Each offset must be a multiple of 16 constants.</para>
    </param>
    <param name="pNumConstants">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array that holds the numbers of constants in the buffers that  <i>ppConstantBuffers</i> specifies. Each number specifies the number of constants that are contained in the constant buffer that the shader uses. Each number of constants starts from its respective offset that is specified in the <i>pFirstConstant</i> array. Each number of constants must be a multiple of 16 constants, in the range [0..4096].</para>
    </param>
    <remarks>
      <para>The runtime drops the call to <b>VSSetConstantBuffers1</b> if the number of constants to which <i>pNumConstants</i> points is larger than the maximum constant buffer size that is supported by shaders (4096 constants).  The values in the elements of the <i>pFirstConstant</i> and <i>pFirstConstant</i> + <i>pNumConstants</i> arrays can exceed the length of each buffer; from the shader's point of view, the constant buffer is the intersection of the actual memory allocation for the buffer and the window [value in an element of <i>pFirstConstant</i>, value in an element of <i>pFirstConstant</i> + value in an element of <i>pNumConstants</i>]. The runtime also drops the call to <b>VSSetConstantBuffers1</b> on existing drivers that don't support this offsetting.</para>
      <para>The runtime will emulate this feature for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature level</a> 9.1, 9.2, and 9.3; therefore, this feature is supported for feature level 9.1, 9.2, and 9.3.  This feature is always available on new drivers for feature level 10 and higher.</para>
      <para>From the shader’s point of view, element [0] in the constant buffers array is the constant at <i>pFirstConstant</i>.</para>
      <para>Out of bounds access to the constant buffers from the shader to the range that is defined by <i>pFirstConstant</i> and <i>pNumConstants</i> returns 0.</para>
      <para>If <i>pFirstConstant</i> and <i>pNumConstants</i> arrays are <b>NULL</b>, you get the same result as if you were binding the entire buffer into view.  You get this same result if you call the <see cref="VSSetConstantBuffers" /> method. If the buffer is larger than the maximum constant buffer size that is supported by shaders (4096 elements), the shader can access only the first 4096 constants.</para>
      <para>If either <i>pFirstConstant</i> or <i>pNumConstants</i> is <b>NULL</b>, the other parameter must also be <b>NULL</b>.</para>
      <h3>Calling VSSetConstantBuffers1 with command list emulation</h3>
      <para>The runtime's <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-command-list">command list</a> emulation of <b>VSSetConstantBuffers1</b> sometimes doesn't actually change the offsets or sizes for the arrays of constant buffers. This behavior occurs when</para>
      <para>
        <b>VSSetConstantBuffers1</b> doesn't effectively change the constant buffers at the beginning and end of the range of slots that you set to update. This section shows how to work around this</para>
      <para>behavior.</para>
      <para>Here is the code to check whether either the runtime emulates command lists or the driver supports command lists:</para>
      <code>
     HRESULT hr = S_OK;
     bool needWorkaround = false;
     D3D11_DEVICE_CONTEXT_TYPE contextType = pDeviceContext-&gt;GetType();

     if( D3D11_DEVICE_CONTEXT_DEFERRED == contextType)
     {
          D3D11_FEATURE_DATA_THREADING threadingCaps = { FALSE, FALSE };

          hr = pDevice-&gt;CheckFeatureSupport( D3D11_FEATURE_THREADING, &amp;amp;amp;amp;amp;amp;threadingCaps, sizeof(threadingCaps) );
          if( SUCCEEDED(hr) &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp; !threadingCaps.DriverCommandLists )
          {
               needWorkaround = true; // the runtime emulates command lists.
          }
     }

</code>
      <para>If the runtime emulates command lists, you need to use one of these code snippets:</para>
      <para>If you change the offset and size on only a single constant buffer, set the constant buffer to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;VSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;VSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;VSSetConstantBuffers1(0, 1, &amp;amp;amp;amp;amp;amp;CBuf, &amp;amp;amp;amp;amp;amp;Offset, &amp;amp;amp;amp;amp;amp;Count);

</code>
      <para>If you change multiple constant buffers, set the first and last constant buffers of the range to <b>NULL</b> first:</para>
      <code>
     pDeviceContext-&gt;VSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);
     if( needWorkaround )
     {
          // Workaround for command list emulation
          pDeviceContext-&gt;VSSetConstantBuffers(0, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
          pDeviceContext-&gt;VSSetConstantBuffers(3, 1, &amp;amp;amp;amp;amp;amp;NullCBuf);
     }
     pDeviceContext-&gt;VSSetConstantBuffers1(0, 4, &amp;amp;amp;amp;amp;amp;CBufs, &amp;amp;amp;amp;amp;amp;Offsets, &amp;amp;amp;amp;amp;amp;Counts);

</code>
    </remarks>
    <seealso cref="ID3D11DeviceContext1" />
  </member>
  <member name="ID3D11DeviceContext1">
    <summary>
      <para>The device context interface represents a device context; it is used to render commands. <b>ID3D11DeviceContext1</b> adds new methods to those in <see cref="ID3D11DeviceContext" />.</para>
    </summary>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d11/d3d11-graphics-reference-d3d11-core-interfaces">Core Interfaces</seealso>
    <seealso cref="ID3D11DeviceContext" />
  </member>
</doc>