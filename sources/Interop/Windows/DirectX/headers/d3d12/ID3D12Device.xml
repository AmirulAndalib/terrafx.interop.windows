<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="ID3D12Device.CheckFeatureSupport">
    <summary>
      <para>Gets information about the features that are supported by the current graphics driver.</para>
    </summary>
    <param name="Feature">
      <para>Type: <b><see cref="D3D12_FEATURE" /></b></para>
      <para>A constant from the <see cref="D3D12_FEATURE" /> enumeration describing the feature(s) that you want to query for support.</para>
    </param>
    <param name="pFeatureSupportData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a data structure that corresponds to the value of the <i>Feature</i> parameter. To determine the corresponding data structure for each constant, see <see cref="D3D12_FEATURE" />.</para>
    </param>
    <param name="FeatureSupportDataSize">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The size of the structure pointed to by the <i>pFeatureSupportData</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns <b>S_OK</b> if successful. Returns <b>E_INVALIDARG</b> if an unsupported data type is passed to the <i>pFeatureSupportData</i> parameter or if a size mismatch is detected for the <i>FeatureSupportDataSize</i> parameter.</para>
    </returns>
    <remarks>
      <para>As a usage example, to check for ray tracing support, specify the <see cref="D3D12_FEATURE_DATA_D3D12_OPTIONS5" /> structure in the <i>pFeatureSupportData</i> parameter. When the function completes successfully, access the <i>RaytracingTier</i> field (which specifies the supported ray tracing tier) of the now-populated <b>D3D12_FEATURE_DATA_D3D12_OPTIONS5</b> structure.</para>
      <para>For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d12/capability-querying">Capability Querying</a>.</para>
      <h3>Hardware support for DXGI Formats</h3>
      <para>To view tables of DXGI formats and hardware features, refer to:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/hardware-support-for-direct3d-12-1-formats">DXGI Format  Support for Direct3D Feature Level 12.1 Hardware</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/hardware-support-for-direct3d-12-0-formats">DXGI Format  Support for Direct3D Feature Level 12.0 Hardware</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/format-support-for-direct3d-11-1-feature-level-hardware">DXGI Format  Support for Direct3D Feature Level 11.1 Hardware</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/format-support-for-direct3d-11-0-feature-level-hardware">DXGI Format  Support for Direct3D Feature Level 11.0 Hardware</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//previous-versions/ff471324(v=vs.85)">Hardware Support for Direct3D 10Level9 Formats</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/format-support-for-direct3d-feature-level-10-1-hardware">Format Support for Direct3D Feature Level 10.1 Hardware</a>
          </description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/format-support-for-direct3d-feature-level-10-0-hardware">Format Support for Direct3D Feature Level 10.0 Hardware</a>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D1211on12</a> sample uses <b>ID3D12Device.CheckFeatureSupport</b> as follows:</para>
      <code>inline UINT8 D3D12GetFormatPlaneCount(
    _In_ ID3D12Device* pDevice,
    DXGI_FORMAT Format
    )
{
    D3D12_FEATURE_DATA_FORMAT_INFO formatInfo = {Format};
    if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;amp;amp;amp;amp;amp;formatInfo, sizeof(formatInfo))))
    {
        return 0;
    }
    return formatInfo.PlaneCount;
}

</code>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CopyDescriptors">
    <summary>
      <para>Copies descriptors from a source to a destination.</para>
    </summary>
    <param name="NumDestDescriptorRanges">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of destination descriptor ranges to copy to.</para>
    </param>
    <param name="pDestDescriptorRangeStarts">
      <para>Type: <b>const <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" />*</b></para>
      <para>An array of <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b> objects to copy to.</para>
      <para>All the destination and source descriptors must be in heaps of the same <see cref="D3D12_DESCRIPTOR_HEAP_TYPE" />.</para>
    </param>
    <param name="pDestDescriptorRangeSizes">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array of destination descriptor range sizes to copy to.</para>
    </param>
    <param name="NumSrcDescriptorRanges">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of source descriptor ranges to copy from.</para>
    </param>
    <param name="pSrcDescriptorRangeStarts">
      <para>Type: <b>const <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" />*</b></para>
      <para>An array of <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b> objects to copy from.</para>
      <blockquote>
        <para>[!IMPORTANT]
All elements in the <i>pSrcDescriptorRangeStarts</i> parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage" descriptor heaps to the GPU-bound descriptor heap, use shader-opaque heaps for the storage heaps and copy into the GPU-visible heap as required.</para>
      </blockquote>
    </param>
    <param name="pSrcDescriptorRangeSizes">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a>*</b></para>
      <para>An array of source descriptor range sizes to copy from.</para>
    </param>
    <param name="DescriptorHeapsType">
      <para>Type: <b><see cref="D3D12_DESCRIPTOR_HEAP_TYPE" /></b></para>
      <para>The <see cref="D3D12_DESCRIPTOR_HEAP_TYPE" />-typed value that specifies the type of descriptor heap to copy with. This is required as different descriptor types may have different sizes.</para>
      <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
    </param>
    <remarks>
      <para>Where applicable, prefer <see cref="ID3D12Device.CopyDescriptorsSimple" /> to this method. It can have a better CPU cache miss rate due to the linear nature of the copy.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/copying-descriptors">Copying Descriptors</seealso>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CopyDescriptorsSimple">
    <summary>
      <para>Copies descriptors from a source to a destination.</para>
    </summary>
    <param name="NumDescriptors">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of descriptors to copy.</para>
    </param>
    <param name="DestDescriptorRangeStart">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b> that describes the destination descriptors to start to copy to.</para>
      <para>The destination and source descriptors must be in heaps of the same <see cref="D3D12_DESCRIPTOR_HEAP_TYPE" />.</para>
    </param>
    <param name="SrcDescriptorRangeStart">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b> that describes the source descriptors to start to copy from.</para>
      <blockquote>
        <para>[!IMPORTANT]
The <i>SrcDescriptorRangeStart</i> parameter must be in a non shader-visible descriptor heap. This is because shader-visible descriptor heaps may be created in <b>WRITE_COMBINE</b> memory or GPU local memory, which is prohibitively slow to read from. If your application manages descriptor heaps via copying the descriptors required for a given pass or frame from local "storage" descriptor heaps to the GPU-bound descriptor heap, then use shader-opaque heaps for the storage heaps and copy into the GPU-visible heap as required.</para>
      </blockquote>
    </param>
    <param name="DescriptorHeapsType">
      <para>Type: <b><see cref="D3D12_DESCRIPTOR_HEAP_TYPE" /></b></para>
      <para>The <see cref="D3D12_DESCRIPTOR_HEAP_TYPE" />-typed value that specifies the type of descriptor heap to copy with. This is required as different descriptor types may have different sizes.</para>
      <para>Both the source and destination descriptor heaps must have the same type, else the debug layer will emit an error.</para>
    </param>
    <remarks>
      <para>Where applicable, prefer this method to <see cref="ID3D12Device.CopyDescriptors" />. It can have a better CPU cache miss rate due to the linear nature of the copy.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/copying-descriptors">Copying Descriptors</seealso>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateCommandAllocator">
    <summary>
      <para>Creates a command allocator object.</para>
    </summary>
    <param name="type">
      <para>Type: <b><see cref="D3D12_COMMAND_LIST_TYPE" /></b></para>
      <para>A <see cref="D3D12_COMMAND_LIST_TYPE" />-typed value that specifies the type of command allocator to create.
The type of command allocator can be the type that records either direct command lists or bundles.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the command allocator interface (<see cref="ID3D12CommandAllocator" />).
The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command allocator can be obtained by using the __uuidof() macro.
For example, __uuidof(ID3D12CommandAllocator) will get the <b>GUID</b> of the interface to a command allocator.</para>
    </param>
    <param name="ppCommandAllocator">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12CommandAllocator" /> interface for the command allocator.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command allocator.
See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>The device creates command lists from the command allocator.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Bundles</a> sample uses <b>ID3D12Device.CreateCommandAllocator</b> as follows:</para>
      <code>ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_commandAllocator)));
ThrowIfFailed(pDevice-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_BUNDLE, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_bundleAllocator)));

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateCommandList">
    <summary>
      <para>Creates a command list.</para>
    </summary>
    <param name="nodeMask">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT</a></b></para>
      <para>For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set a bit to identify the node (the device's physical adapter) for which to create the command list. Each bit in the mask corresponds to a single node. Only one bit must be set. Also see <a href="https://docs.microsoft.com//windows/win32/direct3d12/multi-engine">Multi-adapter systems</a>.</para>
    </param>
    <param name="type">
      <para>Type: <b><see cref="D3D12_COMMAND_LIST_TYPE" /></b></para>
      <para>Specifies the type of command list to create.</para>
    </param>
    <param name="pCommandAllocator">
      <para>Type: <b><see cref="ID3D12CommandAllocator" />*</b></para>
      <para>A pointer to the command allocator object from which the device creates command lists.</para>
    </param>
    <param name="pInitialState">
      <para>Type: <b><see cref="ID3D12PipelineState" />*</b></para>
      <para>An optional pointer to the pipeline state object that contains the initial pipeline state for the command list. If it is <code>nullptr</code>, then the runtime sets a dummy initial pipeline state, so that drivers don't have to deal with undefined state. The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely dwarfs the cost of a single initial state setting. So there's little cost in not setting the initial pipeline state parameter, if doing so is inconvenient.</para>
      <para>For bundles, on the other hand, it might make more sense to try to set the initial state parameter (since bundles are likely smaller overall, and can be reused frequently).</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the globally unique identifier (<b>GUID</b>) of the command list interface to return in <i>ppCommandList</i>.</para>
    </param>
    <param name="ppCommandList">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12CommandList" /> or <see cref="ID3D12GraphicsCommandList" /> interface for the command list.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <a href="https://docs.microsoft.com//windows/desktop/com/structure-of-com-error-codes">HRESULT</a><a href="https://docs.microsoft.com//windows/win32/com/com-error-codes-10">error code</a>.</para>
      <para>|Return value|Description|
|-|-|
|E_OUTOFMEMORY|There is insufficient memory to create the command list.|</para>
      <para>See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 return codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>The device creates command lists from the command allocator.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
    <seealso cref="ID3D12GraphicsCommandList.Reset" />
  </member>
  <member name="ID3D12Device.CreateCommandQueue">
    <summary>
      <para>Creates a command queue.</para>
      <para>Also see <see cref="ID3D12Device9.CreateCommandQueue1" />.</para>
    </summary>
    <param name="pDesc">
      <para>Type: [in] <b>const <see cref="D3D12_COMMAND_QUEUE_DESC" />*</b></para>
      <para>Specifies a <b>D3D12_COMMAND_QUEUE_DESC</b> that describes the command queue.</para>
    </param>
    <param name="riid">
      <para>Type: <b><b>REFIID</b></b></para>
      <para>The globally unique identifier (GUID) for the command queue interface. See <b>Remarks</b>. An input parameter.</para>
    </param>
    <param name="ppCommandQueue">
      <para>Type: [out] <b><b>void</b>**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12CommandQueue" /> interface for the command queue.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the command queue. See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 return codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command queue can be obtained by using the __uuidof() macro. For example, __uuidof(ID3D12CommandQueue) will get the <b>GUID</b> of the interface to a command queue.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
    <seealso cref="ID3D12Device9.CreateCommandQueue1" />
  </member>
  <member name="ID3D12Device.CreateCommandSignature">
    <summary>
      <para>This method creates a command signature.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_COMMAND_SIGNATURE_DESC" />*</b></para>
      <para>Describes the command signature to be created with the <see cref="D3D12_COMMAND_SIGNATURE_DESC" /> structure.</para>
    </param>
    <param name="pRootSignature">
      <para>Type: <b><see cref="ID3D12RootSignature" />*</b></para>
      <para>Specifies the  <see cref="ID3D12RootSignature" /> that the command signature applies to.</para>
      <para>The root signature is required if any of the commands in the signature will update bindings on the pipeline. If the only command present is a draw or dispatch, the root signature parameter can be set to NULL.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the command signature interface (<see cref="ID3D12CommandSignature" />).
The <b>REFIID</b>, or <b>GUID</b>, of the interface to the command signature can be obtained by using the __uuidof() macro.
For example, __uuidof(<b>ID3D12CommandSignature</b>) will get the <b>GUID</b> of the interface to a command signature.</para>
    </param>
    <param name="ppvCommandSignature">
      <para>Type: <b>void**</b></para>
      <para>Specifies a pointer, that on successful completion of the method will point to the created command signature (<see cref="ID3D12CommandSignature" />).</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateCommittedResource">
    <summary>
      <para>Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource is mapped to the heap.</para>
    </summary>
    <param name="pHeapProperties">
      <para>Type: <b>const <see cref="D3D12_HEAP_PROPERTIES" />*</b></para>
      <para>A pointer to a <b>D3D12_HEAP_PROPERTIES</b> structure that provides properties for the resource's heap.</para>
    </param>
    <param name="HeapFlags">
      <para>Type: <b><see cref="D3D12_HEAP_FLAGS" /></b></para>
      <para>Heap options, as a bitwise-OR'd combination of <b>D3D12_HEAP_FLAGS</b> enumeration constants.</para>
    </param>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_RESOURCE_DESC" />*</b></para>
      <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
    </param>
    <param name="InitialResourceState">
      <para>Type: <b><see cref="D3D12_RESOURCE_STATES" /></b></para>
      <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
      <para>When you create a resource together with a <see cref="D3D12_HEAP_TYPE_UPLOAD" /> heap, you must set <i>InitialResourceState</i> to <see cref="D3D12_RESOURCE_STATE_GENERIC_READ" />.</para>
      <para>When you create a resource together with a <see cref="D3D12_HEAP_TYPE_READBACK" /> heap, you must set <i>InitialResourceState</i> to <see cref="D3D12_RESOURCE_STATE_COPY_DEST" />.</para>
    </param>
    <param name="pOptimizedClearValue">
      <para>Type: <b>const <see cref="D3D12_CLEAR_VALUE" />*</b></para>
      <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
      <para>
        <i>pOptimizedClearValue</i> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <see cref="D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET" /> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.</para>
      <para>When you use <see cref="D3D12_RESOURCE_DIMENSION_BUFFER" />, you must set <i>pOptimizedClearValue</i> to <code>nullptr</code>.</para>
    </param>
    <param name="riidResource">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the globally unique identifier (<b>GUID</b>) of the resource interface to return in <i>ppvResource</i>.</para>
      <para>While <i>riidResource</i> is most commonly the <b>GUID</b> of <see cref="ID3D12Resource" />, it may be the <b>GUID</b> of any interface. If the resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.</para>
    </param>
    <param name="ppvResource">
      <para>Type: <b>void**</b></para>
      <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
      <para>
        <i>ppvResource</i> can be <code>nullptr</code>, to enable capability testing. When <i>ppvResource</i> is <code>nullptr</code>, no object is created, and <b>S_FALSE</b> is returned when <i>pDesc</i> is valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <a href="https://docs.microsoft.com//windows/desktop/com/structure-of-com-error-codes">HRESULT</a><a href="https://docs.microsoft.com//windows/win32/com/com-error-codes-10">error code</a>.</para>
      <para>|Return value|Description|
|-|-|
|E_OUTOFMEMORY|There is insufficient memory to create the resource.|</para>
      <para>See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 return codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>This method creates both a resource and a heap, such that the heap is big enough to contain the entire resource, and the resource is mapped to the heap. The created heap is known as an implicit heap, because the heap object can't be obtained by the application. Before releasing the final reference on the resource, your application must ensure that the GPU will no longer read nor write to this resource.</para>
      <para>The implicit heap is made resident for GPU access before the method returns control to your application. Also see <a href="https://docs.microsoft.com//windows/win32/direct3d12/residency">Residency</a>.</para>
      <para>The resource GPU VA mapping can't be changed. See <see cref="ID3D12CommandQueue.UpdateTileMappings" /> and <a href="https://docs.microsoft.com//windows/win32/direct3d12/volume-tiled-resources">Volume tiled resources</a>.</para>
      <para>This method may be called by multiple threads concurrently.</para>
    </remarks>
    <seealso cref="CreatePlacedResource" />
    <seealso cref="CreateReservedResource" />
    <seealso cref="D3D12_HEAP_FLAGS" />
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateComputePipelineState">
    <summary>
      <para>Creates a compute pipeline state object.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_COMPUTE_PIPELINE_STATE_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_COMPUTE_PIPELINE_STATE_DESC" /> structure that describes compute pipeline state.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the pipeline state interface (<see cref="ID3D12PipelineState" />).
The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro.
For example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.</para>
    </param>
    <param name="ppPipelineState">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12PipelineState" /> interface for the pipeline state object.
The pipeline state object is an immutable state object.  It contains no methods.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object.
See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateConstantBufferView">
    <summary>
      <para>Creates a constant-buffer view for accessing resource data.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_CONSTANT_BUFFER_VIEW_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_CONSTANT_BUFFER_VIEW_DESC" /> structure that describes the constant-buffer view.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the start of the heap that holds the constant-buffer view.</para>
    </param>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateDepthStencilView">
    <summary>
      <para>Creates a depth-stencil view for accessing resource data.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> object that represents the depth stencil.</para>
      <para>At least one of <i>pResource</i> or <i>pDesc</i>  must be provided.
A null <i>pResource</i> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.</para>
    </param>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_DEPTH_STENCIL_VIEW_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_DEPTH_STENCIL_VIEW_DESC" /> structure that describes the depth-stencil view.</para>
      <para>A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and DSVs target the  first mip and all array slices. Not all resources support null descriptor initialization.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the start of the heap that holds the depth-stencil view.</para>
    </param>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateDescriptorHeap">
    <summary>
      <para>Creates a descriptor heap object.</para>
    </summary>
    <param name="pDescriptorHeapDesc">
      <para>Type: <b>const <see cref="D3D12_DESCRIPTOR_HEAP_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_DESCRIPTOR_HEAP_DESC" /> structure that describes the heap.</para>
    </param>
    <param name="riid">
      <para>Type: <b><b>REFIID</b></b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the descriptor heap interface. See Remarks.
An input parameter.</para>
    </param>
    <param name="ppvHeap">
      <para>Type: <b><b>void</b>**</b></para>
      <para>A pointer to a memory block that receives a pointer to the descriptor heap.
<i>ppvHeap</i> can be NULL, to enable capability testing.
When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDescriptorHeapDesc</i> is valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the descriptor heap object.
See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>The <b>REFIID</b>, or <b>GUID</b>, of the interface to the descriptor heap can be obtained by using the __uuidof() macro. For example, __uuidof(<see cref="ID3D12DescriptorHeap" />) will get the <b>GUID</b> of the interface to a descriptor heap.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloWorld</a> sample uses <b>ID3D12Device.CreateDescriptorHeap</b> as follows:</para>
      <para>Describe and create a render target view (RTV) descriptor heap.</para>
      <code>// Create descriptor heaps.
{
    // Describe and create a render target view (RTV) descriptor heap.
    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
    rtvHeapDesc.NumDescriptors = FrameCount;
    rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
    ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;amp;amp;amp;amp;amp;rtvHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_rtvHeap)));

    m_rtvDescriptorSize = m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
}

// Create frame resources.
{
    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart());

    // Create a RTV for each frame.
    for (UINT n = 0; n &lt; FrameCount; n++)
    {
        ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_renderTargets[n])));
        m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
        rtvHandle.Offset(1, m_rtvDescriptorSize);
    }

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateFence">
    <summary>
      <para>Creates a fence object.</para>
    </summary>
    <param name="InitialValue">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT64</a></b></para>
      <para>The initial value for the fence.</para>
    </param>
    <param name="Flags">
      <para>Type: <b><see cref="D3D12_FENCE_FLAGS" /></b></para>
      <para>A combination of <see cref="D3D12_FENCE_FLAGS" />-typed values that are combined by using a bitwise OR operation.
The resulting value specifies options for the fence.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the fence interface (<see cref="ID3D12Fence" />).
The <b>REFIID</b>, or <b>GUID</b>, of the interface to the fence can be obtained by using the __uuidof() macro.
For example, __uuidof(ID3D12Fence) will get the <b>GUID</b> of the interface to a fence.</para>
    </param>
    <param name="ppFence">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12Fence" /> interface that is used to access the fence.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">HRESULT</a></b></para>
      <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateGraphicsPipelineState">
    <summary>
      <para>Creates a graphics pipeline state object.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_GRAPHICS_PIPELINE_STATE_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_GRAPHICS_PIPELINE_STATE_DESC" /> structure that describes graphics pipeline state.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the pipeline state interface (<see cref="ID3D12PipelineState" />).
The <b>REFIID</b>, or <b>GUID</b>, of the interface to the pipeline state can be obtained by using the __uuidof() macro.
For example, __uuidof(ID3D12PipelineState) will get the <b>GUID</b> of the interface to a pipeline state.</para>
    </param>
    <param name="ppPipelineState">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to the <see cref="ID3D12PipelineState" /> interface for the pipeline state object.
The pipeline state object is an immutable state object.  It contains no methods.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the pipeline state object.
See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateHeap">
    <summary>
      <para>Creates a heap that can be used with placed resources and reserved resources.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_HEAP_DESC" />*</b></para>
      <para>A pointer to a constant <b>D3D12_HEAP_DESC</b> structure that describes the heap.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the globally unique identifier (<b>GUID</b>) of the heap interface to return in <i>ppvHeap</i>.</para>
      <para>While <i>riidResource</i> is most commonly the <b>GUID</b> of <see cref="ID3D12Heap" />, it may be the <b>GUID</b> of any interface. If the resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.</para>
    </param>
    <param name="ppvHeap">
      <para>Type: <b>void**</b></para>
      <para>An optional pointer to a memory block that receives the requested interface pointer to the created heap object.</para>
      <para>
        <i>ppvHeap</i> can be <code>nullptr</code>, to enable capability testing. When <i>ppvHeap</i> is <code>nullptr</code>, no object is created, and <b>S_FALSE</b> is returned when <i>pDesc</i> is valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <a href="https://docs.microsoft.com//windows/desktop/com/structure-of-com-error-codes">HRESULT</a><a href="https://docs.microsoft.com//windows/win32/com/com-error-codes-10">error code</a>.</para>
      <para>|Return value|Description|
|-|-|
|E_OUTOFMEMORY|There is insufficient memory to create the heap.|</para>
      <para>See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 return codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateHeap</b> creates a heap that can be used with placed resources and reserved resources.</para>
      <para>Before releasing the final reference on the heap, your application must ensure that the GPU will no longer read or write to this heap.</para>
      <para>A placed resource object holds a reference on the heap it is created on; but a reserved resource doesn't hold a reference for each mapping made to a heap.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
    <seealso href="https://docs.microsoft.com//windows/win32/direct3d12/shared-heaps">Shared heaps</seealso>
  </member>
  <member name="ID3D12Device.CreatePlacedResource">
    <summary>
      <para>Creates a resource that is placed in a specific heap. Placed resources are the lightest weight resource objects available, and are the fastest to create and destroy.</para>
      <para>Your application can re-use video memory by overlapping multiple Direct3D placed and reserved resources on heap regions. The simple memory re-use model (described in remarks) exists to clarify which overlapping resource is valid at any given time. To maximize graphics tool support, with the simple model data-inheritance isn't supported; and finer-grained tile and sub-resource invalidation isn't supported. Only full overlapping resource invalidation occurs.</para>
    </summary>
    <param name="pHeap">
      <para>Type: [in] <b><see cref="ID3D12Heap" /></b>*</para>
      <para>A pointer to the <b>ID3D12Heap</b> interface that represents the heap in which the resource is placed.</para>
    </param>
    <param name="HeapOffset">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT64</a></b></para>
      <para>The offset, in bytes, to the resource. The <i>HeapOffset</i> must be a multiple of the resource's alignment, and <i>HeapOffset</i> plus the resource size must be smaller than or equal to the heap size. <see cref="GetResourceAllocationInfo" /> must be used to understand the sizes of texture resources.</para>
    </param>
    <param name="pDesc">
      <para>Type: [in] <b>const <see cref="D3D12_RESOURCE_DESC" /></b>*</para>
      <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
    </param>
    <param name="InitialState">
      <para>Type: <b><see cref="D3D12_RESOURCE_STATES" /></b></para>
      <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
      <para>When a resource is created together with a <b>D3D12_HEAP_TYPE_UPLOAD</b> heap, <i>InitialState</i> must be <b>D3D12_RESOURCE_STATE_GENERIC_READ</b>. When a resource is created together with a <b>D3D12_HEAP_TYPE_READBACK</b> heap, <i>InitialState</i> must be <b>D3D12_RESOURCE_STATE_COPY_DEST</b>.</para>
    </param>
    <param name="pOptimizedClearValue">
      <para>Type: [in, optional] <b>const <see cref="D3D12_CLEAR_VALUE" /></b>*</para>
      <para>Specifies a <b>D3D12_CLEAR_VALUE</b> that describes the default value for a clear color.</para>
      <para>
        <i>pOptimizedClearValue</i> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <b>D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</b> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, your application should choose the value that the clear operation will most commonly be called with.</para>
      <para>Clear operations can be called with other values, but those operations will not be as efficient as when the value matches the one passed into resource creation.</para>
      <para>
        <i>pOptimizedClearValue</i> must be NULL when used with <b>D3D12_RESOURCE_DIMENSION_BUFFER</b>.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the resource interface. This is an input parameter.</para>
      <para>The <b>REFIID</b>, or <b>GUID</b>, of the interface to the resource can be obtained by using the <code>__uuidof</code> macro. For example, <code>__uuidof(ID3D12Resource)</code> gets the <b>GUID</b> of the interface to a resource. Although <b>riid</b> is, most commonly, the GUID for <see cref="ID3D12Resource" />, it may be any <b>GUID</b> for any interface. If the resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.</para>
    </param>
    <param name="ppvResource">
      <para>Type: [out, optional] <b>void</b>**</para>
      <para>A pointer to a memory block that receives a pointer to the resource. <i>ppvResource</i> can be NULL, to enable capability testing. When <i>ppvResource</i> is NULL, no object will be created and S_FALSE will be returned when <i>pResourceDesc</i> and other parameters are valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns <b>E_OUTOFMEMORY</b> if there is insufficient memory to create the resource. See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>
        <b>CreatePlacedResource</b> is similar to fully mapping a reserved resource to an offset within a heap; but the virtual address space associated with a heap may be reused as well.</para>
      <para>Placed resources are lighter weight to create and destroy than committed resources are. This is because no heap is created nor destroyed during those operations. In addition, placed resources enable an even lighter weight technique to reuse memory than resource creation and destruction—that is, reuse through aliasing, and aliasing barriers. Multiple placed resources may simultaneously overlap each other on the same heap, but only a single overlapping resource can be used at a time.</para>
      <para>There are two placed resource usage semantics—a simple model, and an advanced model. We recommend that you choose the simple model (it maximizes graphics tool support across the diverse ecosystem of GPUs), unless and until you find that you need the advanced model for your app.</para>
      <h3>Simple model</h3>
      <para>In this model, you can consider a placed resource to be in one of two states: active, or inactive. It's invalid for the GPU to either read or write from an inactive resource. Placed resources are created in the inactive state.</para>
      <para>To activate a resource with an aliasing barrier on a command list, your application must pass the resource in <see cref="D3D12_RESOURCE_ALIASING_BARRIER.pResourceAfter" />. <b>pResourceBefore</b> can be left NULL during an activation. All resources that share physical memory with the activated resource now become inactive, which includes overlapping placed and reserved resources.</para>
      <para>Aliasing barriers should be grouped up and submitted together, in order to maximize efficiency.</para>
      <para>After activation, resources with either the render target or depth stencil flags must be further initialized. See the notes on the required resource initialization below.</para>
      <h4>Notes on the required resource initialization</h4>
      <para>Certain resource types still require initialization. Resources with either the render target or depth stencil flags must be initialized with either a clear operation or a collection of full subresource copies. If an aliasing barrier was used to denote the transition between two aliased resources, the initialization must occur after the aliasing barrier. This initialization is still required whenever a resource would've been activated in the simple model.</para>
      <para>Placed and reserved resources with either the render target or depth stencil flags must be initialized with one of the following operations before other operations are supported.</para>
      <list type="bullet">
        <item>
          <description>A <i>Clear</i> operation; for example <see cref="ClearRenderTargetView" /> or <see cref="ClearDepthStencilView" />.</description>
        </item>
        <item>
          <description>A <see cref="DiscardResource" /> operation.</description>
        </item>
        <item>
          <description>A <i>Copy</i> operation; for example <see cref="CopyBufferRegion" />, <see cref="CopyTextureRegion" />, or <see cref="CopyResource" />.</description>
        </item>
      </list>
      <para>Applications should prefer the most explicit operation that results in the least amount of texels modified. Consider the following examples.</para>
      <list type="bullet">
        <item>
          <description>Using a depth buffer to solve pixel visibility typically requires each depth texel start out at 1.0 or 0. Therefore, a <i>Clear</i> operation should be the most efficient option for aliased depth buffer initialization.</description>
        </item>
        <item>
          <description>An application may use an aliased render target as a destination for tone mapping. Since the application will render over every pixel during the tone mapping, <see cref="DiscardResource" /> should be the most efficient option for initialization.</description>
        </item>
      </list>
      <h3>Advanced model</h3>
      <para>In this model, you can ignore the active/inactive state abstraction. Instead, you must honor these lower-level rules.</para>
      <list type="bullet">
        <item>
          <description>An aliasing barrier must be between two different GPU resource accesses of the same physical memory, as long as those accesses are within the same <see cref="ExecuteCommandLists" /> call.</description>
        </item>
        <item>
          <description>The first rendering operation to certain types of aliased resource must still be an initialization, just like the simple model.</description>
        </item>
      </list>
      <para>Initialization operations must occur either on an entire subresource, or on a 64KB granularity. An entire subresource initialization is supported for all resource types. A 64KB initialization granularity, aligned at a 64KB offset, is supported for buffers and textures with either the 64KB_UNDEFINED_SWIZZLE or 64KB_STANDARD_SWIZZLE texture layout (refer to <see cref="D3D12_TEXTURE_LAYOUT" />).</para>
      <h3>Notes on the aliasing barrier</h3>
      <para>The aliasing barrier may set NULL for both <i>pResourceAfter</i> and <i>pResourceBefore</i>. The memory coherence definition of <see cref="ExecuteCommandLists" /> and an aliasing barrier are the same, such that two aliased accesses to the same physical memory need no aliasing barrier when the accesses are in two different <b>ExecuteCommandLists</b> invocations.</para>
      <para>For D3D12 advanced usage models, the synchronization definition of <see cref="ExecuteCommandLists" /> is equivalent to an aliasing barrier. Therefore, applications may either insert an aliasing barrier between reusing physical memory, or ensure the two aliased usages of physical memory occurs in two separate calls to <b>ExecuteCommandLists</b>.</para>
      <para>The amount of inactivation varies based on resource properties. Textures with undefined memory layouts are the worst case, as the entire texture must be inactivated atomically. For two overlapping resources with defined layouts, inactivation can result in only the overlapping aligned regions of a resource. Data inheritance can even be well-defined. For more details, see <a href="https://docs.microsoft.com//windows/win32/direct3d12/memory-aliasing-and-data-inheritance">Memory aliasing and data inheritance</a>.</para>
    </remarks>
    <seealso cref="CreateCommittedResource" />
    <seealso cref="CreateReservedResource" />
    <seealso cref="ID3D12Device" />
    <seealso href="https://docs.microsoft.com//windows/win32/direct3d12/shared-heaps">Shared Heaps</seealso>
  </member>
  <member name="ID3D12Device.CreateQueryHeap">
    <summary>
      <para>Creates a query heap.
A query heap contains an array of queries.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_QUERY_HEAP_DESC" />*</b></para>
      <para>Specifies the query heap in a <see cref="D3D12_QUERY_HEAP_DESC" /> structure.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Specifies a REFIID that uniquely identifies the heap.</para>
    </param>
    <param name="ppvHeap">
      <para>Type: <b>void**</b></para>
      <para>Specifies a pointer to the heap, that will be returned on successful completion of the method.
<i>ppvHeap</i> can be NULL, to enable capability testing.
When <i>ppvHeap</i> is NULL, no object will be created and S_FALSE will be returned when <i>pDesc</i> is valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <remarks>
      <para>Refer to <a href="https://docs.microsoft.com//windows/desktop/direct3d12/queries">Queries</a> for more information.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12PredicationQueries</a> sample uses <b>ID3D12Device.CreateQueryHeap</b> as follows:</para>
      <para>Create a query heap and a query result buffer.</para>
      <code>// Pipeline objects.
D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocators[FrameCount];
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap;
ComPtr&lt;ID3D12QueryHeap&gt; m_queryHeap;
UINT m_rtvDescriptorSize;
UINT m_cbvSrvDescriptorSize;
UINT m_frameIndex;

// Synchronization objects.
ComPtr&lt;ID3D12Fence&gt; m_fence;
UINT64 m_fenceValues[FrameCount];
HANDLE m_fenceEvent;

// Asset objects.
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12PipelineState&gt; m_queryState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
ComPtr&lt;ID3D12Resource&gt; m_vertexBuffer;
ComPtr&lt;ID3D12Resource&gt; m_constantBuffer;
ComPtr&lt;ID3D12Resource&gt; m_depthStencil;
ComPtr&lt;ID3D12Resource&gt; m_queryResult;
D3D12_VERTEX_BUFFER_VIEW m_vertexBufferView;

</code>
      <code>// Describe and create a heap for occlusion queries.
D3D12_QUERY_HEAP_DESC queryHeapDesc = {};
queryHeapDesc.Count = 1;
queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION;
ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;amp;amp;amp;amp;amp;queryHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_queryHeap)));

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateRenderTargetView">
    <summary>
      <para>Creates a render-target view for accessing resource data.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> object that represents the render target.</para>
      <para>At least one of <i>pResource</i> or <i>pDesc</i>  must be provided.
A null <i>pResource</i> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.</para>
    </param>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_RENDER_TARGET_VIEW_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_RENDER_TARGET_VIEW_DESC" /> structure that describes the render-target view.</para>
      <para>A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and RTVs target the first mip and all array slices. Not all resources support null descriptor initialization.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the destination where the newly-created render target view will reside.</para>
    </param>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateReservedResource">
    <summary>
      <para>Creates a resource that is reserved, and not yet mapped to any pages in a heap.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_RESOURCE_DESC" />*</b></para>
      <para>A pointer to a <b>D3D12_RESOURCE_DESC</b> structure that describes the resource.</para>
    </param>
    <param name="InitialState">
      <para>Type: <b><see cref="D3D12_RESOURCE_STATES" /></b></para>
      <para>The initial state of the resource, as a bitwise-OR'd combination of <b>D3D12_RESOURCE_STATES</b> enumeration constants.</para>
    </param>
    <param name="pOptimizedClearValue">
      <para>Type: <b>const <see cref="D3D12_CLEAR_VALUE" />*</b></para>
      <para>Specifies a <b>D3D12_CLEAR_VALUE</b> structure that describes the default value for a clear color.</para>
      <para>
        <i>pOptimizedClearValue</i> specifies a value for which clear operations are most optimal. When the created resource is a texture with either the <see cref="D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET" /> or <b>D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</b> flags, you should choose the value with which the clear operation will most commonly be called. You can call the clear operation with other values, but those operations won't be as efficient as when the value matches the one passed in to resource creation.</para>
      <para>When you use <see cref="D3D12_RESOURCE_DIMENSION_BUFFER" />, you must set <i>pOptimizedClearValue</i> to <code>nullptr</code>.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the globally unique identifier (<b>GUID</b>) of the resource interface to return in <i>ppvResource</i>. See <b>Remarks</b>.</para>
      <para>While <i>riidResource</i> is most commonly the <b>GUID</b> of <see cref="ID3D12Resource" />, it may be the <b>GUID</b> of any interface. If the resource object doesn't support the interface for this <b>GUID</b>, then creation fails with <b>E_NOINTERFACE</b>.</para>
    </param>
    <param name="ppvResource">
      <para>Type: <b>void**</b></para>
      <para>An optional pointer to a memory block that receives the requested interface pointer to the created resource object.</para>
      <para>
        <i>ppvResource</i> can be <code>nullptr</code>, to enable capability testing. When <i>ppvResource</i> is <code>nullptr</code>, no object is created, and <b>S_FALSE</b> is returned when <i>pDesc</i> is valid.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a><a href="https://docs.microsoft.com//windows/win32/com/com-error-codes-10">error code</a>.</para>
      <para>|Return value|Description|
|-|-|
|E_OUTOFMEMORY|There is insufficient memory to create the resource.|</para>
      <para>See <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 return codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>
        <b>CreateReservedResource</b> is equivalent to <see cref="D3D11_RESOURCE_MISC_TILED" /> in Direct3D 11. It creates a resource with virtual memory only, no backing store.</para>
      <para>You need to map the resource to physical memory (that is, to a heap) using <see cref="CopyTileMappings" /> and <see cref="UpdateTileMappings" />.</para>
      <para>These resource types can only be created when the adapter supports tiled resource tier 1 or greater. The tiled resource tier defines the behavior of accessing a resource that is not mapped to a heap.</para>
    </remarks>
    <seealso cref="CreateCommittedResource" />
    <seealso cref="CreatePlacedResource" />
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateRootSignature">
    <summary>
      <para>Creates a root signature layout.</para>
    </summary>
    <param name="nodeMask">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT</a></b></para>
      <para>For single GPU operation, set this to zero. If there are multiple GPU nodes, set bits to identify the nodes (the  device's physical adapters) to which the root signature is to apply.
Each bit in the mask corresponds to a single node.
Refer to <a href="https://docs.microsoft.com//windows/win32/direct3d12/multi-engine">Multi-adapter systems</a>.</para>
    </param>
    <param name="pBlobWithRootSignature">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">void</a>*</b></para>
      <para>A pointer to the source data for the serialized signature.</para>
    </param>
    <param name="blobLengthInBytes">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">SIZE_T</a></b></para>
      <para>The size, in bytes, of the block of memory that <i>pBlobWithRootSignature</i> points to.</para>
    </param>
    <param name="riid">
      <para>Type: <b><b>REFIID</b></b></para>
      <para>The globally unique identifier (<b>GUID</b>) for the root signature interface. See Remarks.
An input parameter.</para>
    </param>
    <param name="ppvRootSignature">
      <para>Type: <b><b>void</b>**</b></para>
      <para>A pointer to a memory block that receives a pointer to the root signature.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
      <para>This method returns <b>E_INVALIDARG</b> if the blob that <i>pBlobWithRootSignature</i> points to is invalid.</para>
    </returns>
    <remarks>
      <para>If an application procedurally generates a <see cref="D3D12_ROOT_SIGNATURE_DESC" /> data structure, it must pass a pointer to this <b>D3D12_ROOT_SIGNATURE_DESC</b> in a call to <see cref="D3D12SerializeRootSignature" /> to make the serialized form.
The application then passes the serialized form to <i>pBlobWithRootSignature</i> in a call to <b>ID3D12Device.CreateRootSignature</b>.</para>
      <para>The <b>REFIID</b>, or <b>GUID</b>, of the interface to the root signature layout can be obtained by using the __uuidof() macro.
For example, __uuidof(<see cref="ID3D12RootSignature" />) will get the <b>GUID</b> of the interface to a root signature.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/win32/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12Device.CreateRootSignature</b> as follows:</para>
      <para>Create an empty root signature.</para>
      <code>CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

ComPtr&lt;ID3DBlob&gt; signature;
ComPtr&lt;ID3DBlob&gt; error;
ThrowIfFailed(D3D12SerializeRootSignature(&amp;amp;amp;amp;amp;amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;amp;amp;amp;amp;amp;signature, &amp;amp;amp;amp;amp;amp;error));
ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_rootSignature)));

</code>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateSampler">
    <summary>
      <para>Create a sampler object that encapsulates sampling information for a texture.</para>
    </summary>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_SAMPLER_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_SAMPLER_DESC" /> structure that describes the sampler.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the start of the heap that holds the sampler.</para>
    </param>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateShaderResourceView">
    <summary>
      <para>Creates a shader-resource view for accessing data in a resource.</para>
    </summary>
    <param name="pResource">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> object that represents the shader resource.</para>
      <para>At least one of <i>pResource</i> or <i>pDesc</i>  must be provided.
A null <i>pResource</i> is used to initialize a null descriptor, which guarantees D3D11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.</para>
    </param>
    <param name="pDesc">
      <para>Type: <b>const <see cref="D3D12_SHADER_RESOURCE_VIEW_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_SHADER_RESOURCE_VIEW_DESC" /> structure that describes the shader-resource view.</para>
      <para>A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and for buffers SRVs target a full buffer and are typed (not raw or structured), and for textures SRVs target a full texture, all mips and all array slices. Not all resources support null descriptor initialization.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the shader-resource view. This handle can be created in a shader-visible or non-shader-visible descriptor heap.</para>
    </param>
    <remarks>
      <h3>Processing YUV 4:2:0 video formats</h3>
      <para>An app must map the luma (Y) plane separately from the chroma (UV) planes. Developers do this by calling <b>CreateShaderResourceView</b> twice for the same texture and passing in 1-channel and 2-channel formats. Passing in a 1-channel format compatible with the Y plane maps only the Y plane. Passing in a 2-channel format compatible with the UV planes (together) maps only the U and V planes as a single resource view.</para>
      <para>YUV 4:2:0 formats are listed in <see cref="DXGI_FORMAT" />.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12nBodyGravity</a> sample uses <b>ID3D12Device.CreateShaderResourceView</b> as follows:</para>
      <para>Describe and create two shader resource views based on one description.</para>
      <code>D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
srvDesc.Format = DXGI_FORMAT_UNKNOWN;
srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
srvDesc.Buffer.FirstElement = 0;
srvDesc.Buffer.NumElements = ParticleCount;
srvDesc.Buffer.StructureByteStride = sizeof(Particle);
srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle0(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo0 + index, m_srvUavDescriptorSize);
CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle1(m_srvUavHeap-&gt;GetCPUDescriptorHandleForHeapStart(), SrvParticlePosVelo1 + index, m_srvUavDescriptorSize);
m_device-&gt;CreateShaderResourceView(m_particleBuffer0[index].Get(), &amp;amp;amp;amp;amp;amp;srvDesc, srvHandle0);
m_device-&gt;CreateShaderResourceView(m_particleBuffer1[index].Get(), &amp;amp;amp;amp;amp;amp;srvDesc, srvHandle1);

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateSharedHandle">
    <summary>
      <para>Creates a shared handle to a heap, resource, or fence object.</para>
    </summary>
    <param name="pObject">
      <para>Type: <b><see cref="ID3D12DeviceChild" />*</b></para>
      <para>A pointer to the <see cref="ID3D12DeviceChild" /> interface that represents the heap, resource, or fence object to create for sharing.
The following interfaces (derived from <b>ID3D12DeviceChild</b>) are supported:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="ID3D12Heap" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Resource" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Fence" />
          </description>
        </item>
      </list>
    </param>
    <param name="pAttributes">
      <para>Type: <b>const <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b></para>
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains two separate but related data members: an optional security descriptor, and a <b>Boolean</b> value that determines whether child processes can inherit the returned handle.</para>
      <para>Set this parameter to <b>NULL</b> if you want child processes that the
application might create to not  inherit  the handle returned by
<b>CreateSharedHandle</b>, and if you want the resource that is associated with the returned handle to get a default security
descriptor.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a
<see cref="SECURITY_DESCRIPTOR" /> for the resource.
Set this member to <b>NULL</b> if you want the runtime to assign a default security descriptor to the resource that is associated with the returned handle.
The ACLs in the default security descriptor for the resource come from the primary or impersonation token of the creator.
For more info, see <a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <param name="Access">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">DWORD</a></b></para>
      <para>Currently the only value this parameter accepts is GENERIC_ALL.</para>
    </param>
    <param name="Name">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A <b>NULL</b>-terminated <b>UNICODE</b> string that contains the name to associate with the shared heap.
The name is limited to MAX_PATH characters.
Name comparison is case-sensitive.</para>
      <para>If <i>Name</i> matches the name of an existing resource, <b>CreateSharedHandle</b> fails with <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/dxgi-error">DXGI_ERROR_NAME_ALREADY_EXISTS</a>.
This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace.
The remainder of the name can contain any character except the backslash character (\).
For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.
Fast user switching is implemented using Terminal Services sessions.
Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace.
For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="pHandle">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">HANDLE</a>*</b></para>
      <para>A pointer to a variable that receives the NT HANDLE value to the resource to share.
You can use this handle in calls to access the resource.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns S_OK if successful; otherwise, returns one of the following values:</para>
      <list type="bullet">
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/dxgi-error">DXGI_ERROR_INVALID_CALL</a> if one of the parameters is invalid.
</description>
        </item>
        <item>
          <description>
            <a href="https://docs.microsoft.com//windows/desktop/direct3ddxgi/dxgi-error">DXGI_ERROR_NAME_ALREADY_EXISTS</a> if the supplied name of the resource to share is already associated with another resource.
</description>
        </item>
        <item>
          <description>E_ACCESSDENIED if the object is being created in a protected namespace.</description>
        </item>
        <item>
          <description>E_OUTOFMEMORY if sufficient memory is not available to create the handle.</description>
        </item>
        <item>
          <description>Possibly other error codes that are described in the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> topic.
</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Both heaps and committed resources can be shared. Sharing a committed resource shares the implicit heap along with the committed resource description, such that a compatible resource description can be mapped to the heap from another device.</para>
      <para>For Direct3D 11 and Direct3D 12 interop scenarios, a shared fence is opened in DirectX 11 with the <see cref="ID3D11Device5.OpenSharedFence" /> method, and a shared resource is opened with the <see cref="ID3D11Device.OpenSharedResource1" /> method.</para>
      <para>For Direct3D 12, a shared handle is opened with the <see cref="ID3D12Device.OpenSharedHandle" /> or the ID3D12Device.OpenSharedHandleByName method.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.CreateUnorderedAccessView">
    <summary>
      <para>Creates a view for unordered accessing.</para>
    </summary>
    <param name="pResource">
      <para>Type: [in, optional] <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> object that represents the unordered access.</para>
      <para>At least one of <i>pResource</i> or <i>pDesc</i> must be provided.</para>
      <para>A null <i>pResource</i> is used to initialize a null descriptor, which guarantees Direct3D 11-like null binding behavior (reading 0s, writes are discarded), but must have a valid <i>pDesc</i> in order to determine the descriptor type.</para>
    </param>
    <param name="pCounterResource">
      <para>Type: [in, optional] <b><see cref="ID3D12Resource" />*</b></para>
      <para>The <see cref="ID3D12Resource" /> for the counter (if any) associated with the UAV.</para>
      <para>If <i>pCounterResource</i> is not specified, then the <b>CounterOffsetInBytes</b> member of the <see cref="D3D12_BUFFER_UAV" /> structure must be 0.</para>
      <para>If <i>pCounterResource</i> is specified, then there is a counter associated with the UAV, and the runtime performs validation of the following requirements:</para>
      <list type="bullet">
        <item>
          <description>The <b>StructureByteStride</b> member of the <see cref="D3D12_BUFFER_UAV" /> structure must be greater than 0.
</description>
        </item>
        <item>
          <description>The format must be DXGI_FORMAT_UNKNOWN.
</description>
        </item>
        <item>
          <description>The D3D12_BUFFER_UAV_FLAG_RAW flag (a <see cref="D3D12_BUFFER_UAV_FLAGS" /> enumeration constant) must not be set.
</description>
        </item>
        <item>
          <description>Both of the resources (<i>pResource</i> and <i>pCounterResource</i>) must be buffers.
</description>
        </item>
        <item>
          <description>The <b>CounterOffsetInBytes</b> member of the <see cref="D3D12_BUFFER_UAV" /> structure must be a multiple of **D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT** (4096), and must be within the range of the counter resource.
</description>
        </item>
        <item>
          <description>
            <i>pResource</i> cannot be NULL
</description>
        </item>
        <item>
          <description>
            <i>pDesc</i> cannot be NULL.
</description>
        </item>
      </list>
    </param>
    <param name="pDesc">
      <para>Type: [in, optional] <b>const <see cref="D3D12_UNORDERED_ACCESS_VIEW_DESC" />*</b></para>
      <para>A pointer to a <see cref="D3D12_UNORDERED_ACCESS_VIEW_DESC" /> structure that describes the unordered-access view.</para>
      <para>A null <i>pDesc</i> is used to initialize a default descriptor, if possible. This behavior is identical to the D3D11 null descriptor behavior, where defaults are filled in. This behavior inherits the resource format and dimension (if not typeless) and for buffers UAVs target a full buffer and are typed, and for textures UAVs target the first mip and all array slices. Not all resources support null descriptor initialization.</para>
    </param>
    <param name="DestDescriptor">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the start of the heap that holds the unordered-access view.</para>
    </param>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.Evict">
    <summary>
      <para>Enables the page-out of data, which precludes GPU access of that data.</para>
    </summary>
    <param name="NumObjects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of objects in the <i>ppObjects</i> array to evict from the device.</para>
    </param>
    <param name="ppObjects">
      <para>Type: <b><see cref="ID3D12Pageable" />*</b></para>
      <para>A pointer to a memory block that contains an array of <see cref="ID3D12Pageable" /> interface pointers for the objects.</para>
      <para>Even though most D3D12 objects inherit from <see cref="ID3D12Pageable" />, residency changes are only supported on the following objects:
Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <remarks>
      <para>
        <b>Evict</b> persists the data associated with a resource to disk, and then removes the resource from the memory pool where it was located. This method should be called on the object which owns the physical memory: either a committed resource (which owns both virtual  and physical memory assignments) or a heap - noting that reserved resources do not have physical memory, and placed resources are borrowing memory from a heap.</para>
      <para>Refer to the remarks for <see cref="MakeResident" />.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetAdapterLuid">
    <summary>
      <para>Gets a locally unique identifier for the current device (adapter).</para>
    </summary>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">LUID</a></b></para>
      <para>The locally unique identifier for the adapter.</para>
    </returns>
    <remarks>
      <para>This method returns a unique identifier for the adapter that is specific to the adapter hardware.
Applications can use this identifier to define robust mappings across various APIs (Direct3D 12, DXGI).</para>
      <para>A locally unique identifier (LUID) is a 64-bit value that is guaranteed to be unique only on the system on which it was generated.
The uniqueness of a locally unique identifier (LUID) is guaranteed only until the system is restarted.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetCopyableFootprints">
    <summary>
      <para>Gets a resource layout that can be copied.
Helps the app fill-in
<see cref="D3D12_PLACED_SUBRESOURCE_FOOTPRINT" /> and
<see cref="D3D12_SUBRESOURCE_FOOTPRINT" /> when suballocating space in upload heaps.</para>
    </summary>
    <param name="pResourceDesc">
      <para>Type: <b>const <see cref="D3D12_RESOURCE_DESC" />*</b></para>
      <para>A description of the resource, as a pointer to a <see cref="D3D12_RESOURCE_DESC" /> structure.</para>
    </param>
    <param name="FirstSubresource">
      <para>Type: <b>UINT</b></para>
      <para>Index of the first subresource in the resource.
The range of valid values is 0 to D3D12_REQ_SUBRESOURCES.</para>
    </param>
    <param name="NumSubresources">
      <para>Type: <b>UINT</b></para>
      <para>The number of subresources in the resource.  The range of valid values is 0 to (D3D12_REQ_SUBRESOURCES - <i>FirstSubresource</i>).</para>
    </param>
    <param name="BaseOffset">
      <para>Type: <b>UINT64</b></para>
      <para>The offset, in bytes, to the resource.</para>
    </param>
    <param name="pLayouts">
      <para>Type: <b><see cref="D3D12_PLACED_SUBRESOURCE_FOOTPRINT" />*</b></para>
      <para>A pointer to an array (of length <i>NumSubresources</i>) of
<see cref="D3D12_PLACED_SUBRESOURCE_FOOTPRINT" /> structures, to be filled with the description and placement of each subresource.</para>
    </param>
    <param name="pNumRows">
      <para>Type: <b>UINT*</b></para>
      <para>A pointer to an array (of length <i>NumSubresources</i>) of integer  variables, to be filled with the number of rows for each subresource.</para>
    </param>
    <param name="pRowSizeInBytes">
      <para>Type: <b>UINT64*</b></para>
      <para>A pointer to an array (of length <i>NumSubresources</i>) of integer variables, each entry to be filled with the unpadded size in bytes of a row, of each subresource.</para>
      <para>For example, if a Texture2D resource has a width of 32 and bytes per pixel of 4,</para>
      <para>then <i>pRowSizeInBytes</i> returns 128.</para>
      <para>
        <i>pRowSizeInBytes</i> should not be confused with <b>row pitch</b>, as examining <i>pLayouts</i> and getting the row pitch from that will give you 256 as it is aligned to D3D12_TEXTURE_DATA_PITCH_ALIGNMENT.</para>
    </param>
    <param name="pTotalBytes">
      <para>Type: <b>UINT64*</b></para>
      <para>A pointer to an integer variable, to be filled with the total size, in bytes.</para>
    </param>
    <remarks>
      <para>This routine assists the application in filling out
<see cref="D3D12_PLACED_SUBRESOURCE_FOOTPRINT" /> and
<see cref="D3D12_SUBRESOURCE_FOOTPRINT" /> structures, when suballocating space in upload heaps.
The resulting structures are GPU adapter-agnostic, meaning that the values will not vary from one GPU adapter to the next.
<b>GetCopyableFootprints</b> uses specified details about resource formats, texture layouts, and alignment requirements (from the <see cref="D3D12_RESOURCE_DESC" /> structure)  to fill out the subresource structures.
Applications have access to all these details, so this method, or a variation of it, could be  written as part of the app.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Multithreading</a> sample uses <b>ID3D12Device.GetCopyableFootprints</b> as follows:</para>
      <code>// Returns required size of a buffer to be used for data upload
inline UINT64 GetRequiredIntermediateSize(
    _In_ ID3D12Resource* pDestinationResource,
    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources)
{
    D3D12_RESOURCE_DESC Desc = pDestinationResource-&gt;GetDesc();
    UINT64 RequiredSize = 0;

    ID3D12Device* pDevice;
    pDestinationResource-&gt;GetDevice(__uuidof(*pDevice), reinterpret_cast&lt;void**&gt;(&amp;amp;amp;amp;amp;amp;pDevice));
    pDevice-&gt;GetCopyableFootprints(&amp;amp;amp;amp;amp;amp;Desc, FirstSubresource, NumSubresources, 0, nullptr, nullptr, nullptr, &amp;amp;amp;amp;amp;amp;RequiredSize);
    pDevice-&gt;Release();

    return RequiredSize;
}

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/cd3dx12-resource-desc">CD3DX12_RESOURCE_DESC</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/cd3dx12-subresource-footprint">CD3DX12_SUBRESOURCE_FOOTPRINT</seealso>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetCustomHeapProperties">
    <summary>
      <para>Divulges the equivalent custom heap properties that are used for non-custom heap types, based on the adapter's architectural properties.</para>
    </summary>
    <param name="nodeMask">
      <para>Type: <b>UINT</b></para>
      <para>For single-GPU operation, set this to zero.
If there are multiple GPU nodes, set a bit to identify the node (the  device's physical adapter).
Each bit in the mask corresponds to a single node.
Only 1 bit must be set.
See <a href="https://docs.microsoft.com//windows/win32/direct3d12/multi-engine">Multi-adapter systems</a>.</para>
    </param>
    <param name="heapType">
      <para>Type: <b><see cref="D3D12_HEAP_TYPE" /></b></para>
      <para>A <see cref="D3D12_HEAP_TYPE" />-typed value that specifies the heap to get properties for.
D3D12_HEAP_TYPE_CUSTOM is not supported as a parameter value.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="D3D12_HEAP_PROPERTIES" /></b></para>
      <para>Returns a <see cref="D3D12_HEAP_PROPERTIES" /> structure that provides properties for the specified heap.
The <b>Type</b> member of the returned D3D12_HEAP_PROPERTIES is always D3D12_HEAP_TYPE_CUSTOM.</para>
      <para>When <see cref="D3D12_FEATURE_DATA_ARCHITECTURE" />.UMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
      <list type="table">
        <listheader>
          <description>Heap Type</description>
          <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
        </listheader>
        <item>
          <description>D3D12_HEAP_TYPE_UPLOAD</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_DEFAULT</description>
          <description>
            <b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L1.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_READBACK</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
      </list>
      <para>When D3D12_FEATURE_DATA_ARCHITECTURE.UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE.CacheCoherentUMA is FALSE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
      <list type="table">
        <listheader>
          <description>Heap Type</description>
          <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
        </listheader>
        <item>
          <description>D3D12_HEAP_TYPE_UPLOAD</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_COMBINE, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_DEFAULT</description>
          <description>
            <b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_READBACK</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
      </list>
      <para>When D3D12_FEATURE_DATA_ARCHITECTURE.UMA is TRUE and D3D12_FEATURE_DATA_ARCHITECTURE.CacheCoherentUMA is TRUE, the returned D3D12_HEAP_PROPERTIES members convert as follows:</para>
      <list type="table">
        <listheader>
          <description>Heap Type</description>
          <description>How the returned D3D12_HEAP_PROPERTIES members convert</description>
        </listheader>
        <item>
          <description>D3D12_HEAP_TYPE_UPLOAD</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_DEFAULT</description>
          <description>
            <b>CPUPageProperty</b> = NOT_AVAILABLE, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
        <item>
          <description>D3D12_HEAP_TYPE_READBACK</description>
          <description>
            <b>CPUPageProperty</b> = WRITE_BACK, <b>MemoryPoolPreference</b> = L0.
</description>
        </item>
      </list>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetDescriptorHandleIncrementSize">
    <summary>
      <para>Gets the size of the handle increment for the given type of descriptor heap. This value is typically used to increment a handle into a descriptor array by the correct amount.</para>
    </summary>
    <param name="DescriptorHeapType">
      <para>The <see cref="D3D12_DESCRIPTOR_HEAP_TYPE" />-typed value that specifies the type of descriptor heap to get the size of the handle increment for.</para>
    </param>
    <returns>
      <para>Returns the size of the handle increment for the given type of descriptor heap, including any necessary padding.</para>
    </returns>
    <remarks>
      <para>The descriptor size returned by this method is used as one input to the helper structures <a href="https://docs.microsoft.com//windows/desktop/direct3d12/cd3dx12-cpu-descriptor-handle">CD3DX12_CPU_DESCRIPTOR_HANDLE</a> and <a href="https://docs.microsoft.com//windows/desktop/direct3d12/cd3dx12-gpu-descriptor-handle">CD3DX12_GPU_DESCRIPTOR_HANDLE</a>.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12PredicationQueries</a> sample uses <b>ID3D12Device.GetDescriptorHandleIncrementSize</b> as follows:</para>
      <para>Create the descriptor heap for the resources. The <code>m_rtvDescriptorSize</code> variable stores the render target view descriptor handle increment size, and is used in the <b>Create frame resources</b> section of the code.</para>
      <code>// Create descriptor heaps.
{
    // Describe and create a render target view (RTV) descriptor heap.
    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
    rtvHeapDesc.NumDescriptors = FrameCount;
    rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
    ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;amp;amp;amp;amp;amp;rtvHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_rtvHeap)));

    // Describe and create a depth stencil view (DSV) descriptor heap.
    D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc = {};
    dsvHeapDesc.NumDescriptors = 1;
    dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
    dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
    ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;amp;amp;amp;amp;amp;dsvHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_dsvHeap)));

    // Describe and create a constant buffer view (CBV) descriptor heap.
    D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc = {};
    cbvHeapDesc.NumDescriptors = CbvCountPerFrame * FrameCount;
    cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
    ThrowIfFailed(m_device-&gt;CreateDescriptorHeap(&amp;amp;amp;amp;amp;amp;cbvHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_cbvHeap)));

    // Describe and create a heap for occlusion queries.
    D3D12_QUERY_HEAP_DESC queryHeapDesc = {};
    queryHeapDesc.Count = 1;
    queryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_OCCLUSION;
    ThrowIfFailed(m_device-&gt;CreateQueryHeap(&amp;amp;amp;amp;amp;amp;queryHeapDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_queryHeap)));

    m_rtvDescriptorSize = m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
    m_cbvSrvDescriptorSize = m_device-&gt;GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}

// Create frame resources.
{
    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart());

    // Create a RTV and a command allocator for each frame.
    for (UINT n = 0; n &lt; FrameCount; n++)
    {
        ThrowIfFailed(m_swapChain-&gt;GetBuffer(n, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_renderTargets[n])));
        m_device-&gt;CreateRenderTargetView(m_renderTargets[n].Get(), nullptr, rtvHandle);
        rtvHandle.Offset(1, m_rtvDescriptorSize);

        ThrowIfFailed(m_device-&gt;CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_commandAllocators[n])));
    }
}

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetDeviceRemovedReason">
    <summary>
      <para>Gets the reason that the device was removed.</para>
    </summary>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns the reason that the device was removed.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetNodeCount">
    <summary>
      <para>Reports the number of physical adapters (nodes) that are associated with this device.</para>
    </summary>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of physical adapters (nodes) that this device has.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetResourceAllocationInfo">
    <summary>
      <para>Gets the size and alignment of memory required for a collection of resources on this adapter.</para>
    </summary>
    <param name="visibleMask">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT</a></b></para>
      <para>For single-GPU operation, set this to zero. If there are multiple GPU nodes, then set bits to identify the nodes (the device's physical adapters). Each bit in the mask corresponds to a single node. Also see <a href="https://docs.microsoft.com//windows/win32/direct3d12/multi-engine">Multi-adapter systems</a>.</para>
    </param>
    <param name="numResourceDescs">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of resource descriptors in the <i>pResourceDescs</i> array.</para>
    </param>
    <param name="pResourceDescs">
      <para>Type: <b>const <see cref="D3D12_RESOURCE_DESC" />*</b></para>
      <para>An array of <b>D3D12_RESOURCE_DESC</b> structures that described the resources to get info about.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="D3D12_RESOURCE_ALLOCATION_INFO" /></b></para>
      <para>A <see cref="D3D12_RESOURCE_ALLOCATION_INFO" /> structure that provides info about video memory allocated for the specified array of resources.</para>
      <para>If an error occurs, then <b>D3D12_RESOURCE_ALLOCATION_INFO.SizeInBytes</b> equals <b>UINT64_MAX</b>.</para>
    </returns>
    <remarks>
      <para>When you're using <see cref="CreatePlacedResource" />, your application must use <b>GetResourceAllocationInfo</b> in order to understand the size and alignment characteristics of texture resources. The results of this method vary depending on the particular adapter, and must be treated as unique to this adapter and driver version.</para>
      <para>Your application can't use the output of <b>GetResourceAllocationInfo</b> to understand packed mip properties of textures. To understand packed mip properties of textures, your application must use <see cref="GetResourceTiling" />.</para>
      <para>Texture resource sizes significantly differ from the information returned by <b>GetResourceTiling</b>, because some adapter architectures allocate extra memory for textures to reduce the effective bandwidth during common rendering scenarios. This even includes textures that have constraints on their texture layouts, or have standardized texture layouts. That extra memory can't be sparsely mapped nor remapped by an application using <see cref="CreateReservedResource" /> and <see cref="UpdateTileMappings" />, so it isn't reported by <b>GetResourceTiling</b>.</para>
      <para>Your application can forgo using <b>GetResourceAllocationInfo</b> for buffer resources (<see cref="D3D12_RESOURCE_DIMENSION_BUFFER" />). Buffers have the same size on all adapters, which is merely the smallest multiple of 64KB that's greater or equal to <see cref="D3D12_RESOURCE_DESC.Width" />.</para>
      <para>When multiple resource descriptions are passed in, the C++ algorithm for calculating a structure size and alignment are used. For example, a three-element array with two tiny 64KB-aligned resources and a tiny 4MB-aligned resource, reports differing sizes based on the order of the array. If the 4MB aligned resource is in the middle, then the resulting <b>Size</b> is 12MB. Otherwise, the resulting <b>Size</b> is 8MB. The <b>Alignment</b> returned would always be 4MB, because it's the superset of all alignments in the resource array.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.GetResourceTiling">
    <summary>
      <para>Gets info about how a tiled resource is broken into tiles.</para>
    </summary>
    <param name="pTiledResource">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies a tiled <see cref="ID3D12Resource" />  to get info about.</para>
    </param>
    <param name="pNumTilesForEntireResource">
      <para>Type: <b>UINT*</b></para>
      <para>A pointer to a variable that receives the number of tiles needed to store the entire tiled resource.</para>
    </param>
    <param name="pPackedMipDesc">
      <para>Type: <b><see cref="D3D12_PACKED_MIP_INFO" />*</b></para>
      <para>A pointer to a <see cref="D3D12_PACKED_MIP_INFO" /> structure that <b>GetResourceTiling</b> fills with info about how the tiled resource's mipmaps are packed.</para>
    </param>
    <param name="pStandardTileShapeForNonPackedMips">
      <para>Type: <b><see cref="D3D12_TILE_SHAPE" />*</b></para>
      <para>Specifies a <see cref="D3D12_TILE_SHAPE" /> structure that <b>GetResourceTiling</b> fills with info about the tile shape. This is info about how pixels fit in the tiles, independent of tiled resource's dimensions, not including packed mipmaps. If the entire tiled resource is packed, this parameter is meaningless because the tiled resource has no defined layout for packed mipmaps. In this situation, <b>GetResourceTiling</b> sets the members of D3D12_TILE_SHAPE to zeros.</para>
    </param>
    <param name="pNumSubresourceTilings">
      <para>Type: <b>UINT*</b></para>
      <para>A pointer to a variable that contains the number of tiles in the subresource. On input, this is the number of subresources to query tilings for; on output, this is the number that was actually retrieved at <i>pSubresourceTilingsForNonPackedMips</i> (clamped to what's available).</para>
    </param>
    <param name="FirstSubresourceTilingToGet">
      <para>Type: <b>UINT</b></para>
      <para>The number of the first subresource tile to get. <b>GetResourceTiling</b> ignores this parameter if the number that <i>pNumSubresourceTilings</i> points to is 0.</para>
    </param>
    <param name="pSubresourceTilingsForNonPackedMips">
      <para>Type: <b><see cref="D3D12_SUBRESOURCE_TILING" />*</b></para>
      <para>Specifies a <see cref="D3D12_SUBRESOURCE_TILING" /> structure that <b>GetResourceTiling</b> fills with info about subresource tiles. If subresource tiles are part of packed mipmaps, <b>GetResourceTiling</b> sets the members of D3D12_SUBRESOURCE_TILING to zeros, except the <i>StartTileIndexInOverallResource</i> member, which <b>GetResourceTiling</b> sets to D3D12_PACKED_TILE (0xffffffff). The D3D12_PACKED_TILE constant indicates that the whole <b>D3D12_SUBRESOURCE_TILING</b> structure is meaningless for this situation, and the info that the <i>pPackedMipDesc</i> parameter points to applies.</para>
    </param>
    <remarks>
      <para>To estimate the total resource size of textures needed when calculating heap sizes and calling <see cref="CreatePlacedResource" />, use <see cref="GetResourceAllocationInfo" /> instead of <b>GetResourceTiling</b>.
<b>GetResourceTiling</b> cannot be used for this.</para>
      <para>For more information on tiled resources, refer to <a href="https://docs.microsoft.com//windows/desktop/direct3d12/volume-tiled-resources">Volume Tiled Resources</a>.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/subresources">Subresources</seealso>
  </member>
  <member name="ID3D12Device.MakeResident">
    <summary>
      <para>Makes objects resident for the device.</para>
    </summary>
    <param name="NumObjects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of objects  in the <i>ppObjects</i> array to make resident for the device.</para>
    </param>
    <param name="ppObjects">
      <para>Type: <b><see cref="ID3D12Pageable" />*</b></para>
      <para>A pointer to a memory block that contains an array of <see cref="ID3D12Pageable" /> interface pointers for the objects.</para>
      <para>Even though most D3D12 objects inherit from <see cref="ID3D12Pageable" />, residency changes are only supported on the following objects:
Descriptor Heaps, Heaps, Committed Resources, and Query Heaps</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <remarks>
      <para>
        <b>MakeResident</b> loads the data associated with a resource from disk, and re-allocates the memory from the resource's appropriate memory pool. This method should be called on the object which owns the physical memory.</para>
      <para>Use this method, and <see cref="Evict" />, to manage GPU video memory, noting that this was done automatically in D3D11, but now has to be done by the app in D3D12.</para>
      <para>
        <b>MakeResident</b> and <see cref="Evict" /> can help applications manage the residency budget on many adapters. <b>MakeResident</b> explicitly pages-in data and, then, precludes page-out so the GPU can access the data. <b>Evict</b> enables page-out.</para>
      <para>Some GPU architectures do not benefit from residency manipulation, due to the lack of sufficient GPU virtual address space. Use <see cref="D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT" /> and <see cref="IDXGIAdapter3.QueryVideoMemoryInfo" /> to recognize when the maximum GPU VA space per-process is too small or roughly the same size as the residency budget. For such architectures, the residency budget will always be constrained by the amount of GPU virtual address space. <see cref="Evict" /> will not free-up any residency budget on such systems.</para>
      <para>Applications must handle <b>MakeResident</b> failures, even if there appears to be enough residency budget available. Physical memory fragmentation and adapter architecture quirks can preclude the utilization of large contiguous ranges. Applications should free up more residency budget before trying again.</para>
      <para>
        <b>MakeResident</b> is ref-counted, such that <see cref="Evict" /> must be called the same amount of times as <b>MakeResident</b> before <b>Evict</b> takes effect. Objects that support residency are made resident during creation, so a single <b>Evict</b> call will actually evict the object.</para>
      <para>Applications must use fences to ensure the GPU doesn't use non-resident objects. <b>MakeResident</b> must return before the GPU executes a command list that references the object. <see cref="Evict" /> must be called after the GPU finishes executing a command list that references the object.</para>
      <para>Evicted objects still consume the same GPU virtual address and same amount of GPU virtual address space. Therefore, resource descriptors and other GPU virtual address references are not invalidated after <see cref="Evict" />.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.OpenSharedHandle">
    <summary>
      <para>Opens a handle for shared resources, shared heaps, and shared fences, by using HANDLE and REFIID.</para>
    </summary>
    <param name="NTHandle">
      <para>Type: <b>HANDLE</b></para>
      <para>The handle that was output by the call to
<see cref="ID3D12Device.CreateSharedHandle" />.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The globally unique identifier (<b>GUID</b>) for one of the following interfaces:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="ID3D12Heap" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Resource" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Fence" />
          </description>
        </item>
      </list>
      <para>The <b>REFIID</b>, or <b>GUID</b>, of the interface can be obtained by using the __uuidof() macro.
For example, __uuidof(ID3D12Heap) will get the <b>GUID</b> of the interface to a resource.</para>
    </param>
    <param name="ppvObj">
      <para>Type: <b>void**</b></para>
      <para>A pointer to a memory block that receives a pointer to one of the following interfaces:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="ID3D12Heap" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Resource" />
          </description>
        </item>
        <item>
          <description>
            <see cref="ID3D12Fence" />
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <seealso cref="ID3D12Device" />
    <seealso href="https://docs.microsoft.com//windows/win32/direct3d12/multi-engine">Multi-adapter systems</seealso>
  </member>
  <member name="ID3D12Device.OpenSharedHandleByName">
    <summary>
      <para>Opens a handle for shared resources, shared heaps, and shared fences, by using Name and Access.</para>
    </summary>
    <param name="Name">
      <para>Type: <b>LPCWSTR</b></para>
      <para>The name that was optionally passed as the <i>Name</i> parameter in the call to
<see cref="ID3D12Device.CreateSharedHandle" />.</para>
    </param>
    <param name="Access">
      <para>Type: <b>DWORD</b></para>
      <para>The access level that was specified in the <i>Access</i> parameter in the call to
<see cref="ID3D12Device.CreateSharedHandle" />.</para>
    </param>
    <param name="pNTHandle">
      <para>Type: <b>HANDLE*</b></para>
      <para>Pointer to the shared handle.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device.SetStablePowerState">
    <summary>
      <para>A development-time aid for certain types of profiling and experimental prototyping.</para>
    </summary>
    <param name="Enable">
      <para>Type: <b>BOOL</b></para>
      <para>Specifies a BOOL that turns the stable power state on or off.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>This method returns one of the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a>.</para>
    </returns>
    <remarks>
      <para>This method is only useful during the development of applications. It enables developers to profile GPU usage of multiple algorithms without experiencing artifacts from <a href="https://en.wikipedia.org/wiki/dynamic_frequency_scaling">dynamic frequency scaling</a>.</para>
      <para>Do not call this method in normal execution for a shipped application. This method only works while the machine is in <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">developer mode</a>. If developer mode is not enabled, then device removal will occur. Instead, call this method in response to an off-by-default, developer-facing switch. Calling it in response to command line parameters, config files, registry keys, and developer console commands are reasonable usage scenarios.</para>
      <para>A stable power state typically fixes GPU clock rates at a slower setting that is significantly lower than that experienced by users under normal application load. This reduction in clock rate affects the entire system. Slow clock rates are required to ensure processors don’t exhaust power, current, and thermal limits. Normal usage scenarios commonly leverage a processors ability to dynamically over-clock. Any conclusions made by comparing two designs under a stable power state should be double-checked with supporting results from real usage scenarios.</para>
    </remarks>
    <seealso cref="ID3D12Device" />
  </member>
  <member name="ID3D12Device">
    <summary>
      <para>Represents a virtual adapter; it is used to create command allocators, command lists, command queues, fences, resources, pipeline state objects, heaps, root signatures, samplers, and many resource views.
<b>Note</b>  This interface was introduced in Windows 10. Applications targetting Windows 10 should use this interface instead of later versions. Applications targetting a later version of Windows 10 should use the appropriate version of the <b>ID3D12Device</b> interface. The latest version of this interface is <see cref="ID3D12Device3" /> introduced in Windows 10 Fall Creators Update.</para>
    </summary>
    <remarks>
      <para>Use <see cref="D3D12CreateDevice" /> to create a device.</para>
      <para>For Windows 10 Anniversary some additional functionality is available through <see cref="ID3D12Device1" />.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D1211on12</a> sample uses <b>ID3D12Device</b> as follows:</para>
      <para>Header file declarations.</para>
      <code>// Pipeline objects.
D3D12_VIEWPORT m_viewport;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12Resource&gt; m_depthStencil;
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature &gt;m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvSrvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_samplerHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState1;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState2;
D3D12_RECT m_scissorRect;

</code>
      <para>Checking supported features.</para>
      <code>inline UINT8 D3D12GetFormatPlaneCount(
    _In_ ID3D12Device* pDevice,
    DXGI_FORMAT Format
    )
{
    D3D12_FEATURE_DATA_FORMAT_INFO formatInfo = {Format};
    if (FAILED(pDevice-&gt;CheckFeatureSupport(D3D12_FEATURE_FORMAT_INFO, &amp;amp;amp;amp;amp;amp;formatInfo, sizeof(formatInfo))))
    {
        return 0;
    }
    return formatInfo.PlaneCount;
}

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/direct3d-12-interfaces">Core Interfaces</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/creating-descriptors">Creating Descriptors</seealso>
    <seealso cref="ID3D12Device1" />
    <seealso cref="ID3D12Device2" />
    <seealso cref="ID3D12Object" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/memory-management">Memory Management in Direct3D 12</seealso>
  </member>
</doc>