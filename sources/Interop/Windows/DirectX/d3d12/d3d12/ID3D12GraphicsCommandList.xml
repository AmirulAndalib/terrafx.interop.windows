<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="ID3D12GraphicsCommandList.BeginEvent">
    <summary>
      <para>Not intended to be called directly.  Use the
<a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">PIX event runtime</a> to insert events into a command list.</para>
    </summary>
    <param name="Metadata">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Internal.</para>
    </param>
    <param name="pData">
      <para>Type: <b>const <a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">void</a>*</b></para>
      <para>Internal.</para>
    </param>
    <param name="Size">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Internal.</para>
    </param>
    <remarks>
      <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
      <para>To mark the start of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXBeginEvent</b> function or <b>PIXScopedEvent</b> macro.  These are provided by the <a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.BeginQuery">
    <summary>
      <para>Starts a query running.</para>
    </summary>
    <param name="pQueryHeap">
      <para>Type: <b><see cref="ID3D12QueryHeap" />*</b></para>
      <para>Specifies the <see cref="ID3D12QueryHeap" /> containing the query.</para>
    </param>
    <param name="Type">
      <para>Type: <b><see cref="D3D12_QUERY_TYPE" /></b></para>
      <para>Specifies one member of <see cref="D3D12_QUERY_TYPE" />.</para>
    </param>
    <param name="Index">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the index of the query within the query heap.</para>
    </param>
    <remarks>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/queries">Queries</a> for more information about D3D12 queries.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12PredicationQueries</a> sample uses
<b>ID3D12GraphicsCommandList.BeginQuery</b> as follows:</para>
      <code>// Fill the command list with all the render commands and dependent state.
void D3D12PredicationQueries.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    // Draw the quads and perform the occlusion query.
    {
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);

        m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
        m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);

        // Draw the far quad conditionally based on the result of the occlusion query
        // from the previous frame.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPredication(m_queryResult.Get(), 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;DrawInstanced(4, 1, 0, 0);

        // Disable predication and always draw the near quad.
        m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad);
        m_commandList-&gt;DrawInstanced(4, 1, 4, 0);

        // Run the occlusion query with the bounding box quad.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPipelineState(m_queryState.Get());
        m_commandList-&gt;BeginQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);
        m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
        m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);

        // Resolve the occlusion query and store the results in the query result buffer
        // to be used on the subsequent frame.
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION, D3D12_RESOURCE_STATE_COPY_DEST));
        m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1, m_queryResult.Get(), 0);
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION));
    }

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ClearDepthStencilView">
    <summary>
      <para>Clears the depth-stencil resource.</para>
    </summary>
    <param name="DepthStencilView">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Describes the CPU descriptor handle that represents the start of the heap for the depth stencil to be cleared.</para>
    </param>
    <param name="ClearFlags">
      <para>Type: <b><see cref="D3D12_CLEAR_FLAGS" /></b></para>
      <para>A combination of <see cref="D3D12_CLEAR_FLAGS" /> values that are combined by using a bitwise OR operation. The resulting value identifies the type of data to clear (depth buffer, stencil buffer, or both).</para>
    </param>
    <param name="Depth">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">FLOAT</a></b></para>
      <para>A value to clear the depth buffer with. This value will be clamped between 0 and 1.</para>
    </param>
    <param name="Stencil">
      <para>Type: <b>UINT8</b></para>
      <para>A value to clear the stencil buffer with.</para>
    </param>
    <param name="NumRects">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
    </param>
    <param name="pRects">
      <para>Type: <b>const <b>D3D12_RECT</b>*</b></para>
      <para>An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearDepthStencilView</b> clears the entire resource view.</para>
    </param>
    <remarks>
      <para>
        <b>ClearDepthStencilView</b> may be used to initialize resources which alias the same heap memory. See <see cref="CreatePlacedResource" /> for more details.</para>
      <h3>Runtime validation</h3>
      <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
      <para>Validation failure will result in the call to <see cref="Close" /> returning <b>E_INVALIDARG</b>.</para>
      <h3>Debug layer</h3>
      <para>The debug layer will issue errors if the input colors are denormalized.</para>
      <para>The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state.
For <b>ClearDepthStencilView</b>, the state must be in the state <see cref="D3D12_RESOURCE_STATE_DEPTH_WRITE" />.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Bundles</a> sample uses <b>ID3D12GraphicsCommandList.ClearDepthStencilView</b> as follows:</para>
      <code>// Pipeline objects.
D3D12_VIEWPORT m_viewport;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12Resource&gt; m_depthStencil;
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature &gt;m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_cbvSrvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_dsvHeap;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_samplerHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState1;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState2;
D3D12_RECT m_scissorRect;

</code>
      <code>void D3D12Bundles.PopulateCommandList(FrameResource* pFrameResource)
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_pCurrentFrameResource-&gt;m_commandAllocator.Get(), m_pipelineState1.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvHeap.Get(), m_samplerHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    if (UseBundles)
    {
        // Execute the prebuilt bundle.
        m_commandList-&gt;ExecuteBundle(pFrameResource-&gt;m_bundle.Get());
    }
    else
    {
        // Populate a new command list.
        pFrameResource-&gt;PopulateCommandList(m_commandList.Get(), m_pipelineState1.Get(), m_pipelineState2.Get(), m_currentFrameResourceIndex, m_numIndices, &amp;amp;amp;amp;amp;amp;m_indexBufferView,
            &amp;amp;amp;amp;amp;amp;m_vertexBufferView, m_cbvSrvHeap.Get(), m_cbvSrvDescriptorSize, m_samplerHeap.Get(), m_rootSignature.Get());
    }

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Multithreading</a> sample uses <b>ID3D12GraphicsCommandList.ClearDepthStencilView</b> as follows:</para>
      <code>void FrameResource.Init()
{
    // Reset the command allocators and lists for the main thread.
    for (int i = 0; i &lt; CommandListCount; i++)
    {
        ThrowIfFailed(m_commandAllocators[i]-&gt;Reset());
        ThrowIfFailed(m_commandLists[i]-&gt;Reset(m_commandAllocators[i].Get(), m_pipelineState.Get()));
    }

    // Clear the depth stencil buffer in preparation for rendering the shadow map.
    m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_shadowDepthView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    // Reset the worker command allocators and lists.
    for (int i = 0; i &lt; NumContexts; i++)
    {
        ThrowIfFailed(m_shadowCommandAllocators[i]-&gt;Reset());
        ThrowIfFailed(m_shadowCommandLists[i]-&gt;Reset(m_shadowCommandAllocators[i].Get(), m_pipelineStateShadowMap.Get()));

        ThrowIfFailed(m_sceneCommandAllocators[i]-&gt;Reset());
        ThrowIfFailed(m_sceneCommandLists[i]-&gt;Reset(m_sceneCommandAllocators[i].Get(), m_pipelineState.Get()));
    }
}

</code>
      <code>// Assemble the CommandListPre command list.
void D3D12Multithreading.BeginFrame()
{
    m_pCurrentFrameResource-&gt;Init();

    // Indicate that the back buffer will be used as a render target.
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    // Clear the render target and depth stencil.
    const float clearColor[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;Close());
}

// Assemble the CommandListMid command list.
void D3D12Multithreading.MidFrame()
{
    // Transition our shadow map from the shadow pass to readable in the scene pass.
    m_pCurrentFrameResource-&gt;SwapBarriers();

    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ClearRenderTargetView">
    <summary>
      <para>Sets all the elements in a render target to one value.</para>
    </summary>
    <param name="RenderTargetView">
      <para>Type: <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>Specifies a D3D12_CPU_DESCRIPTOR_HANDLE structure that describes the CPU descriptor handle that represents the start of the heap for the render target to be cleared.</para>
    </param>
    <param name="ColorRGBA">
      <para>Type: <b>const FLOAT[4]</b></para>
      <para>A 4-component array that represents the color to fill the render target with.</para>
    </param>
    <param name="NumRects">
      <para>Type: <b>UINT</b></para>
      <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
    </param>
    <param name="pRects">
      <para>Type: <b>const D3D12_RECT*</b></para>
      <para>An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearRenderTargetView</b> clears the entire resource view.</para>
    </param>
    <remarks>
      <para>
        <b>ClearRenderTargetView</b> may be used to initialize resources which alias the same heap memory. See <see cref="CreatePlacedResource" /> for more details.</para>
      <h3>Runtime validation</h3>
      <para>For floating-point inputs, the runtime will set denormalized values to 0 (while preserving NANs).</para>
      <para>Validation failure will result in the call to <see cref="Close" /> returning <b>E_INVALIDARG</b>.</para>
      <h3>Debug layer</h3>
      <para>The debug layer will issue errors if the input colors are denormalized.</para>
      <para>The debug layer will issue an error if the subresources referenced by the view are not in the appropriate state.
For <b>ClearRenderTargetView</b>, the state must be <see cref="D3D12_RESOURCE_STATE_RENDER_TARGET" />.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.ClearRenderTargetView</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Multithreading</a> sample uses <b>ID3D12GraphicsCommandList.ClearRenderTargetView</b> as follows:</para>
      <code>// Frame resources.
FrameResource* m_frameResources[FrameCount];
FrameResource* m_pCurrentFrameResource;
int m_currentFrameResourceIndex;

</code>
      <code>// Assemble the CommandListPre command list.
void D3D12Multithreading.BeginFrame()
{
    m_pCurrentFrameResource-&gt;Init();

    // Indicate that the back buffer will be used as a render target.
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    // Clear the render target and depth stencil.
    const float clearColor[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListPre]-&gt;Close());
}

// Assemble the CommandListMid command list.
void D3D12Multithreading.MidFrame()
{
    // Transition our shadow map from the shadow pass to readable in the scene pass.
    m_pCurrentFrameResource-&gt;SwapBarriers();

    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandLists[CommandListMid]-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ClearState">
    <summary>
      <para>Resets the state of a direct command list back to the state it was in when the command list was created.</para>
    </summary>
    <param name="pPipelineState">
      <para>Type: <b><see cref="ID3D12PipelineState" />*</b></para>
      <para>A pointer to the <see cref="ID3D12PipelineState" /> object that contains the initial pipeline state for the command list.</para>
    </param>
    <remarks>
      <para>It is invalid to call <b>ClearState</b> on a bundle.  If an app calls <b>ClearState</b> on a bundle, the call to <see cref="Close" /> will return <b>E_FAIL</b>.</para>
      <para>When <b>ClearState</b> is called, all currently bound resources are unbound.  The primitive topology is set to <see cref="D3D_PRIMITIVE_TOPOLOGY_UNDEFINED" />.  Viewports, scissor rectangles, stencil reference value, and the blend factor are set to empty values (all zeros).  Predication is disabled.</para>
      <para>The app-provided pipeline state object becomes bound as the currently set pipeline state object.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ClearUnorderedAccessViewFloat">
    <summary>
      <para>Sets all of the elements in an unordered-access view (UAV) to the specified float values.</para>
    </summary>
    <param name="ViewGPUHandleInCurrentHeap">
      <para>Type: [in] <b><see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /> that references an initialized descriptor for the unordered-access view (UAV) that is to be cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <see cref="SetDescriptorHeaps" />.</para>
    </param>
    <param name="ViewCPUHandle">
      <para>Type: [in] <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /> in a non-shader visible descriptor heap that references an initialized descriptor for the unordered-access view (UAV) that is to be cleared.</para>
      <blockquote>
        <para>[!IMPORTANT]
This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type of memory are prohibitively slow.</para>
      </blockquote>
    </param>
    <param name="pResource">
      <para>Type: [in] <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> interface that represents the unordered-access-view (UAV) resource to clear.</para>
    </param>
    <param name="Values">
      <para>Type: [in] <b>const FLOAT[4]</b></para>
      <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
    </param>
    <param name="NumRects">
      <para>Type: [in] <b>UINT</b></para>
      <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
    </param>
    <param name="pRects">
      <para>Type: [in] <b>const <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-rect">D3D12_RECT</a>*</b></para>
      <para>An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearUnorderedAccessViewFloat</b> clears the entire resource view.</para>
    </param>
    <remarks>
      <h3>Runtime validation</h3>
      <para>For floating-point inputs, the runtime sets denormalized values to 0 (while preserving NANs).</para>
      <para>If you want to clear the UAV to a specific bit pattern, consider using <see cref="ID3D12GraphicsCommandList.ClearUnorderedAccessViewUint" />.</para>
      <para>Validation failure results in the call to <see cref="ID3D12GraphicsCommandList.Close" /> returning <b>E_INVALIDARG</b>.</para>
      <h3>Debug layer</h3>
      <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
      <para>The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For <b>ClearUnorderedAccessViewFloat</b>, the state must be <see cref="D3D12_RESOURCE_STATE_UNORDERED_ACCESS" />.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList interface" />
  </member>
  <member name="ID3D12GraphicsCommandList.ClearUnorderedAccessViewUint">
    <summary>
      <para>Sets all the elements in a unordered-access view (UAV) to the specified integer values.</para>
    </summary>
    <param name="ViewGPUHandleInCurrentHeap">
      <para>Type: [in] <b><see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /> that references an initialized descriptor for the unordered-access view (UAV) that is to be cleared. This descriptor must be in a shader-visible descriptor heap, which must be set on the command list via <see cref="SetDescriptorHeaps" />.</para>
    </param>
    <param name="ViewCPUHandle">
      <para>Type: [in] <b><see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /> in a non-shader visible descriptor heap that references an initialized descriptor for the unordered-access view (UAV) that is to be cleared.</para>
      <blockquote>
        <para>[!IMPORTANT]
This descriptor must not be in a shader-visible descriptor heap. This is to allow drivers that implement the clear as a fixed-function hardware operation (rather than as a dispatch) to efficiently read from the descriptor, as shader-visible heaps may be created in <b>WRITE_BACK</b> memory (similar to <b>D3D12_HEAP_TYPE_UPLOAD</b> heap types), and CPU reads from this type of memory are prohibitively slow.</para>
      </blockquote>
    </param>
    <param name="pResource">
      <para>Type: [in] <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> interface that represents the unordered-access-view (UAV) resource to clear.</para>
    </param>
    <param name="Values">
      <para>Type: [in] <b>const UINT[4]</b></para>
      <para>A 4-component array that containing the values to fill the unordered-access-view resource with.</para>
    </param>
    <param name="NumRects">
      <para>Type: [in] <b>UINT</b></para>
      <para>The number of rectangles in the array that the <i>pRects</i> parameter specifies.</para>
    </param>
    <param name="pRects">
      <para>Type: [in] <b>const <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12-rect">D3D12_RECT</a>*</b></para>
      <para>An array of <b>D3D12_RECT</b> structures for the rectangles in the resource view to clear. If <b>NULL</b>, <b>ClearUnorderedAccessViewUint</b> clears the entire resource view.</para>
    </param>
    <remarks>
      <h3>Runtime validation</h3>
      <para>Validation failure results in the call to <see cref="ID3D12GraphicsCommandList.Close" /> returning <b>E_INVALIDARG</b>.</para>
      <h3>Debug layer</h3>
      <para>The debug layer issues errors if the input values are outside of a normalized range.</para>
      <para>The debug layer issues an error if the subresources referenced by the view aren't in the appropriate state. For <b>ClearUnorderedAccessViewUint</b>, the state must be <see cref="D3D12_RESOURCE_STATE_UNORDERED_ACCESS" />.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList interface" />
  </member>
  <member name="ID3D12GraphicsCommandList.Close">
    <summary>
      <para>Indicates that recording to the command list has finished.</para>
    </summary>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command list recording.
</description>
        </item>
        <item>
          <description>
            <b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.
</description>
        </item>
        <item>
          <description>
            <b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.
</description>
        </item>
      </list>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>The runtime will validate that the command list has not previously been closed.  If an error was encountered during recording, the error code is returned here.  The runtime won't call the close device driver interface (DDI) in this case.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.Close</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.LoadAssets()
{
    // Create an empty root signature.
    {
        CD3DX12_ROOT_SIGNATURE_DESC rootSignatureDesc;
        rootSignatureDesc.Init(0, nullptr, 0, nullptr, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

        ComPtr&lt;ID3DBlob&gt; signature;
        ComPtr&lt;ID3DBlob&gt; error;
        ThrowIfFailed(D3D12SerializeRootSignature(&amp;amp;amp;amp;amp;amp;rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &amp;amp;amp;amp;amp;amp;signature, &amp;amp;amp;amp;amp;amp;error));
        ThrowIfFailed(m_device-&gt;CreateRootSignature(0, signature-&gt;GetBufferPointer(), signature-&gt;GetBufferSize(), IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_rootSignature)));
    }

    // Create the pipeline state, which includes compiling and loading shaders.
    {
        ComPtr&lt;ID3DBlob&gt; vertexShader;
        ComPtr&lt;ID3DBlob&gt; pixelShader;

#if defined(_DEBUG)
        // Enable better shader debugging with the graphics debugging tools.
        UINT compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#else
        UINT compileFlags = 0;
#endif

        ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "VSMain", "vs_5_0", compileFlags, 0, &amp;amp;amp;amp;amp;amp;vertexShader, nullptr));
        ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L"shaders.hlsl").c_str(), nullptr, nullptr, "PSMain", "ps_5_0", compileFlags, 0, &amp;amp;amp;amp;amp;amp;pixelShader, nullptr));

        // Define the vertex input layout.
        D3D12_INPUT_ELEMENT_DESC inputElementDescs[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
            { "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }
        };

        // Describe and create the graphics pipeline state object (PSO).
        D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {};
        psoDesc.InputLayout = { inputElementDescs, _countof(inputElementDescs) };
        psoDesc.pRootSignature = m_rootSignature.Get();
        psoDesc.VS = { reinterpret_cast&lt;UINT8*&gt;(vertexShader-&gt;GetBufferPointer()), vertexShader-&gt;GetBufferSize() };
        psoDesc.PS = { reinterpret_cast&lt;UINT8*&gt;(pixelShader-&gt;GetBufferPointer()), pixelShader-&gt;GetBufferSize() };
        psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
        psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
        psoDesc.DepthStencilState.DepthEnable = FALSE;
        psoDesc.DepthStencilState.StencilEnable = FALSE;
        psoDesc.SampleMask = UINT_MAX;
        psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
        psoDesc.NumRenderTargets = 1;
        psoDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
        psoDesc.SampleDesc.Count = 1;
        ThrowIfFailed(m_device-&gt;CreateGraphicsPipelineState(&amp;amp;amp;amp;amp;amp;psoDesc, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_pipelineState)));
    }

    // Create the command list.
    ThrowIfFailed(m_device-&gt;CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), m_pipelineState.Get(), IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_commandList)));

    // Command lists are created in the recording state, but there is nothing
    // to record yet. The main loop expects it to be closed, so close it now.
    ThrowIfFailed(m_commandList-&gt;Close());

    // Create the vertex buffer.
    {
        // Define the geometry for a triangle.
        Vertex triangleVertices[] =
        {
            { { 0.0f, 0.25f * m_aspectRatio, 0.0f }, { 1.0f, 0.0f, 0.0f, 1.0f } },
            { { 0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 1.0f, 0.0f, 1.0f } },
            { { -0.25f, -0.25f * m_aspectRatio, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f } }
        };

        const UINT vertexBufferSize = sizeof(triangleVertices);

        // Note: using upload heaps to transfer static data like vert buffers is not
        // recommended. Every time the GPU needs it, the upload heap will be marshalled
        // over. Please read up on Default Heap usage. An upload heap is used here for
        // code simplicity and because there are very few verts to actually transfer.
        ThrowIfFailed(m_device-&gt;CreateCommittedResource(
            &amp;amp;amp;amp;amp;amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
            D3D12_HEAP_FLAG_NONE,
            &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_DESC.Buffer(vertexBufferSize),
            D3D12_RESOURCE_STATE_GENERIC_READ,
            nullptr,
            IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_vertexBuffer)));

        // Copy the triangle data to the vertex buffer.
        UINT8* pVertexDataBegin;
        CD3DX12_RANGE readRange(0, 0);        // We do not intend to read from this resource on the CPU.
        ThrowIfFailed(m_vertexBuffer-&gt;Map(0, &amp;amp;amp;amp;amp;amp;readRange, reinterpret_cast&lt;void**&gt;(&amp;amp;amp;amp;amp;amp;pVertexDataBegin)));
        memcpy(pVertexDataBegin, triangleVertices, sizeof(triangleVertices));
        m_vertexBuffer-&gt;Unmap(0, nullptr);

        // Initialize the vertex buffer view.
        m_vertexBufferView.BufferLocation = m_vertexBuffer-&gt;GetGPUVirtualAddress();
        m_vertexBufferView.StrideInBytes = sizeof(Vertex);
        m_vertexBufferView.SizeInBytes = vertexBufferSize;
    }

    // Create synchronization objects and wait until assets have been uploaded to the GPU.
    {
        ThrowIfFailed(m_device-&gt;CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;m_fence)));
        m_fenceValue = 1;

        // Create an event handle to use for frame synchronization.
        m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
        if (m_fenceEvent == nullptr)
        {
            ThrowIfFailed(HRESULT_FROM_WIN32(GetLastError()));
        }

        // Wait for the command list to execute; we are reusing the same command
        // list in our main loop but for now, we just want to wait for setup to
        // complete before continuing.
        WaitForPreviousFrame();
    }
}

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.CopyBufferRegion">
    <summary>
      <para>Copies a region of a buffer from one resource to another.</para>
    </summary>
    <param name="pDstBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies the destination <see cref="ID3D12Resource" />.</para>
    </param>
    <param name="DstOffset">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies a UINT64 offset (in bytes) into the destination resource.</para>
    </param>
    <param name="pSrcBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies the source  <see cref="ID3D12Resource" />.</para>
    </param>
    <param name="SrcOffset">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies a UINT64 offset (in bytes) into the source resource, to start the copy from.</para>
    </param>
    <param name="NumBytes">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies the number of bytes to copy.</para>
    </param>
    <remarks>
      <para>Consider using the <see cref="CopyResource" /> method when copying an entire resource, and use this method for copying regions of a resource.</para>
      <para>
        <b>CopyBufferRegion</b> may be used to initialize resources which alias the same heap memory. See <see cref="CreatePlacedResource" /> for more details.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.CopyBufferRegion</b> as follows:</para>
      <code>inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources,
    UINT64 RequiredSize,
    _In_reads_(NumSubresources) const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    _In_reads_(NumSubresources) const UINT* pNumRows,
    _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
{
    // Minor validation
    D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc();
    D3D12_RESOURCE_DESC DestinationDesc = pDestinationResource-&gt;GetDesc();
    if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER ||
        IntermediateDesc.Width &lt; RequiredSize + pLayouts[0].Offset ||
        RequiredSize &gt; (SIZE_T)-1 ||
        (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp;
            (FirstSubresource != 0 || NumSubresources != 1)))
    {
        return 0;
    }

    BYTE* pData;
    HRESULT hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;amp;amp;amp;amp;amp;pData));
    if (FAILED(hr))
    {
        return 0;
    }

    for (UINT i = 0; i &lt; NumSubresources; ++i)
    {
        if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0;
        D3D12_MEMCPY_DEST DestData = { pData + pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
        MemcpySubresource(&amp;amp;amp;amp;amp;amp;DestData, &amp;amp;amp;amp;amp;amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth);
    }
    pIntermediate-&gt;Unmap(0, NULL);

    if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
    {
        CD3DX12_BOX SrcBox( UINT( pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) );
        pCmdList-&gt;CopyBufferRegion(
            pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width);
    }
    else
    {
        for (UINT i = 0; i &lt; NumSubresources; ++i)
        {
            CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
            CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]);
            pCmdList-&gt;CopyTextureRegion(&amp;amp;amp;amp;amp;amp;Dst, 0, 0, 0, &amp;amp;amp;amp;amp;amp;Src, nullptr);
        }
    }
    return RequiredSize;
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="CopyTextureRegion" />
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.CopyTextureRegion">
    <summary>
      <para>This method uses the GPU to copy texture data between two locations. Both the source and the destination may reference texture data located within either a buffer resource or a texture resource.</para>
    </summary>
    <param name="pDst">
      <para>Type: <b>const <see cref="D3D12_TEXTURE_COPY_LOCATION" />*</b></para>
      <para>Specifies the destination <see cref="D3D12_TEXTURE_COPY_LOCATION" />. The subresource referred to must be in the D3D12_RESOURCE_STATE_COPY_DEST state.</para>
    </param>
    <param name="DstX">
      <para>Type: <b>UINT</b></para>
      <para>The x-coordinate of the upper left corner of the destination region.</para>
    </param>
    <param name="DstY">
      <para>Type: <b>UINT</b></para>
      <para>The y-coordinate of the upper left corner of the destination region. For a 1D subresource, this must be zero.</para>
    </param>
    <param name="DstZ">
      <para>Type: <b>UINT</b></para>
      <para>The z-coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</para>
    </param>
    <param name="pSrc">
      <para>Type: <b>const <see cref="D3D12_TEXTURE_COPY_LOCATION" />*</b></para>
      <para>Specifies the source <see cref="D3D12_TEXTURE_COPY_LOCATION" />.
The subresource referred to must be in the D3D12_RESOURCE_STATE_COPY_SOURCE state.</para>
    </param>
    <param name="pSrcBox">
      <para>Type: <b>const <see cref="D3D12_BOX" />*</b></para>
      <para>Specifies an optional  D3D12_BOX that sets the size of the source texture to copy.</para>
    </param>
    <remarks>
      <para>The source box must be within the size of the source resource. The destination offsets, (x, y, and z), allow the source box to be offset when writing into the destination resource; however, the dimensions of the source box and the offsets must be within the size of the resource. If you try and copy outside the destination resource or specify a source box that is larger than the source resource, the behavior of <b>CopyTextureRegion</b> is undefined. If you created a device that supports the <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-layers">debug layer</a>, the debug output reports an error on this invalid <b>CopyTextureRegion</b> call. Invalid parameters to <b>CopyTextureRegion</b> cause undefined behavior and might result in incorrect rendering, clipping, no copy, or even the removal of the rendering device.</para>
      <para>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels.</para>
      <para>
        <b>CopyTextureRegion</b> performs the copy on the GPU (similar to a <code>memcpy</code> by the CPU). As a consequence, the source and destination resources:</para>
      <list type="bullet">
        <item>
          <description>Must be different subresources (although they can be from the same resource).</description>
        </item>
        <item>
          <description>Must have compatible <see cref="DXGI_FORMAT" />s (identical or from the same type group). For example, a DXGI_FORMAT_R32G32B32_FLOAT texture can be copied to a DXGI_FORMAT_R32G32B32_UINT texture since both of these formats are in the DXGI_FORMAT_R32G32B32_TYPELESS group. <b>CopyTextureRegion</b> can copy between a few format types. For more info, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-block-compression">Format Conversion using Direct3D 10.1</a>.</description>
        </item>
      </list>
      <b>CopyTextureRegion</b> only supports copy; it does not support any stretch, color key, or blend. <b>CopyTextureRegion</b> can reinterpret the resource data between a few format types.
<para>Note that for a depth-stencil buffer, the depth and stencil planes are <a href="https://docs.microsoft.com//windows/win32/direct3d12/subresources#plane-slice">separate subresources</a> within the buffer.</para><para>To copy an entire resource, rather than just a region of a subresource, we recommend to use <see cref="CopyResource" /> instead.</para><para><b>Note</b>  If you use <b>CopyTextureRegion</b> with a depth-stencil buffer or a multisampled resource, you must copy the entire subresource rectangle. In this situation, you must pass 0 to the <i>DstX</i>, <i>DstY</i>, and <i>DstZ</i> parameters and <b>NULL</b> to the <i>pSrcBox</i> parameter. In addition, source and destination resources, which are represented by the <i>pSrcResource</i> and <i>pDstResource</i> parameters, should have identical sample count values.</para><para><b>CopyTextureRegion</b> may be used to initialize resources which alias the same heap memory. See <see cref="CreatePlacedResource" /> for more details.</para><h3>Example</h3><para>The following code snippet copies the box (located at (120,100),(200,220)) from a source texture into the region (10,20),(90,140) in a destination texture.</para><code>D3D12_BOX sourceRegion;
sourceRegion.left = 120;
sourceRegion.top = 100;
sourceRegion.right = 200;
sourceRegion.bottom = 220;
sourceRegion.front = 0;
sourceRegion.back = 1;

pCmdList -&gt; CopyTextureRegion(pDestTexture, 10, 20, 0, pSourceTexture, &amp;amp;amp;amp;amp;amp;sourceRegion);

</code><para>Notice, that for a 2D texture, front and back are set to 0 and 1 respectively.</para><h4>Examples</h4><para>The <b>HelloTriangle</b> sample uses <b>ID3D12GraphicsCommandList.CopyTextureRegion</b> as follows:</para><code>inline UINT64 UpdateSubresources(
    _In_ ID3D12GraphicsCommandList* pCmdList,
    _In_ ID3D12Resource* pDestinationResource,
    _In_ ID3D12Resource* pIntermediate,
    _In_range_(0,D3D12_REQ_SUBRESOURCES) UINT FirstSubresource,
    _In_range_(0,D3D12_REQ_SUBRESOURCES-FirstSubresource) UINT NumSubresources,
    UINT64 RequiredSize,
    _In_reads_(NumSubresources) const D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    _In_reads_(NumSubresources) const UINT* pNumRows,
    _In_reads_(NumSubresources) const UINT64* pRowSizesInBytes,
    _In_reads_(NumSubresources) const D3D12_SUBRESOURCE_DATA* pSrcData)
{
    // Minor validation
    D3D12_RESOURCE_DESC IntermediateDesc = pIntermediate-&gt;GetDesc();
    D3D12_RESOURCE_DESC DestinationDesc = pDestinationResource-&gt;GetDesc();
    if (IntermediateDesc.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER ||
        IntermediateDesc.Width &lt; RequiredSize + pLayouts[0].Offset ||
        RequiredSize &gt; (SIZE_T)-1 ||
        (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER &amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp;
            (FirstSubresource != 0 || NumSubresources != 1)))
    {
        return 0;
    }

    BYTE* pData;
    HRESULT hr = pIntermediate-&gt;Map(0, NULL, reinterpret_cast&lt;void**&gt;(&amp;amp;amp;amp;amp;amp;pData));
    if (FAILED(hr))
    {
        return 0;
    }

    for (UINT i = 0; i &lt; NumSubresources; ++i)
    {
        if (pRowSizesInBytes[i] &gt; (SIZE_T)-1) return 0;
        D3D12_MEMCPY_DEST DestData = { pData + pLayouts[i].Offset, pLayouts[i].Footprint.RowPitch, pLayouts[i].Footprint.RowPitch * pNumRows[i] };
        MemcpySubresource(&amp;amp;amp;amp;amp;amp;DestData, &amp;amp;amp;amp;amp;amp;pSrcData[i], (SIZE_T)pRowSizesInBytes[i], pNumRows[i], pLayouts[i].Footprint.Depth);
    }
    pIntermediate-&gt;Unmap(0, NULL);

    if (DestinationDesc.Dimension == D3D12_RESOURCE_DIMENSION_BUFFER)
    {
        CD3DX12_BOX SrcBox( UINT( pLayouts[0].Offset ), UINT( pLayouts[0].Offset + pLayouts[0].Footprint.Width ) );
        pCmdList-&gt;CopyBufferRegion(
            pDestinationResource, 0, pIntermediate, pLayouts[0].Offset, pLayouts[0].Footprint.Width);
    }
    else
    {
        for (UINT i = 0; i &lt; NumSubresources; ++i)
        {
            CD3DX12_TEXTURE_COPY_LOCATION Dst(pDestinationResource, i + FirstSubresource);
            CD3DX12_TEXTURE_COPY_LOCATION Src(pIntermediate, pLayouts[i]);
            pCmdList-&gt;CopyTextureRegion(&amp;amp;amp;amp;amp;amp;Dst, 0, 0, 0, &amp;amp;amp;amp;amp;amp;Src, nullptr);
        }
    }
    return RequiredSize;
}

</code><para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para></remarks>
    <seealso cref="CopyBufferRegion" />
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.CopyTiles">
    <summary>
      <para>Copies tiles from buffer to tiled resource or vice versa.</para>
    </summary>
    <param name="pTiledResource">
      <para>Type: <b>ID3D12Resource*</b></para>
      <para>A pointer to a tiled resource.</para>
    </param>
    <param name="pTileRegionStartCoordinate">
      <para>Type: <b>const <see cref="D3D12_TILED_RESOURCE_COORDINATE" />*</b></para>
      <para>A pointer to a
<see cref="D3D12_TILED_RESOURCE_COORDINATE" /> structure that describes the starting coordinates of the tiled resource.</para>
    </param>
    <param name="pTileRegionSize">
      <para>Type: <b>const <see cref="D3D12_TILE_REGION_SIZE" />*</b></para>
      <para>A pointer to a <see cref="D3D12_TILE_REGION_SIZE" /> structure that describes the size of the tiled region.</para>
    </param>
    <param name="pBuffer">
      <para>Type: <b>ID3D12Resource*</b></para>
      <para>A pointer to an <see cref="ID3D12Resource" /> that represents a default, dynamic, or staging buffer.</para>
    </param>
    <param name="BufferStartOffsetInBytes">
      <para>Type: <b>UINT64</b></para>
      <para>The offset in bytes into the buffer at <i>pBuffer</i> to start the operation.</para>
    </param>
    <param name="Flags">
      <para>Type: <b><see cref="D3D12_TILE_COPY_FLAGS" /></b></para>
      <para>A combination of <see cref="D3D12_TILE_COPY_FLAGS" />-typed values that are combined by using a bitwise OR operation and that identifies how to copy tiles.</para>
    </param>
    <remarks>
      <para>
        <b>CopyTiles</b> drops write operations to
unmapped areas and handles read operations from unmapped areas
(except on Tier_1 tiled resources,
where reading and writing unmapped areas is invalid - refer to <see cref="D3D12_TILED_RESOURCES_TIER" />).</para>
      <para>If a copy operation involves writing to the same memory location multiple times because multiple locations in the
destination resource are mapped to the same tile memory, the resulting write operations to multi-mapped tiles are
non-deterministic and non-repeatable; that is, accesses to the tile memory happen in whatever order the hardware
happens to execute the copy operation.</para>
      <para>The tiles involved in the copy operation can't include tiles that contain packed mipmaps or results of the copy
operation are undefined. To transfer data to and from mipmaps that the hardware packs into the one-or-more tiles that constitute the packed mips, you must
use the standard (that is, non-tile specific) copy APIs
like <see cref="CopyTextureRegion" />.</para>
      <para>
        <b>CopyTiles</b> does copy data in a slightly different pattern than the standard copy methods.</para>
      <para>The memory layout of the tiles in the non-tiled buffer resource side of the copy operation is linear in memory within 64 KB tiles, which the hardware and driver swizzle and de-swizzle per tile as appropriate when they transfer to and from a tiled resource. For multisample antialiasing (MSAA) surfaces, the hardware and driver traverse each pixel's samples in sample-index order before they move to the next pixel. For tiles that are partially filled on the right side (for a surface that has a width not a multiple of tile width in pixels), the pitch and stride to move down a row is the full size in bytes of the number pixels that would fit across the tile if the tile was full. So, there can be a gap between each row of pixels in memory. Mipmaps that are smaller than a tile are not packed together in the linear layout, which might seem to be a waste of memory space, but as mentioned you can't use <b>CopyTiles</b> to copy to mipmaps that the hardware packs together. You can just use generic copy APIs, like <see cref="CopyTextureRegion" />, to copy small mipmaps individually.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d11/tiled-resources">Tiled resources</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.DiscardResource">
    <summary>
      <para>Indicates that the contents of a resource don't need to be preserved. The function may re-initialize resource metadata in some cases.</para>
    </summary>
    <param name="pResource">
      <para>Type: [in] <b><see cref="ID3D12Resource" />*</b></para>
      <para>A pointer to the <see cref="ID3D12Resource" /> interface for the resource to discard.</para>
    </param>
    <param name="pRegion">
      <para>Type: [in, optional] <b>const <see cref="D3D12_DISCARD_REGION" />*</b></para>
      <para>A pointer to a <see cref="D3D12_DISCARD_REGION" /> structure that describes details for the discard-resource operation.</para>
    </param>
    <remarks>
      <para>The semantics of <b>DiscardResource</b> change based on the command list type.</para>
      <para>For <see cref="D3D12_COMMAND_LIST_TYPE_DIRECT" />, the following two rules apply:</para>
      <list type="bullet">
        <item>
          <description>When a resource has the <see cref="D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET" /> flag, <b>DiscardResource</b> must be called when the discarded subresource regions are in the <see cref="D3D12_RESOURCE_STATE_RENDER_TARGET" /> resource barrier state.</description>
        </item>
        <item>
          <description>When a resource has the <see cref="D3D12_RESOURCE_FLAG _ALLOW_DEPTH_STENCIL" /> flag, <b>DiscardResource</b> must be called when the discarded subresource regions are in the <see cref="D3D12_RESOURCE_STATE_DEPTH_WRITE" />.
</description>
        </item>
      </list>
      <para>For <see cref="D3D12_COMMAND_LIST_TYPE_COMPUTE" />, the following rule applies:</para>
      <list type="bullet">
        <item>
          <description>The resource must have the <see cref="D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS" /> flag, and <b>DiscardResource</b> must be called when the discarded subresource regions are in the <see cref="D3D12_RESOURCE_STATE_UNORDERED_ACCESS" /> resource barrier state.</description>
        </item>
      </list>
      <b>DiscardResource</b> is not supported on command lists with either <see cref="D3D12_COMMAND_LIST_TYPE_BUNDLE" /> nor <b>D3D12_COMMAND_LIST_TYPE_COPY</b>.
</remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12">Using Resource Barriers to Synchronize Resource States in Direct3D 12</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.Dispatch">
    <summary>
      <para>Executes a command list from a thread group.</para>
    </summary>
    <param name="ThreadGroupCountX">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the x direction. <i>ThreadGroupCountX</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).</para>
    </param>
    <param name="ThreadGroupCountY">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the y direction. <i>ThreadGroupCountY</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).</para>
    </param>
    <param name="ThreadGroupCountZ">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of groups dispatched in the z direction.  <i>ThreadGroupCountZ</i> must be less than or equal to D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65535).
In feature level 10 the value for <i>ThreadGroupCountZ</i> must be 1.</para>
    </param>
    <remarks>
      <para>You call the <b>Dispatch</b> method to execute commands in a compute shader. A compute shader can be run on many threads in parallel, within a thread group. Index a particular thread, within a thread group using a 3D vector
given by (x,y,z).</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12nBodyGravity</a> sample uses <b>ID3D12GraphicsCommandList.Dispatch</b> as follows:</para>
      <code>// Run the particle simulation using the compute shader.
void D3D12nBodyGravity.Simulate(UINT threadIndex)
{
    ID3D12GraphicsCommandList* pCommandList = m_computeCommandList[threadIndex].Get();

    UINT srvIndex;
    UINT uavIndex;
    ID3D12Resource *pUavResource;
    if (m_srvIndex[threadIndex] == 0)
    {
        srvIndex = SrvParticlePosVelo0;
        uavIndex = UavParticlePosVelo1;
        pUavResource = m_particleBuffer1[threadIndex].Get();
    }
    else
    {
        srvIndex = SrvParticlePosVelo1;
        uavIndex = UavParticlePosVelo0;
        pUavResource = m_particleBuffer0[threadIndex].Get();
    }

    pCommandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(pUavResource, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS));

    pCommandList-&gt;SetPipelineState(m_computeState.Get());
    pCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_srvUavHeap.Get() };
    pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    CD3DX12_GPU_DESCRIPTOR_HANDLE srvHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), srvIndex + threadIndex, m_srvUavDescriptorSize);
    CD3DX12_GPU_DESCRIPTOR_HANDLE uavHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), uavIndex + threadIndex, m_srvUavDescriptorSize);

    pCommandList-&gt;SetComputeRootConstantBufferView(RootParameterCB, m_constantBufferCS-&gt;GetGPUVirtualAddress());
    pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterSRV, srvHandle);
    pCommandList-&gt;SetComputeRootDescriptorTable(RootParameterUAV, uavHandle);

    pCommandList-&gt;Dispatch(static_cast&lt;int&gt;(ceil(ParticleCount / 128.0f)), 1, 1);

    pCommandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(pUavResource, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE));
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.DrawIndexedInstanced">
    <summary>
      <para>Draws indexed, instanced primitives.</para>
    </summary>
    <param name="IndexCountPerInstance">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of indices read from the index buffer for each instance.</para>
    </param>
    <param name="InstanceCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of instances to draw.</para>
    </param>
    <param name="StartIndexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The location of the first index read by the GPU from the index buffer.</para>
    </param>
    <param name="BaseVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">INT</a></b></para>
      <para>A value added to each index before reading a vertex from the vertex buffer.</para>
    </param>
    <param name="StartInstanceLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
    </param>
    <remarks>
      <para>A draw API submits work to the rendering pipeline.</para>
      <para>Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be
to draw the same object with different positions and colors. Instancing requires multiple vertex buffers: at least one for per-vertex data
and a second buffer for per-instance data.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Bundles</a> sample uses <b>ID3D12GraphicsCommandList.DrawIndexedInstanced</b> as follows:</para>
      <code>void FrameResource.PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1, ID3D12PipelineState* pPso2,
    UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc, D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc,
    ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize, ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature)
{
    // If the root signature matches the root signature of the caller, then
    // bindings are inherited, otherwise the bind space is reset.
    pCommandList-&gt;SetGraphicsRootSignature(pRootSignature);

    ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap, pSamplerDescriptorHeap };
    pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
    pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc);

    pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);

    pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
    pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());

    // Calculate the descriptor offset due to multiple frame resources.
    // 1 SRV + how many CBVs we have currently.
    UINT frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount);
    CD3DX12_GPU_DESCRIPTOR_HANDLE cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset, cbvSrvDescriptorSize);

    BOOL usePso1 = TRUE;
    for (UINT i = 0; i &lt; m_cityRowCount; i++)
    {
        for (UINT j = 0; j &lt; m_cityColumnCount; j++)
        {
            // Alternate which PSO to use; the pixel shader is different on
            // each just as a PSO setting demonstration.
            pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2);
            usePso1 = !usePso1;

            // Set this city's CBV table and move to the next descriptor.
            pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
            cbvSrvHandle.Offset(cbvSrvDescriptorSize);

            pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0);
        }
    }
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.DrawInstanced">
    <summary>
      <para>Draws non-indexed, instanced primitives.</para>
    </summary>
    <param name="VertexCountPerInstance">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of vertices to draw.</para>
    </param>
    <param name="InstanceCount">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of instances to draw.</para>
    </param>
    <param name="StartVertexLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Index of the first vertex.</para>
    </param>
    <param name="StartInstanceLocation">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>A value added to each index before reading per-instance data from a vertex buffer.</para>
    </param>
    <remarks>
      <para>A draw API submits work to the rendering pipeline.</para>
      <para>Instancing might extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be
to draw the same object with different positions and colors.</para>
      <para>The vertex data for an instanced draw call typically comes from a vertex buffer that is bound to the pipeline.
But, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.DrawInstanced</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.EndEvent">
    <summary>
      <para>Not intended to be called directly.  Use the
<a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">PIX event runtime</a> to insert events into a command list.</para>
    </summary>
    <remarks>
      <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
      <para>To mark the end of an instrumentation region at the current location within a D3D12 command list, use the <b>PIXEndEvent</b> function or <b>PIXScopedEvent</b> macro.  These are provided by the <a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.EndQuery">
    <summary>
      <para>Ends a running query.</para>
    </summary>
    <param name="pQueryHeap">
      <para>Type: <b><see cref="ID3D12QueryHeap" />*</b></para>
      <para>Specifies the <see cref="ID3D12QueryHeap" /> containing the query.</para>
    </param>
    <param name="Type">
      <para>Type: <b><see cref="D3D12_QUERY_TYPE" /></b></para>
      <para>Specifies one member of <see cref="D3D12_QUERY_TYPE" />.</para>
    </param>
    <param name="Index">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the index of the query in the query heap.</para>
    </param>
    <remarks>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/queries">Queries</a> for more information about D3D12 queries.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12PredicationQueries</a> sample uses <b>ID3D12GraphicsCommandList.EndQuery</b> as follows:</para>
      <code>// Fill the command list with all the render commands and dependent state.
void D3D12PredicationQueries.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    // Draw the quads and perform the occlusion query.
    {
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);

        m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
        m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);

        // Draw the far quad conditionally based on the result of the occlusion query
        // from the previous frame.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPredication(m_queryResult.Get(), 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;DrawInstanced(4, 1, 0, 0);

        // Disable predication and always draw the near quad.
        m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad);
        m_commandList-&gt;DrawInstanced(4, 1, 4, 0);

        // Run the occlusion query with the bounding box quad.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPipelineState(m_queryState.Get());
        m_commandList-&gt;BeginQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);
        m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
        m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);

        // Resolve the occlusion query and store the results in the query result buffer
        // to be used on the subsequent frame.
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION, D3D12_RESOURCE_STATE_COPY_DEST));
        m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1, m_queryResult.Get(), 0);
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION));
    }

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ExecuteBundle">
    <summary>
      <para>Executes a bundle.</para>
    </summary>
    <param name="pCommandList">
      <para>Type: <b><see cref="ID3D12GraphicsCommandList" />*</b></para>
      <para>Specifies the <see cref="ID3D12GraphicsCommandList" /> that determines the bundle to be executed.</para>
    </param>
    <remarks>
      <para>Bundles inherit all state from the parent command list on which <b>ExecuteBundle</b> is called, except the pipeline state object and primitive topology.
All of the state that is set in a bundle will affect the state of the parent command list.
Note that <b>ExecuteBundle</b> is not a predicated operation.</para>
      <h3>Runtime validation</h3>
      <para>The runtime will validate that the "callee" is a bundle and that the "caller" is a direct command list.  The runtime will also validate that the bundle has been closed.  If the contract is violated, the runtime will silently drop the call.
Validation failure will result in <see cref="Close" /> returning E_INVALIDARG.</para>
      <h3>Debug layer</h3>
      <para>The debug layer will issue a warning in the same cases where the runtime will fail.
The debug layer will issue a warning if a predicate is set when <see cref="ExecuteCommandList" /> is called.
Also, the debug layer will issue an error if it detects that any resource reference by the command list has been destroyed.</para>
      <para>The debug layer will also validate that the command allocator associated with the bundle has not been reset since <see cref="Close" /> was called on the command list.  This validation occurs at <b>ExecuteBundle</b> time, and when the parent command list is executed on a command queue.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Bundles</a> sample uses <b>ID3D12GraphicsCommandList.ExecuteBundle</b> as follows:</para>
      <code>void D3D12Bundles.PopulateCommandList(FrameResource* pFrameResource)
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_pCurrentFrameResource-&gt;m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_pCurrentFrameResource-&gt;m_commandAllocator.Get(), m_pipelineState1.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvHeap.Get(), m_samplerHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;ClearDepthStencilView(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    if (UseBundles)
    {
        // Execute the prebuilt bundle.
        m_commandList-&gt;ExecuteBundle(pFrameResource-&gt;m_bundle.Get());
    }
    else
    {
        // Populate a new command list.
        pFrameResource-&gt;PopulateCommandList(m_commandList.Get(), m_pipelineState1.Get(), m_pipelineState2.Get(), m_currentFrameResourceIndex, m_numIndices, &amp;amp;amp;amp;amp;amp;m_indexBufferView,
            &amp;amp;amp;amp;amp;amp;m_vertexBufferView, m_cbvSrvHeap.Get(), m_cbvSrvDescriptorSize, m_samplerHeap.Get(), m_rootSignature.Get());
    }

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ExecuteIndirect">
    <summary>
      <para>Apps perform indirect draws/dispatches using the <b>ExecuteIndirect</b> method.</para>
    </summary>
    <param name="pCommandSignature">
      <para>Type: <b><see cref="ID3D12CommandSignature" />*</b></para>
      <para>Specifies a <see cref="ID3D12CommandSignature" />. The data referenced by <i>pArgumentBuffer</i> will be interpreted depending on the contents of the command signature. Refer to <a href="https://docs.microsoft.com//windows/desktop/direct3d12/indirect-drawing">Indirect Drawing</a> for the APIs that are used to create a command signature.</para>
    </param>
    <param name="MaxCommandCount">
      <para>Type: <b>UINT</b></para>
      <para>There are two ways that command counts can be specified:</para>
      <list type="bullet">
        <item>
          <description>If <i>pCountBuffer</i> is not NULL, then <i>MaxCommandCount</i> specifies the maximum number of operations which will be performed.  The actual number of operations to be performed are defined by the minimum of this value, and a 32-bit unsigned integer contained in <i>pCountBuffer</i> (at the byte offset specified by <i>CountBufferOffset</i>).
</description>
        </item>
        <item>
          <description>If <i>pCountBuffer</i> is NULL, the <i>MaxCommandCount</i> specifies the exact number of operations which will be performed.
</description>
        </item>
      </list>
    </param>
    <param name="pArgumentBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies one or more <see cref="ID3D12Resource" /> objects, containing the command arguments.</para>
    </param>
    <param name="ArgumentBufferOffset">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies an offset into <i>pArgumentBuffer</i> to identify the first command argument.</para>
    </param>
    <param name="pCountBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies a pointer to a <see cref="ID3D12Resource" />.</para>
    </param>
    <param name="CountBufferOffset">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies a UINT64 that is the offset into <i>pCountBuffer</i>, identifying the argument count.</para>
    </param>
    <remarks>
      <para>The semantics of this API are defined with the following pseudo-code:</para>
      <para>Non-NULL pCountBuffer:</para>
      <code>// Read draw count out of count buffer
UINT CommandCount = pCountBuffer-&gt;ReadUINT32(CountBufferOffset);

CommandCount = min(CommandCount, MaxCommandCount)

// Get pointer to first Commanding argument
BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset;

for(UINT CommandIndex = 0; CommandIndex &lt; CommandCount; CommandIndex++)
{
  // Interpret the data contained in *Arguments
  // according to the command signature
  pCommandSignature-&gt;Interpret(Arguments);

  Arguments += pCommandSignature-&gt;GetByteStride();
}

</code>
      <para>NULL pCountBuffer:</para>
      <code>// Get pointer to first Commanding argument
BYTE* Arguments = pArgumentBuffer-&gt;GetBase() + ArgumentBufferOffset;

for(UINT CommandIndex = 0; CommandIndex &lt; MaxCommandCount; CommandIndex++)
{
  // Interpret the data contained in *Arguments
  // according to the command signature
  pCommandSignature-&gt;Interpret(Arguments);

  Arguments += pCommandSignature-&gt;GetByteStride();
}

</code>
      <para>The debug layer will issue an error if either the count buffer or the argument buffer are not in the D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT state. The core runtime will validate:</para>
      <list type="bullet">
        <item>
          <description>
            <i>CountBufferOffset</i> and <i>ArgumentBufferOffset</i> are 4-byte aligned
</description>
        </item>
        <item>
          <description>
            <i>pCountBuffer</i> and <i>pArgumentBuffer</i> are buffer resources (any heap type)
</description>
        </item>
        <item>
          <description>The offset implied by <i>MaxCommandCount</i>, <i>ArgumentBufferOffset</i>, and the drawing program stride do not exceed the bounds of <i>pArgumentBuffer</i> (similarly for count buffer)
</description>
        </item>
        <item>
          <description>The command list is a direct command list or a compute command list (not a copy or JPEG decode command list)</description>
        </item>
        <item>
          <description>The root signature of the command list matches the root signature of the command signature</description>
        </item>
      </list>
      <para>The functionality of two APIs from earlier versions of Direct3D, <code>DrawInstancedIndirect</code> and <code>DrawIndexedInstancedIndirect</code>, are encompassed by  <b>ExecuteIndirect</b>.</para>
      <h3>Bundles</h3>
      <b>ID3D12GraphicsCommandList.ExecuteIndirect</b> is allowed inside of bundle command lists only if all of the following are true:
<list type="bullet"><item><description>CountBuffer is NULL (CPU-specified count only).</description></item><item><description>The command signature contains exactly one operation.  This implies that the command signature does not contain root arguments changes, nor contain VB/IB binding changes.</description></item></list><h3>Obtaining buffer virtual addresses</h3><para>The <see cref="ID3D12Resource.GetGPUVirtualAddress" /> method enables an app to retrieve the GPU virtual address of a buffer.</para><para>Apps are free to apply byte offsets to virtual addresses before placing them in an indirect argument buffer.  Note that all of the D3D12 alignment requirements for VB/IB/CB still apply to the resulting GPU virtual address.</para><h4>Examples</h4><para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12ExecuteIndirect</a> sample uses <b>ID3D12GraphicsCommandList.ExecuteIndirect</b> as follows:</para><code>// Data structure to match the command signature used for ExecuteIndirect.
struct IndirectCommand
{
    D3D12_GPU_VIRTUAL_ADDRESS cbv;
    D3D12_DRAW_ARGUMENTS drawArguments;
};

</code><para>The call to <b>ExecuteIndirect</b> is near the end of this listing, below the comment "Draw the triangles that have not been culled."</para><code>// Fill the command list with all the render commands and dependent state.
void D3D12ExecuteIndirect.PopulateCommandLists()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_computeCommandAllocators[m_frameIndex]-&gt;Reset());
    ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_computeCommandList-&gt;Reset(m_computeCommandAllocators[m_frameIndex].Get(), m_computeState.Get()));
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get()));

    // Record the compute commands that will cull triangles and prevent them from being processed by the vertex shader.
    if (m_enableCulling)
    {
        UINT frameDescriptorOffset = m_frameIndex * CbvSrvUavDescriptorCountPerFrame;
        D3D12_GPU_DESCRIPTOR_HANDLE cbvSrvUavHandle = m_cbvSrvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart();

        m_computeCommandList-&gt;SetComputeRootSignature(m_computeRootSignature.Get());

        ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvUavHeap.Get() };
        m_computeCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

        m_computeCommandList-&gt;SetComputeRootDescriptorTable(
            SrvUavTable,
            CD3DX12_GPU_DESCRIPTOR_HANDLE(cbvSrvUavHandle, CbvSrvOffset + frameDescriptorOffset, m_cbvSrvUavDescriptorSize));

        m_computeCommandList-&gt;SetComputeRoot32BitConstants(RootConstants, 4, reinterpret_cast&lt;void*&gt;(&amp;amp;amp;amp;amp;amp;m_csRootConstants), 0);

        // Reset the UAV counter for this frame.
        m_computeCommandList-&gt;CopyBufferRegion(m_processedCommandBuffers[m_frameIndex].Get(), CommandBufferSizePerFrame, m_processedCommandBufferCounterReset.Get(), 0, sizeof(UINT));

        D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER.Transition(m_processedCommandBuffers[m_frameIndex].Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_UNORDERED_ACCESS);
        m_computeCommandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;barrier);

        m_computeCommandList-&gt;Dispatch(static_cast&lt;UINT&gt;(ceil(TriangleCount / float(ComputeThreadBlockSize))), 1, 1);
    }

    ThrowIfFailed(m_computeCommandList-&gt;Close());

    // Record the rendering commands.
    {
        // Set necessary state.
        m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

        ID3D12DescriptorHeap* ppHeaps[] = { m_cbvSrvUavHeap.Get() };
        m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

        m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
        m_commandList-&gt;RSSetScissorRects(1, m_enableCulling ? &amp;amp;amp;amp;amp;amp;m_cullingScissorRect : &amp;amp;amp;amp;amp;amp;m_scissorRect);

        // Indicate that the command buffer will be used for indirect drawing
        // and that the back buffer will be used as a render target.
        D3D12_RESOURCE_BARRIER barriers[2] = {
            CD3DX12_RESOURCE_BARRIER.Transition(
                m_enableCulling ? m_processedCommandBuffers[m_frameIndex].Get() : m_commandBuffer.Get(),
                m_enableCulling ? D3D12_RESOURCE_STATE_UNORDERED_ACCESS : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE,
                D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT),
            CD3DX12_RESOURCE_BARRIER.Transition(
                m_renderTargets[m_frameIndex].Get(),
                D3D12_RESOURCE_STATE_PRESENT,
                D3D12_RESOURCE_STATE_RENDER_TARGET)
        };

        m_commandList-&gt;ResourceBarrier(_countof(barriers), barriers);

        CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
        CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
        m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

        // Record commands.
        const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
        m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
        m_commandList-&gt;ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

        m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
        m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);

        if (m_enableCulling)
        {
            // Draw the triangles that have not been culled.
            m_commandList-&gt;ExecuteIndirect(
                m_commandSignature.Get(),
                TriangleCount,
                m_processedCommandBuffers[m_frameIndex].Get(),
                0,
                m_processedCommandBuffers[m_frameIndex].Get(),
                CommandBufferSizePerFrame);
        }
        else
        {
            // Draw all of the triangles.
            m_commandList-&gt;ExecuteIndirect(
                m_commandSignature.Get(),
                TriangleCount,
                m_commandBuffer.Get(),
                CommandBufferSizePerFrame * m_frameIndex,
                nullptr,
                0);
        }

        // Indicate that the command buffer may be used by the compute shader
        // and that the back buffer will now be used to present.
        barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT;
        barriers[0].Transition.StateAfter = m_enableCulling ? D3D12_RESOURCE_STATE_COPY_DEST : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
        barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;

        m_commandList-&gt;ResourceBarrier(_countof(barriers), barriers);

        ThrowIfFailed(m_commandList-&gt;Close());
    }
}

</code><para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para></remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/indirect-drawing">Indirect Drawing</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.IASetIndexBuffer">
    <summary>
      <para>Sets the view for the index buffer.</para>
    </summary>
    <param name="pView">
      <para>Type: <b>const <see cref="D3D12_INDEX_BUFFER_VIEW" />*</b></para>
      <para>The view specifies the index buffer's address, size, and <see cref="DXGI_FORMAT" />, as a pointer to a <see cref="D3D12_INDEX_BUFFER_VIEW" /> structure.</para>
    </param>
    <remarks>
      <para>Only one index buffer can be bound to the graphics pipeline at any one time.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12Bundles</a> sample uses <b>ID3D12GraphicsCommandList.IASetIndexBuffer</b> as follows:</para>
      <code>void FrameResource.PopulateCommandList(ID3D12GraphicsCommandList* pCommandList, ID3D12PipelineState* pPso1, ID3D12PipelineState* pPso2,
    UINT frameResourceIndex, UINT numIndices, D3D12_INDEX_BUFFER_VIEW* pIndexBufferViewDesc, D3D12_VERTEX_BUFFER_VIEW* pVertexBufferViewDesc,
    ID3D12DescriptorHeap* pCbvSrvDescriptorHeap, UINT cbvSrvDescriptorSize, ID3D12DescriptorHeap* pSamplerDescriptorHeap, ID3D12RootSignature* pRootSignature)
{
    // If the root signature matches the root signature of the caller, then
    // bindings are inherited, otherwise the bind space is reset.
    pCommandList-&gt;SetGraphicsRootSignature(pRootSignature);

    ID3D12DescriptorHeap* ppHeaps[] = { pCbvSrvDescriptorHeap, pSamplerDescriptorHeap };
    pCommandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
    pCommandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    pCommandList-&gt;IASetIndexBuffer(pIndexBufferViewDesc);

    pCommandList-&gt;IASetVertexBuffers(0, 1, pVertexBufferViewDesc);

    pCommandList-&gt;SetGraphicsRootDescriptorTable(0, pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());
    pCommandList-&gt;SetGraphicsRootDescriptorTable(1, pSamplerDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart());

    // Calculate the descriptor offset due to multiple frame resources.
    // 1 SRV + how many CBVs we have currently.
    UINT frameResourceDescriptorOffset = 1 + (frameResourceIndex * m_cityRowCount * m_cityColumnCount);
    CD3DX12_GPU_DESCRIPTOR_HANDLE cbvSrvHandle(pCbvSrvDescriptorHeap-&gt;GetGPUDescriptorHandleForHeapStart(), frameResourceDescriptorOffset, cbvSrvDescriptorSize);

    BOOL usePso1 = TRUE;
    for (UINT i = 0; i &lt; m_cityRowCount; i++)
    {
        for (UINT j = 0; j &lt; m_cityColumnCount; j++)
        {
            // Alternate which PSO to use; the pixel shader is different on
            // each just as a PSO setting demonstration.
            pCommandList-&gt;SetPipelineState(usePso1 ? pPso1 : pPso2);
            usePso1 = !usePso1;

            // Set this city's CBV table and move to the next descriptor.
            pCommandList-&gt;SetGraphicsRootDescriptorTable(2, cbvSrvHandle);
            cbvSrvHandle.Offset(cbvSrvDescriptorSize);

            pCommandList-&gt;DrawIndexedInstanced(numIndices, 1, 0, 0, 0);
        }
    }
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.IASetPrimitiveTopology">
    <summary>
      <para>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</para>
    </summary>
    <param name="PrimitiveTopology">
      <para>Type: <b>D3D12_PRIMITIVE_TOPOLOGY</b></para>
      <para>The type of primitive and ordering of the primitive data (see <see cref="D3D_PRIMITIVE_TOPOLOGY" />).</para>
    </param>
    <seealso cref="D3D12_PRIMITIVE_TOPOLOGY_TYPE" />
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.IASetVertexBuffers">
    <summary>
      <para>Sets a CPU descriptor handle for the vertex buffers.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b>UINT</b></para>
      <para>Index into the device's zero-based array to begin setting vertex buffers.</para>
    </param>
    <param name="NumViews">
      <para>Type: <b>UINT</b></para>
      <para>The number of views in the <i>pViews</i> array.</para>
    </param>
    <param name="pViews">
      <para>Type: <b>const <see cref="D3D12_VERTEX_BUFFER_VIEW" />*</b></para>
      <para>Specifies the vertex buffer views in an array of <see cref="D3D12_VERTEX_BUFFER_VIEW" /> structures.</para>
    </param>
    <seealso cref="IASetIndexBuffer" />
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.OMSetBlendFactor">
    <summary>
      <para>Sets the blend factor that modulate values for a pixel shader, render target, or both.</para>
    </summary>
    <param name="BlendFactor">
      <para>Type: <b>const FLOAT[4]</b></para>
      <para>Array of blend factors, one for each RGBA component.</para>
    </param>
    <remarks>
      <para>If you created the blend-state object with <see cref="D3D12_BLEND_BLEND_FACTOR" /> or <b>D3D12_BLEND_INV_BLEND_FACTOR</b>, then the blending stage uses the non-NULL array of blend factors. Otherwise,the blending stage doesn't use the non-NULL array of blend factors; the runtime stores the blend factors.</para>
      <para>If you pass NULL, then the runtime uses or stores a blend factor equal to <code>{ 1, 1, 1, 1 }</code>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.OMSetRenderTargets">
    <summary>
      <para>Sets CPU descriptor handles for the render targets and depth stencil.</para>
    </summary>
    <param name="NumRenderTargetDescriptors">
      <para>Type: <b>UINT</b></para>
      <para>The number of entries in the <i>pRenderTargetDescriptors</i> array (ranges between 0 and <b>D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT</b>). If this parameter is nonzero, the number of entries in the array to which pRenderTargetDescriptors points must equal the number in this parameter.</para>
    </param>
    <param name="pRenderTargetDescriptors">
      <para>Type: <b>const <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" />*</b></para>
      <para>Specifies an array of <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /> structures that describe the CPU descriptor handles that represents the start of the heap of render target descriptors. If this parameter is NULL and NumRenderTargetDescriptors is 0, no render targets are bound.</para>
    </param>
    <param name="RTsSingleHandleToDescriptorRange">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>True</b> means the handle passed in is the pointer to a contiguous range of <i>NumRenderTargetDescriptors</i>  descriptors.  This case is useful if the set of descriptors to bind already happens to be contiguous in memory (so all that’s needed is a handle to the first one).  For example, if  <i>NumRenderTargetDescriptors</i> is 3 then the memory layout is taken as follows:</para>
      <para>
        <img alt="Memory layout with parameter set to true" src="https://docs.microsoft.com/windows/win32/api/d3d12mages/oms_true.png" />
      </para>
      <para>In this case the driver dereferences the handle and then increments the memory being pointed to.</para>
      <para>
        <b>False</b> means that the handle is the first of an array of <i>NumRenderTargetDescriptors</i> handles.  The false case allows an application to bind a set of descriptors from different locations at once. Again assuming that <i>NumRenderTargetDescriptors</i> is 3, the memory layout is taken as follows:</para>
      <para>
        <img alt="Memory layout with parameter set to false" src="https://docs.microsoft.com/windows/win32/api/d3d12mages/oms_false.png" />
      </para>
      <para>In this case the driver dereferences three handles that are expected to be adjacent to each other in memory.</para>
    </param>
    <param name="pDepthStencilDescriptor">
      <para>Type: <b>const <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" />*</b></para>
      <para>A pointer to a <see cref="D3D12_CPU_DESCRIPTOR_HANDLE" /> structure that describes the CPU descriptor handle that represents the start of the heap that holds the depth stencil descriptor. If this parameter is NULL, no depth stencil descriptor is bound.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.OMSetStencilRef">
    <summary>
      <para>Sets the reference value for depth stencil tests.</para>
    </summary>
    <param name="StencilRef">
      <para>Type: <b>UINT</b></para>
      <para>Reference value to perform against when doing a depth-stencil test.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.Reset">
    <summary>
      <para>Resets a command list back to its initial state as if a new command list was just created.</para>
    </summary>
    <param name="pAllocator">
      <para>Type: <b>ID3D12CommandAllocator*</b></para>
      <para>A pointer to the <see cref="ID3D12CommandAllocator" /> object that the device creates command lists from.</para>
    </param>
    <param name="pInitialState">
      <para>Type: <b>ID3D12PipelineState*</b></para>
      <para>A pointer to the <see cref="ID3D12PipelineState" /> object that contains the initial pipeline state for the command list.  This is optional and can be NULL.  If NULL, the runtime sets a dummy initial pipeline state so that drivers don't have to deal with undefined state.  The overhead for this is low, particularly for a command list, for which the overall cost of recording the command list likely dwarfs the cost of one initial state setting.  So there is little cost in  not setting the initial pipeline state parameter if it isn't convenient.</para>
      <para>For bundles on the other hand, it might make more sense to try to set the initial state parameter since bundles are likely smaller overall and can be reused frequently.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/com/structure-of-com-error-codes">HRESULT</a></b></para>
      <para>Returns <b>S_OK</b> if successful; otherwise, returns one of the following values:</para>
      <list type="bullet">
        <item>
          <description>
            <b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or the per-device limit would have been exceeded.
</description>
        </item>
        <item>
          <description>
            <b>E_OUTOFMEMORY</b> if the operating system ran out of memory.
</description>
        </item>
        <item>
          <description>
            <b>E_INVALIDARG</b> if the allocator is currently being used with another command list in the "recording" state or if the specified allocator was created with the wrong type.
</description>
        </item>
      </list>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/d3d12-graphics-reference-returnvalues">Direct3D 12 Return Codes</a> for other possible return values.</para>
    </returns>
    <remarks>
      <para>By using <b>Reset</b>, you can re-use command list tracking structures without any allocations. Unlike <see cref="ID3D12CommandAllocator.Reset" />, you can call <b>Reset</b> while the command list is still being executed. A typical pattern is to submit a command list and then immediately reset it to reuse the allocated memory for another command list.</para>
      <para>You can use <b>Reset</b> for both direct command lists and bundles.</para>
      <para>The command allocator that <b>Reset</b> takes as input can be associated with no more than one recording command list at a time.  The allocator type, direct command list or bundle, must match the type of command list that is being created.</para>
      <para>If a bundle doesn't specify a resource heap, it can't make changes to which descriptor tables are bound. Either way, bundles can't change the resource heap within the bundle. If a heap is specified for a bundle, the heap must match the calling 'parent' command list’s heap.</para>
      <h3>Runtime validation</h3>
      <para>Before an app calls <b>Reset</b>, the command list must be in the "closed" state.  <b>Reset</b> will fail if the command list isn't in the "closed" state.</para>
      <para>
        <b>Note</b>  If a call to <see cref="ID3D12GraphicsCommandList.Close" /> fails, the command list can never be reset.  Calling <b>Reset</b> will result in the same error being returned that <b>ID3D12GraphicsCommandList.Close</b> returned.</para>
      <para>After <b>Reset</b> succeeds, the command list is left in the "recording" state.  <b>Reset</b> will fail if it would cause the maximum concurrently recording command list limit, which is specified at device creation, to be exceeded.</para>
      <para>Apps must specify a command list allocator.  The runtime will ensure that an allocator is never associated with more than one recording command list at the same time.</para>
      <para>
        <b>Reset</b> fails for bundles that are referenced by a not yet submitted command list.</para>
      <h3>Debug layer</h3>
      <para>The debug layer will also track graphics processing unit (GPU) progress and issue an error if it can't prove that there are no outstanding executions of the command list.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.Reset</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12CommandAllocator.Reset" />
    <seealso cref="ID3D12Device.CreateCommandList" />
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ResolveQueryData">
    <summary>
      <para>Extracts data from a query. <b>ResolveQueryData</b> works with all heap types (default, upload, and readback).</para>
    </summary>
    <param name="pQueryHeap">
      <para>Type: <b><see cref="ID3D12QueryHeap" />*</b></para>
      <para>Specifies the  <see cref="ID3D12QueryHeap" /> containing the queries to resolve.</para>
    </param>
    <param name="Type">
      <para>Type: <b><see cref="D3D12_QUERY_TYPE" /></b></para>
      <para>Specifies the type of query, one member of <see cref="D3D12_QUERY_TYPE" />.</para>
    </param>
    <param name="StartIndex">
      <para>Type: <b>UINT</b></para>
      <para>Specifies an index of the first query to resolve.</para>
    </param>
    <param name="NumQueries">
      <para>Type: <b>UINT</b></para>
      <para>Specifies the number of queries to resolve.</para>
    </param>
    <param name="pDestinationBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>Specifies an <see cref="ID3D12Resource" /> destination buffer, which must be in the state
<see cref="D3D12_RESOURCE_STATE_COPY_DEST" />.</para>
    </param>
    <param name="AlignedDestinationBufferOffset">
      <para>Type: <b>UINT64</b></para>
      <para>Specifies an alignment offset into the destination buffer.
Must be a multiple of 8 bytes.</para>
    </param>
    <remarks>
      <para>
        <b>ResolveQueryData</b> performs a batched operation that writes query data into a destination buffer.  Query data is written contiguously to the destination buffer, and the parameter.</para>
      <para>
        <b>ResolveQueryData</b> turns application-opaque query data in an application-opaque query heap into adapter-agnostic values usable by your application. Resolving queries within a heap that have not been completed (so have had <see cref="ID3D12GraphicsCommandList.BeginQuery" /> called for them, but not <see cref="ID3D12GraphicsCommandList.EndQuery" />), or that have been uninitialized, results in undefined behavior and might cause device hangs or removal. The debug layer will emit an error if it detects an application has resolved incomplete or uninitialized queries.</para>
      <blockquote>
        <para>[!NOTE]
Resolving incomplete or uninitialized queries is undefined behavior because the driver might internally store GPUVAs or other data within unresolved queries. And so attempting to resolve these queries on uninitialized data could cause a page fault or device hang. Older versions of the debug layer didn't validate this behavior.</para>
      </blockquote>
      <para>Binary occlusion queries write 64-bits per query. The least significant bit is either 0 (the object was entirely occluded) or 1 (at least 1 sample of the object would have been drawn). The rest of the bits are 0. Occlusion queries write 64-bits per query. The value is the number of samples that passed testing. Timestamp queries write 64-bits per query, which is a tick value that must be compared to the respective command queue frequency (see <a href="https://docs.microsoft.com//windows/win32/direct3d12/timing">Timing</a>).</para>
      <para>Pipeline statistics queries write a <see cref="D3D12_QUERY_DATA_PIPELINE_STATISTICS" /> structure per query. All stream-out statistics queries write a <see cref="D3D12_QUERY_DATA_SO_STATISTICS" /> structure per query.</para>
      <para>The core runtime will validate the following.</para>
      <list type="bullet">
        <item>
          <description>
            <i>StartIndex</i> and <i>NumQueries</i> are within range.
</description>
        </item>
        <item>
          <description>
            <i>AlignedDestinationBufferOffset</i> is a multiple of 8 bytes.
</description>
        </item>
        <item>
          <description>
            <i>DestinationBuffer</i> is a buffer.
</description>
        </item>
        <item>
          <description>The written data will not overflow the output buffer.
</description>
        </item>
        <item>
          <description>The query type must be supported by the command list type.
</description>
        </item>
        <item>
          <description>The query type must be supported by the query heap.
</description>
        </item>
      </list>
      <para>The debug layer will issue a warning if the destination buffer is not in the D3D12_RESOURCE_STATE_COPY_DEST state,
or if any queries being resolved have not had <see cref="ID3D12GraphicsCommandList.EndQuery" /> called on them.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.ResolveSubresource">
    <summary>
      <para>Copy a multi-sampled resource into a non-multi-sampled resource.</para>
    </summary>
    <param name="pDstResource">
      <para>Type: [in] <b>ID3D12Resource*</b></para>
      <para>Destination resource. Must be a created on a <see cref="D3D12_HEAP_TYPE_DEFAULT" /> heap and be single-sampled. See <see cref="ID3D12Resource" />.</para>
    </param>
    <param name="DstSubresource">
      <para>Type: [in] <b>UINT</b></para>
      <para>A zero-based index, that identifies the destination subresource. Use <a href="https://docs.microsoft.com//windows/win32/direct3d12/d3d12calcsubresource">D3D12CalcSubresource</a> to calculate the subresource index if the parent resource is complex.</para>
    </param>
    <param name="pSrcResource">
      <para>Type: [in] <b>ID3D12Resource*</b></para>
      <para>Source resource. Must be multisampled.</para>
    </param>
    <param name="SrcSubresource">
      <para>Type: [in] <b>UINT</b></para>
      <para>The source subresource of the source resource.</para>
    </param>
    <param name="Format">
      <para>Type: [in] <b>DXGI_FORMAT</b></para>
      <para>A <see cref="DXGI_FORMAT" /> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</para>
    </param>
    <remarks>
      <h3>Debug layer</h3>
      <para>The debug layer will issue an error if the subresources referenced by the source view is not in the  <see cref="D3D12_RESOURCE_STATE_RESOLVE_SOURCE" /> state.</para>
      <para>The debug layer will issue an error if the destination buffer is not in the  <see cref="D3D12_RESOURCE_STATE_RESOLVE_DEST" /> state.</para>
      <para>The source and destination resources must be the same resource type and have the same dimensions. In addition, they must have compatible formats. There are three scenarios for this:</para>
      <list type="table">
        <listheader>
          <description>Scenario</description>
          <description>Requirements</description>
        </listheader>
        <item>
          <description>Source and destination are prestructured and typed</description>
          <description>Both the source and destination must have identical formats and that format must be specified in the Format parameter.</description>
        </item>
        <item>
          <description>One resource is prestructured and typed and the other is prestructured and typeless</description>
          <description>The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is DXGI_FORMAT_R32_FLOAT and the typeless resource is DXGI_FORMAT_R32_TYPELESS). The format of the typed resource must be specified in the Format parameter.</description>
        </item>
        <item>
          <description>Source and destination are prestructured and typeless</description>
          <description>Both the source and destination must have the same typeless format (i.e. both must have DXGI_FORMAT_R32_TYPELESS), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are DXGI_FORMAT_R32_TYPELESS then DXGI_FORMAT_R32_FLOAT could be specified in the Format parameter).
For example, given the DXGI_FORMAT_R16G16B16A16_TYPELESS format:
<list type="bullet"><item><description>The source (or dest) format could be DXGI_FORMAT_R16G16B16A16_UNORM</description></item><item><description>The dest (or source) format could be DXGI_FORMAT_R16G16B16A16_FLOAT</description></item></list></description>
        </item>
      </list>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/win32/direct3d12/subresources">Subresources</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.ResourceBarrier">
    <summary>
      <para>Notifies the driver that it needs to synchronize multiple accesses to resources.</para>
    </summary>
    <param name="NumBarriers">
      <para>Type: <b>UINT</b></para>
      <para>The number of submitted barrier descriptions.</para>
    </param>
    <param name="pBarriers">
      <para>Type: <b>const <see cref="D3D12_RESOURCE_BARRIER" />*</b></para>
      <para>Pointer to an array of barrier descriptions.</para>
    </param>
    <remarks>
      <para>There are three types of barrier descriptions:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="D3D12_RESOURCE_TRANSITION_BARRIER" /> -  Transition barriers  indicate that a set of subresources transition between different usages.  The caller must specify the <i>before</i> and <i>after</i> usages of the subresources.  The D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time.
</description>
        </item>
        <item>
          <description>
            <see cref="D3D12_RESOURCE_ALIASING_BARRIER" /> - Aliasing barriers indicate a transition between usages of two different resources which have mappings into the same heap.  The application can specify both the before and the after resource.  Note that one or both resources can be NULL (indicating that any tiled resource could cause aliasing).
</description>
        </item>
        <item>
          <description>
            <see cref="D3D12_RESOURCE_UAV_BARRIER" /> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular resource must complete before any future UAV accesses (read or write) can begin.  The specified resource may be NULL.  It is not necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV.  Additionally, it is not necessary to insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to execute the UAV accesses in any order.  The resource can be NULL (indicating that any UAV access could require the barrier).
</description>
        </item>
      </list>
      <para>When <b>ID3D12GraphicsCommandList.ResourceBarrier</b> is passed an array of resource barrier descriptions, the API behaves as if it was called N times (1 for each array element), in the specified order.
Transitions should be batched together into a single API call when possible, as a performance optimization.</para>
      <para>For descriptions of the usage states a subresource can be in, see the <see cref="D3D12_RESOURCE_STATES" /> enumeration and the <a href="https://docs.microsoft.com//windows/win32/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12">Using Resource Barriers to Synchronize Resource States in Direct3D 12</a> section.</para>
      <para>All subresources in a resource must be in the RENDER_TARGET state, or DEPTH_WRITE state, for render targets/depth-stencil resources respectively, when  <see cref="ID3D12GraphicsCommandList.DiscardResource" /> is called.</para>
      <para>When a back buffer is presented, it must be in the D3D12_RESOURCE_STATE_PRESENT state.  If <see cref="IDXGISwapChain1.Present1" /> is called on a resource which is not in the PRESENT state, a debug layer warning will be emitted.</para>
      <para>The resource usage bits are group into two categories, read-only and read/write.</para>
      <para>The following usage bits are read-only:</para>
      <list type="bullet">
        <item>
          <description>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_INDEX_BUFFER</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_COPY_SOURCE</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_DEPTH_READ</description>
        </item>
      </list>
      <para>The following usage bits are read/write:</para>
      <list type="bullet">
        <item>
          <description>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_DEPTH_WRITE</description>
        </item>
      </list>
      <para>The following usage bits are write-only:</para>
      <list type="bullet">
        <item>
          <description>D3D12_RESOURCE_STATE_COPY_DEST</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_RENDER_TARGET</description>
        </item>
        <item>
          <description>D3D12_RESOURCE_STATE_STREAM_OUT</description>
        </item>
      </list>
      <para>At most one write bit can be set.
If any write bit is set, then no read bit may be set.
If no write bit is set, then any number of read bits may be set.</para>
      <para>At any given time, a subresource is in exactly one  state (determined by a set of flags).  The application must ensure that the states are matched when making a sequence of <b>ResourceBarrier</b> calls. In other words, the before and after states in consecutive calls to <b>ResourceBarrier</b> must agree.</para>
      <para>To transition all subresources within a resource, the application can set the subresource index to D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, which implies that all subresources are changed.</para>
      <para>For improved performance, applications should use split barriers (refer to
<a href="https://docs.microsoft.com//windows/win32/direct3d12/user-mode-heap-synchronization">Multi-engine synchronization</a>). Your application should also batch multiple transitions into a single call whenever possible.</para>
      <h3>Runtime validation</h3>
      <para>The runtime will validate that the barrier type values are valid members of the <see cref="D3D12_RESOURCE_BARRIER_TYPE" /> enumeration.</para>
      <para>In addition, the runtime checks the following:</para>
      <list type="bullet">
        <item>
          <description>The resource pointer is non-NULL.</description>
        </item>
        <item>
          <description>The subresource index is valid</description>
        </item>
        <item>
          <description>The before and after states are supported by the <see cref="D3D12_RESOURCE_BINDING_TIER" /> and <see cref="D3D12_RESOURCE_FLAGS" /> flags of the resource.
</description>
        </item>
        <item>
          <description>Reserved bits in the state masks are not set.</description>
        </item>
        <item>
          <description>The before and after states are different.</description>
        </item>
        <item>
          <description>The set of bits in the before and after states are valid.</description>
        </item>
        <item>
          <description>If the D3D12_RESOURCE_STATE_RESOLVE_SOURCE bit is set, then the resource sample count must be greater than 1.</description>
        </item>
        <item>
          <description>If the D3D12_RESOURCE_STATE_RESOLVE_DEST bit is set, then the resource sample count must be equal to 1.</description>
        </item>
      </list>
      <para>For aliasing barriers the runtime will validate that, if either resource pointer is non-NULL, it refers to a tiled resource.</para>
      <para>For UAV barriers the runtime will validate that, if the resource is non-NULL, the resource has the D3D12_RESOURCE_STATE_UNORDERED_ACCESS bind flag set.</para>
      <para>Validation failure causes <see cref="ID3D12GraphicsCommandList.Close" /> to return E_INVALIDARG.</para>
      <h3>Debug layer</h3>
      <para>The debug layer normally issues errors where runtime validation fails:</para>
      <list type="bullet">
        <item>
          <description>If a  subresource transition in a command list is inconsistent with previous transitions in the same command list. </description>
        </item>
        <item>
          <description>If a resource is used without first calling <b>ResourceBarrier</b> to put the resource into the correct state.  </description>
        </item>
        <item>
          <description>If a resource is illegally bound for read and write at the same time.</description>
        </item>
        <item>
          <description>If the <i>before</i> states passed to the <b>ResourceBarrier</b> do not match the <i>after</i> states of previous calls to <b>ResourceBarrier</b>, including the aliasing case.
</description>
        </item>
      </list>
      <para>Whereas the debug layer attempts to validate the runtime rules, it operates conservatively so that debug layer errors are real errors, and in some cases real errors may not produce debug layer errors.</para>
      <para>The debug layer will issue warnings in the following cases:</para>
      <list type="bullet">
        <item>
          <description>All of the cases where the D3D12 debug layer would issues warnings for <see cref="ID3D12GraphicsCommandList.ResourceBarrier" />.
</description>
        </item>
        <item>
          <description>If a depth buffer is used in a non-read-only mode while the resource has the D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE usage bit set.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/win32/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.ResourceBarrier</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/win32/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/win32/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12">Using Resource Barriers to Synchronize Resource States in Direct3D 12</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.RSSetScissorRects">
    <summary>
      <para>Binds an array of scissor rectangles to the rasterizer stage.</para>
    </summary>
    <param name="NumRects">
      <para>Type: <b>UINT</b></para>
      <para>The number of scissor rectangles to bind.</para>
    </param>
    <param name="pRects">
      <para>Type: <b>const D3D12_RECT*</b></para>
      <para>An array of scissor rectangles.</para>
    </param>
    <remarks>
      <para>All scissor rectangles must be set atomically as one operation. Any scissor rectangles not defined by the call are disabled.</para>
      <para>Which scissor rectangle to use is determined by the <code>SV_ViewportArrayIndex</code> semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the <code>SV_ViewportArrayIndex</code> semantic then Direct3D will use the first scissor rectangle in the array.</para>
      <para>Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <see cref="RSSetViewports" />).</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.RSSetScissorRects</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>// Command list allocators can only be reset when the associated
// command lists have finished execution on the GPU; apps should use
// fences to determine GPU execution progress.
ThrowIfFailed(m_commandAllocator-&gt;Reset());

// However, when ExecuteCommandList() is called on a particular command
// list, that command list can then be reset at any time and must be before
// re-recording.
ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

// Set necessary state.
m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

// Indicate that the back buffer will be used as a render target.
m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

// Record commands.
const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

// Indicate that the back buffer will now be used to present.
m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

ThrowIfFailed(m_commandList-&gt;Close());

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.RSSetViewports">
    <summary>
      <para>Bind an array of viewports to the rasterizer stage of the pipeline.</para>
    </summary>
    <param name="NumViewports">
      <para>Type: <b>UINT</b></para>
      <para>Number of viewports to bind.
The range of valid values is (0, D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE).</para>
    </param>
    <param name="pViewports">
      <para>Type: <b>const <see cref="D3D12_VIEWPORT" />*</b></para>
      <para>An array of <see cref="D3D12_VIEWPORT" /> structures to bind to the device.</para>
    </param>
    <remarks>
      <para>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</para>
      <para>Which viewport to use is determined by the <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics">SV_ViewportArrayIndex</a> semantic output by a geometry shader; if a geometry shader does not specify the semantic, Direct3D will use the first viewport in the array.</para>
      <para>
        <b>Note</b>  Even though you specify float values to the members of the <see cref="D3D12_VIEWPORT" /> structure for the <i>pViewports</i> array in a call to  <b>RSSetViewports</b> for <a href="https://docs.microsoft.com//windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro">feature levels</a> 9_x, <b>RSSetViewports</b> uses DWORDs internally. Because of this behavior, when you use a negative top left corner for the viewport, the call to  <b>RSSetViewports</b> for feature levels 9_x fails. This failure occurs because <b>RSSetViewports</b> for 9_x casts the floating point values into unsigned integers without validation, which results in integer overflow.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12HelloTriangle</a> sample uses <b>ID3D12GraphicsCommandList.RSSetViewports</b> as follows:</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <code>void D3D12HelloTriangle.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocator-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocator.Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());
    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;DrawInstanced(3, 1, 0, 0);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRoot32BitConstant">
    <summary>
      <para>Sets a constant in the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b>UINT</b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="SrcData">
      <para>Type: <b>UINT</b></para>
      <para>The source data for the constant to set.</para>
    </param>
    <param name="DestOffsetIn32BitValues">
      <para>Type: <b>UINT</b></para>
      <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRoot32BitConstants">
    <summary>
      <para>Sets a group of constants in the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="Num32BitValuesToSet">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of constants to set in the root signature.</para>
    </param>
    <param name="pSrcData">
      <para>Type: <b>const void*</b></para>
      <para>The source data for the group of constants to set.</para>
    </param>
    <param name="DestOffsetIn32BitValues">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRootConstantBufferView">
    <summary>
      <para>Sets a CPU descriptor handle for the constant buffer in the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b>UINT</b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>Specifies the D3D12_GPU_VIRTUAL_ADDRESS of the constant buffer.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRootDescriptorTable">
    <summary>
      <para>Sets a descriptor table into the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b>UINT</b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BaseDescriptor">
      <para>Type: <b><see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRootShaderResourceView">
    <summary>
      <para>Sets a CPU descriptor handle for the shader resource in the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b>UINT</b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>The GPU virtual address of the buffer.
D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRootSignature">
    <summary>
      <para>Sets the layout of the compute root signature.</para>
    </summary>
    <param name="pRootSignature">
      <para>Type: <b><see cref="ID3D12RootSignature" />*</b></para>
      <para>A pointer to the <see cref="ID3D12RootSignature" /> object.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetComputeRootUnorderedAccessView">
    <summary>
      <para>Sets a CPU descriptor handle for the unordered-access-view resource in the compute root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>The GPU virtual address of the buffer.
D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetDescriptorHeaps">
    <summary>
      <para>Changes the currently bound descriptor heaps that are associated with a command list.</para>
    </summary>
    <param name="NumDescriptorHeaps">
      <para>Type: [in] <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>Number of descriptor heaps to bind.</para>
    </param>
    <param name="ppDescriptorHeaps">
      <para>Type: [in] <b><see cref="ID3D12DescriptorHeap" />*</b></para>
      <para>A pointer to an array of <see cref="ID3D12DescriptorHeap" /> objects for the heaps to set on the command list.</para>
      <para>You can only bind descriptor heaps of type <see cref="D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV" /> and <see cref="D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER" />.</para>
      <para>Only one descriptor heap of each type can be set at one time, which means a maximum of 2 heaps (one sampler, one CBV/SRV/UAV) can be set at one time.</para>
    </param>
    <remarks>
      <para>
        <b>SetDescriptorHeaps</b> can be called on a bundle, but the bundle descriptor heaps must match the calling command list descriptor heap. For more information on bundle restrictions, refer to <a href="https://docs.microsoft.com//windows/desktop/direct3d12/recording-command-lists-and-bundles">Creating and Recording Command Lists and Bundles</a>.</para>
      <para>All previously set heaps are unset by the call. At most one heap of each shader-visible type can be set in the call.</para>
      <para>Changing descriptor heaps can incur a pipeline flush on some hardware. Because of this, it is recommended to use a single shader-visible heap of each type, and set it once per frame, rather than regularly changing the bound descriptor heaps. Instead, use <see cref="ID3D12Device.CopyDescriptors" /> and <see cref="ID3D12Device.CopyDescriptorsSimple" /> to copy the required descriptors from shader-opaque heaps to the single shader-visible heap as required during rendering.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/descriptor-heaps">Descriptor Heaps</seealso>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRoot32BitConstant">
    <summary>
      <para>Sets a constant in the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="SrcData">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The source data for the constant to set.</para>
    </param>
    <param name="DestOffsetIn32BitValues">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The offset, in 32-bit values, to set the constant in the root signature.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRoot32BitConstants">
    <summary>
      <para>Sets a group of constants in the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="Num32BitValuesToSet">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The number of constants to set in the root signature.</para>
    </param>
    <param name="pSrcData">
      <para>Type: <b>const void*</b></para>
      <para>The source data for the group of constants to set.</para>
    </param>
    <param name="DestOffsetIn32BitValues">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The offset, in 32-bit values, to set the first constant of the group in the root signature.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRootConstantBufferView">
    <summary>
      <para>Sets a CPU descriptor handle for the constant buffer in the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>The GPU virtual address of the constant buffer.
D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRootDescriptorTable">
    <summary>
      <para>Sets a descriptor table into the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BaseDescriptor">
      <para>Type: <b><see cref="D3D12_GPU_DESCRIPTOR_HANDLE" /></b></para>
      <para>A GPU_descriptor_handle object for the base descriptor to set.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRootShaderResourceView">
    <summary>
      <para>Sets a CPU descriptor handle for the shader resource in the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>The GPU virtual address of the Buffer.
Textures are not supported. D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRootSignature">
    <summary>
      <para>Sets the layout of the graphics root signature.</para>
    </summary>
    <param name="pRootSignature">
      <para>Type: <b><see cref="ID3D12RootSignature" />*</b></para>
      <para>A pointer to the <see cref="ID3D12RootSignature" /> object.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetGraphicsRootUnorderedAccessView">
    <summary>
      <para>Sets a CPU descriptor handle for the unordered-access-view resource in the graphics root signature.</para>
    </summary>
    <param name="RootParameterIndex">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/WinProg/windows-data-types">UINT</a></b></para>
      <para>The slot number for binding.</para>
    </param>
    <param name="BufferLocation">
      <para>Type: <b>D3D12_GPU_VIRTUAL_ADDRESS</b></para>
      <para>The GPU virtual address of the buffer.
D3D12_GPU_VIRTUAL_ADDRESS is a typedef'd alias of UINT64.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetMarker">
    <summary>
      <para>Not intended to be called directly.  Use the
<a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">PIX event runtime</a> to insert events into a command list.</para>
    </summary>
    <param name="Metadata">
      <para>Type: <b>UINT</b></para>
      <para>Internal.</para>
    </param>
    <param name="pData">
      <para>Type: <b>const void*</b></para>
      <para>Internal.</para>
    </param>
    <param name="Size">
      <para>Type: <b>UINT</b></para>
      <para>Internal.</para>
    </param>
    <remarks>
      <para>This is a support method used internally by the PIX event runtime.  It is not intended to be called directly.</para>
      <para>To insert instrumentation markers at the current location within a D3D12 command list, use the <b>PIXSetMarker</b> function.  This is provided by the <a href="https://devblogs.microsoft.com/pix/winpixeventruntime/">WinPixEventRuntime</a> NuGet package.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetPipelineState">
    <summary>
      <para>Sets all shaders and programs most of the fixed-function state of the graphics processing unit (GPU) pipeline.</para>
    </summary>
    <param name="pPipelineState">
      <para>Type: <b><see cref="ID3D12PipelineState" />*</b></para>
      <para>Pointer to the <see cref="ID3D12PipelineState" /> containing the pipeline state data.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList.SetPredication">
    <summary>
      <para>Sets a rendering predicate.</para>
    </summary>
    <param name="pBuffer">
      <para>Type: <b><see cref="ID3D12Resource" />*</b></para>
      <para>The buffer, as an <see cref="ID3D12Resource" />, which must be in the <see cref="D3D12_RESOURCE_STATE_PREDICATION" /> or <see cref="D3D21_RESOURCE_STATE_INDIRECT_ARGUMENT" /> state (both values are identical, and provided as aliases for clarity), or <b>NULL</b> to disable predication.</para>
    </param>
    <param name="AlignedBufferOffset">
      <para>Type: <b>UINT64</b></para>
      <para>The aligned buffer offset, as a UINT64.</para>
    </param>
    <param name="Operation">
      <para>Type: <b><see cref="D3D12_PREDICATION_OP" /></b></para>
      <para>Specifies a <see cref="D3D12_PREDICATION_OP" />, such as D3D12_PREDICATION_OP_EQUAL_ZERO or D3D12_PREDICATION_OP_NOT_EQUAL_ZERO.</para>
    </param>
    <remarks>
      <para>Use this method to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting predicate data of the predicate is equal to the operation specified.</para>
      <para>Unlike Direct3D 11, in Direct3D 12 predication state is not inherited by direct command lists, and predication is always respected (there are no predication hints).
All direct command lists begin with predication disabled.
Bundles do inherit predication state.
It is legal for the same predicate to be bound multiple times.</para>
      <para>Illegal API calls will result in <see cref="Close" /> returning an error,
or <see cref="ID3D12CommandQueue.ExecuteCommandLists" /> dropping the command list and removing the device.</para>
      <para>The debug layer will issue errors whenever the runtime validation fails.</para>
      <para>Refer to <a href="https://docs.microsoft.com//windows/desktop/direct3d12/predication">Predication</a> for more information.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12PredicationQueries</a> sample uses <b>ID3D12GraphicsCommandList.SetPredication</b> as follows:</para>
      <code>// Fill the command list with all the render commands and dependent state.
void D3D12PredicationQueries.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    ID3D12DescriptorHeap* ppHeaps[] = { m_cbvHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(m_dsvHeap-&gt;GetCPUDescriptorHandleForHeapStart());
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, &amp;amp;amp;amp;amp;amp;dsvHandle);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    m_commandList-&gt;ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

    // Draw the quads and perform the occlusion query.
    {
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvFarQuad(m_cbvHeap-&gt;GetGPUDescriptorHandleForHeapStart(), m_frameIndex * CbvCountPerFrame, m_cbvSrvDescriptorSize);
        CD3DX12_GPU_DESCRIPTOR_HANDLE cbvNearQuad(cbvFarQuad, m_cbvSrvDescriptorSize);

        m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
        m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);

        // Draw the far quad conditionally based on the result of the occlusion query
        // from the previous frame.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPredication(m_queryResult.Get(), 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;DrawInstanced(4, 1, 0, 0);

        // Disable predication and always draw the near quad.
        m_commandList-&gt;SetPredication(nullptr, 0, D3D12_PREDICATION_OP_EQUAL_ZERO);
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvNearQuad);
        m_commandList-&gt;DrawInstanced(4, 1, 4, 0);

        // Run the occlusion query with the bounding box quad.
        m_commandList-&gt;SetGraphicsRootDescriptorTable(0, cbvFarQuad);
        m_commandList-&gt;SetPipelineState(m_queryState.Get());
        m_commandList-&gt;BeginQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);
        m_commandList-&gt;DrawInstanced(4, 1, 8, 0);
        m_commandList-&gt;EndQuery(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0);

        // Resolve the occlusion query and store the results in the query result buffer
        // to be used on the subsequent frame.
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_PREDICATION, D3D12_RESOURCE_STATE_COPY_DEST));
        m_commandList-&gt;ResolveQueryData(m_queryHeap.Get(), D3D12_QUERY_TYPE_BINARY_OCCLUSION, 0, 1, m_queryResult.Get(), 0);
        m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_queryResult.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_PREDICATION));
    }

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso cref="ID3D12GraphicsCommandList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/predication-queries">Predication queries walk-through</seealso>
  </member>
  <member name="ID3D12GraphicsCommandList.SOSetTargets">
    <summary>
      <para>Sets the stream output buffer views.</para>
    </summary>
    <param name="StartSlot">
      <para>Type: <b>UINT</b></para>
      <para>Index into the device's zero-based array to begin setting stream output buffers.</para>
    </param>
    <param name="NumViews">
      <para>Type: <b>UINT</b></para>
      <para>The number of entries in the <i>pViews</i> array.</para>
    </param>
    <param name="pViews">
      <para>Type: <b>const <see cref="D3D12_STREAM_OUTPUT_BUFFER_VIEW" />*</b></para>
      <para>Specifies an array of  <see cref="D3D12_STREAM_OUTPUT_BUFFER_VIEW" /> structures.</para>
    </param>
    <seealso cref="ID3D12GraphicsCommandList" />
  </member>
  <member name="ID3D12GraphicsCommandList">
    <summary>
      <para>Encapsulates a list of graphics commands for rendering. Includes APIs for instrumenting the command list execution, and for setting and clearing the pipeline state.
<b>Note</b>  The latest version of this interface is <see cref="ID3D12GraphicsCommandList1" /> introduced in the Windows 10 Creators Update. Applications targetting Windows 10 Creators Update should use the <b>ID3D12GraphicsCommandList1</b> interface instead of <b>ID3D12GraphicsCommandList</b>.</para>
    </summary>
    <remarks>
      <para>This interface is new to D3D12, encapsulating much of the functionality of the <see cref="ID3D11CommandList" /> interface, and including the new functionality described in <a href="https://docs.microsoft.com//windows/desktop/direct3d12/rendering">Rendering</a>.</para>
      <h4>Examples</h4>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/direct3d12/working-samples">D3D12nBodyGravity</a> sample uses <b>ID3D12GraphicsCommandList</b> as follows:</para>
      <para>Declare the pipeline objects.</para>
      <code>D3D12_VIEWPORT m_viewport;
D3D12_RECT m_scissorRect;
ComPtr&lt;IDXGISwapChain3&gt; m_swapChain;
ComPtr&lt;ID3D12Device&gt; m_device;
ComPtr&lt;ID3D12Resource&gt; m_renderTargets[FrameCount];
ComPtr&lt;ID3D12CommandAllocator&gt; m_commandAllocator;
ComPtr&lt;ID3D12CommandQueue&gt; m_commandQueue;
ComPtr&lt;ID3D12RootSignature&gt; m_rootSignature;
ComPtr&lt;ID3D12DescriptorHeap&gt; m_rtvHeap;
ComPtr&lt;ID3D12PipelineState&gt; m_pipelineState;
ComPtr&lt;ID3D12GraphicsCommandList&gt; m_commandList;
UINT m_rtvDescriptorSize;

</code>
      <para>Populating command lists.</para>
      <code>// Fill the command list with all the render commands and dependent state.
void D3D12nBodyGravity.PopulateCommandList()
{
    // Command list allocators can only be reset when the associated
    // command lists have finished execution on the GPU; apps should use
    // fences to determine GPU execution progress.
    ThrowIfFailed(m_commandAllocators[m_frameIndex]-&gt;Reset());

    // However, when ExecuteCommandList() is called on a particular command
    // list, that command list can then be reset at any time and must be before
    // re-recording.
    ThrowIfFailed(m_commandList-&gt;Reset(m_commandAllocators[m_frameIndex].Get(), m_pipelineState.Get()));

    // Set necessary state.
    m_commandList-&gt;SetPipelineState(m_pipelineState.Get());
    m_commandList-&gt;SetGraphicsRootSignature(m_rootSignature.Get());

    m_commandList-&gt;SetGraphicsRootConstantBufferView(RootParameterCB, m_constantBufferGS-&gt;GetGPUVirtualAddress() + m_frameIndex * sizeof(ConstantBufferGS));

    ID3D12DescriptorHeap* ppHeaps[] = { m_srvUavHeap.Get() };
    m_commandList-&gt;SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);

    m_commandList-&gt;IASetVertexBuffers(0, 1, &amp;amp;amp;amp;amp;amp;m_vertexBufferView);
    m_commandList-&gt;IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_POINTLIST);
    m_commandList-&gt;RSSetScissorRects(1, &amp;amp;amp;amp;amp;amp;m_scissorRect);

    // Indicate that the back buffer will be used as a render target.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET));

    CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(), m_frameIndex, m_rtvDescriptorSize);
    m_commandList-&gt;OMSetRenderTargets(1, &amp;amp;amp;amp;amp;amp;rtvHandle, FALSE, nullptr);

    // Record commands.
    const float clearColor[] = { 0.0f, 0.0f, 0.1f, 0.0f };
    m_commandList-&gt;ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

    // Render the particles.
    float viewportHeight = static_cast&lt;float&gt;(static_cast&lt;UINT&gt;(m_viewport.Height) / m_heightInstances);
    float viewportWidth = static_cast&lt;float&gt;(static_cast&lt;UINT&gt;(m_viewport.Width) / m_widthInstances);
    for (UINT n = 0; n &lt; ThreadCount; n++)
    {
        const UINT srvIndex = n + (m_srvIndex[n] == 0 ? SrvParticlePosVelo0 : SrvParticlePosVelo1);

        D3D12_VIEWPORT viewport;
        viewport.TopLeftX = (n % m_widthInstances) * viewportWidth;
        viewport.TopLeftY = (n / m_widthInstances) * viewportHeight;
        viewport.Width = viewportWidth;
        viewport.Height = viewportHeight;
        viewport.MinDepth = D3D12_MIN_DEPTH;
        viewport.MaxDepth = D3D12_MAX_DEPTH;
        m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;viewport);

        CD3DX12_GPU_DESCRIPTOR_HANDLE srvHandle(m_srvUavHeap-&gt;GetGPUDescriptorHandleForHeapStart(), srvIndex, m_srvUavDescriptorSize);
        m_commandList-&gt;SetGraphicsRootDescriptorTable(RootParameterSRV, srvHandle);

        m_commandList-&gt;DrawInstanced(ParticleCount, 1, 0, 0);
    }

    m_commandList-&gt;RSSetViewports(1, &amp;amp;amp;amp;amp;amp;m_viewport);

    // Indicate that the back buffer will now be used to present.
    m_commandList-&gt;ResourceBarrier(1, &amp;amp;amp;amp;amp;amp;CD3DX12_RESOURCE_BARRIER.Transition(m_renderTargets[m_frameIndex].Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));

    ThrowIfFailed(m_commandList-&gt;Close());
}

</code>
      <para>Refer to the <a href="https://docs.microsoft.com//windows/desktop/direct3d12/notes-on-example-code">Example Code in the D3D12 Reference</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/direct3d12/direct3d-12-interfaces">Core Interfaces</seealso>
    <seealso cref="ID3D12CommandList" />
    <seealso cref="ID3D12GraphicsCommandList1" />
  </member>
</doc>